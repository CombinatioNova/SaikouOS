var Mh = Object.defineProperty; var Dh = (t, e, n) => e in t ? Mh(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n; var te = (t, e, n) => (Dh(t, typeof e != "symbol" ? e + "" : e, n), n), Lh = (t, e, n) => { if (!e.has(t)) throw TypeError("Cannot " + n) }; var ls = (t, e, n) => { if (e.has(t)) throw TypeError("Cannot add the same private member more than once"); e instanceof WeakSet ? e.add(t) : e.set(t, n) }; var Sr = (t, e, n) => (Lh(t, e, "access private method"), n); (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) o(r); new MutationObserver(r => { for (const i of r) if (i.type === "childList") for (const s of i.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && o(s) }).observe(document, { childList: !0, subtree: !0 }); function n(r) { const i = {}; return r.integrity && (i.integrity = r.integrity), r.referrerPolicy && (i.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? i.credentials = "include" : r.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i } function o(r) { if (r.ep) return; r.ep = !0; const i = n(r); fetch(r.href, i) } })(); function Uh(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var Ld = { exports: {} }, Ui = {}, Ud = { exports: {} }, B = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var cr = Symbol.for("react.element"), Fh = Symbol.for("react.portal"), bh = Symbol.for("react.fragment"), Vh = Symbol.for("react.strict_mode"), Gh = Symbol.for("react.profiler"), $h = Symbol.for("react.provider"), qh = Symbol.for("react.context"), Hh = Symbol.for("react.forward_ref"), zh = Symbol.for("react.suspense"), Bh = Symbol.for("react.memo"), Jh = Symbol.for("react.lazy"), Ka = Symbol.iterator; function Wh(t) { return t === null || typeof t != "object" ? null : (t = Ka && t[Ka] || t["@@iterator"], typeof t == "function" ? t : null) } var Fd = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, bd = Object.assign, Vd = {}; function co(t, e, n) { this.props = t, this.context = e, this.refs = Vd, this.updater = n || Fd } co.prototype.isReactComponent = {}; co.prototype.setState = function (t, e) { if (typeof t != "object" && typeof t != "function" && t != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, t, e, "setState") }; co.prototype.forceUpdate = function (t) { this.updater.enqueueForceUpdate(this, t, "forceUpdate") }; function Gd() { } Gd.prototype = co.prototype; function Vl(t, e, n) { this.props = t, this.context = e, this.refs = Vd, this.updater = n || Fd } var Gl = Vl.prototype = new Gd; Gl.constructor = Vl; bd(Gl, co.prototype); Gl.isPureReactComponent = !0; var Oa = Array.isArray, $d = Object.prototype.hasOwnProperty, $l = { current: null }, qd = { key: !0, ref: !0, __self: !0, __source: !0 }; function Hd(t, e, n) { var o, r = {}, i = null, s = null; if (e != null) for (o in e.ref !== void 0 && (s = e.ref), e.key !== void 0 && (i = "" + e.key), e) $d.call(e, o) && !qd.hasOwnProperty(o) && (r[o] = e[o]); var u = arguments.length - 2; if (u === 1) r.children = n; else if (1 < u) { for (var c = Array(u), d = 0; d < u; d++)c[d] = arguments[d + 2]; r.children = c } if (t && t.defaultProps) for (o in u = t.defaultProps, u) r[o] === void 0 && (r[o] = u[o]); return { $$typeof: cr, type: t, key: i, ref: s, props: r, _owner: $l.current } } function Yh(t, e) { return { $$typeof: cr, type: t.type, key: e, ref: t.ref, props: t.props, _owner: t._owner } } function ql(t) { return typeof t == "object" && t !== null && t.$$typeof === cr } function Kh(t) { var e = { "=": "=0", ":": "=2" }; return "$" + t.replace(/[=:]/g, function (n) { return e[n] }) } var Qa = /\/+/g; function as(t, e) { return typeof t == "object" && t !== null && t.key != null ? Kh("" + t.key) : e.toString(36) } function Hr(t, e, n, o, r) { var i = typeof t; (i === "undefined" || i === "boolean") && (t = null); var s = !1; if (t === null) s = !0; else switch (i) { case "string": case "number": s = !0; break; case "object": switch (t.$$typeof) { case cr: case Fh: s = !0 } }if (s) return s = t, r = r(s), t = o === "" ? "." + as(s, 0) : o, Oa(r) ? (n = "", t != null && (n = t.replace(Qa, "$&/") + "/"), Hr(r, e, n, "", function (d) { return d })) : r != null && (ql(r) && (r = Yh(r, n + (!r.key || s && s.key === r.key ? "" : ("" + r.key).replace(Qa, "$&/") + "/") + t)), e.push(r)), 1; if (s = 0, o = o === "" ? "." : o + ":", Oa(t)) for (var u = 0; u < t.length; u++) { i = t[u]; var c = o + as(i, u); s += Hr(i, e, n, c, r) } else if (c = Wh(t), typeof c == "function") for (t = c.call(t), u = 0; !(i = t.next()).done;)i = i.value, c = o + as(i, u++), s += Hr(i, e, n, c, r); else if (i === "object") throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead."); return s } function Tr(t, e, n) { if (t == null) return t; var o = [], r = 0; return Hr(t, o, "", "", function (i) { return e.call(n, i, r++) }), o } function Oh(t) { if (t._status === -1) { var e = t._result; e = e(), e.then(function (n) { (t._status === 0 || t._status === -1) && (t._status = 1, t._result = n) }, function (n) { (t._status === 0 || t._status === -1) && (t._status = 2, t._result = n) }), t._status === -1 && (t._status = 0, t._result = e) } if (t._status === 1) return t._result.default; throw t._result } var Ue = { current: null }, zr = { transition: null }, Qh = { ReactCurrentDispatcher: Ue, ReactCurrentBatchConfig: zr, ReactCurrentOwner: $l }; function zd() { throw Error("act(...) is not supported in production builds of React.") } B.Children = { map: Tr, forEach: function (t, e, n) { Tr(t, function () { e.apply(this, arguments) }, n) }, count: function (t) { var e = 0; return Tr(t, function () { e++ }), e }, toArray: function (t) { return Tr(t, function (e) { return e }) || [] }, only: function (t) { if (!ql(t)) throw Error("React.Children.only expected to receive a single React element child."); return t } }; B.Component = co; B.Fragment = bh; B.Profiler = Gh; B.PureComponent = Vl; B.StrictMode = Vh; B.Suspense = zh; B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Qh; B.act = zd; B.cloneElement = function (t, e, n) { if (t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + "."); var o = bd({}, t.props), r = t.key, i = t.ref, s = t._owner; if (e != null) { if (e.ref !== void 0 && (i = e.ref, s = $l.current), e.key !== void 0 && (r = "" + e.key), t.type && t.type.defaultProps) var u = t.type.defaultProps; for (c in e) $d.call(e, c) && !qd.hasOwnProperty(c) && (o[c] = e[c] === void 0 && u !== void 0 ? u[c] : e[c]) } var c = arguments.length - 2; if (c === 1) o.children = n; else if (1 < c) { u = Array(c); for (var d = 0; d < c; d++)u[d] = arguments[d + 2]; o.children = u } return { $$typeof: cr, type: t.type, key: r, ref: i, props: o, _owner: s } }; B.createContext = function (t) { return t = { $$typeof: qh, _currentValue: t, _currentValue2: t, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, t.Provider = { $$typeof: $h, _context: t }, t.Consumer = t }; B.createElement = Hd; B.createFactory = function (t) { var e = Hd.bind(null, t); return e.type = t, e }; B.createRef = function () { return { current: null } }; B.forwardRef = function (t) { return { $$typeof: Hh, render: t } }; B.isValidElement = ql; B.lazy = function (t) { return { $$typeof: Jh, _payload: { _status: -1, _result: t }, _init: Oh } }; B.memo = function (t, e) { return { $$typeof: Bh, type: t, compare: e === void 0 ? null : e } }; B.startTransition = function (t) { var e = zr.transition; zr.transition = {}; try { t() } finally { zr.transition = e } }; B.unstable_act = zd; B.useCallback = function (t, e) { return Ue.current.useCallback(t, e) }; B.useContext = function (t) { return Ue.current.useContext(t) }; B.useDebugValue = function () { }; B.useDeferredValue = function (t) { return Ue.current.useDeferredValue(t) }; B.useEffect = function (t, e) { return Ue.current.useEffect(t, e) }; B.useId = function () { return Ue.current.useId() }; B.useImperativeHandle = function (t, e, n) { return Ue.current.useImperativeHandle(t, e, n) }; B.useInsertionEffect = function (t, e) { return Ue.current.useInsertionEffect(t, e) }; B.useLayoutEffect = function (t, e) { return Ue.current.useLayoutEffect(t, e) }; B.useMemo = function (t, e) { return Ue.current.useMemo(t, e) }; B.useReducer = function (t, e, n) { return Ue.current.useReducer(t, e, n) }; B.useRef = function (t) { return Ue.current.useRef(t) }; B.useState = function (t) { return Ue.current.useState(t) }; B.useSyncExternalStore = function (t, e, n) { return Ue.current.useSyncExternalStore(t, e, n) }; B.useTransition = function () { return Ue.current.useTransition() }; B.version = "18.3.1"; Ud.exports = B; var P = Ud.exports; const Xh = Uh(P);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Zh = P, jh = Symbol.for("react.element"), em = Symbol.for("react.fragment"), tm = Object.prototype.hasOwnProperty, nm = Zh.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, om = { key: !0, ref: !0, __self: !0, __source: !0 }; function Bd(t, e, n) { var o, r = {}, i = null, s = null; n !== void 0 && (i = "" + n), e.key !== void 0 && (i = "" + e.key), e.ref !== void 0 && (s = e.ref); for (o in e) tm.call(e, o) && !om.hasOwnProperty(o) && (r[o] = e[o]); if (t && t.defaultProps) for (o in e = t.defaultProps, e) r[o] === void 0 && (r[o] = e[o]); return { $$typeof: jh, type: t, key: i, ref: s, props: r, _owner: nm.current } } Ui.Fragment = em; Ui.jsx = Bd; Ui.jsxs = Bd; Ld.exports = Ui; var m = Ld.exports, Ls = {}, Jd = { exports: {} }, Oe = {}, Wd = { exports: {} }, Yd = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (t) { function e(L, V) { var H = L.length; L.push(V); e: for (; 0 < H;) { var O = H - 1 >>> 1, X = L[O]; if (0 < r(X, V)) L[O] = V, L[H] = X, H = O; else break e } } function n(L) { return L.length === 0 ? null : L[0] } function o(L) { if (L.length === 0) return null; var V = L[0], H = L.pop(); if (H !== V) { L[0] = H; e: for (var O = 0, X = L.length, gt = X >>> 1; O < gt;) { var Me = 2 * (O + 1) - 1, Et = L[Me], Xe = Me + 1, ve = L[Xe]; if (0 > r(Et, H)) Xe < X && 0 > r(ve, Et) ? (L[O] = ve, L[Xe] = H, O = Xe) : (L[O] = Et, L[Me] = H, O = Me); else if (Xe < X && 0 > r(ve, H)) L[O] = ve, L[Xe] = H, O = Xe; else break e } } return V } function r(L, V) { var H = L.sortIndex - V.sortIndex; return H !== 0 ? H : L.id - V.id } if (typeof performance == "object" && typeof performance.now == "function") { var i = performance; t.unstable_now = function () { return i.now() } } else { var s = Date, u = s.now(); t.unstable_now = function () { return s.now() - u } } var c = [], d = [], f = 1, p = null, h = 3, g = !1, S = !1, w = !1, I = typeof setTimeout == "function" ? setTimeout : null, x = typeof clearTimeout == "function" ? clearTimeout : null, y = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function v(L) { for (var V = n(d); V !== null;) { if (V.callback === null) o(d); else if (V.startTime <= L) o(d), V.sortIndex = V.expirationTime, e(c, V); else break; V = n(d) } } function T(L) { if (w = !1, v(L), !S) if (n(c) !== null) S = !0, he(E); else { var V = n(d); V !== null && Ce(T, V.startTime - L) } } function E(L, V) { S = !1, w && (w = !1, x(A), A = -1), g = !0; var H = h; try { for (v(V), p = n(c); p !== null && (!(p.expirationTime > V) || L && !b());) { var O = p.callback; if (typeof O == "function") { p.callback = null, h = p.priorityLevel; var X = O(p.expirationTime <= V); V = t.unstable_now(), typeof X == "function" ? p.callback = X : p === n(c) && o(c), v(V) } else o(c); p = n(c) } if (p !== null) var gt = !0; else { var Me = n(d); Me !== null && Ce(T, Me.startTime - V), gt = !1 } return gt } finally { p = null, h = H, g = !1 } } var C = !1, k = null, A = -1, N = 5, M = -1; function b() { return !(t.unstable_now() - M < N) } function z() { if (k !== null) { var L = t.unstable_now(); M = L; var V = !0; try { V = k(!0, L) } finally { V ? se() : (C = !1, k = null) } } else C = !1 } var se; if (typeof y == "function") se = function () { y(z) }; else if (typeof MessageChannel < "u") { var ht = new MessageChannel, mt = ht.port2; ht.port1.onmessage = z, se = function () { mt.postMessage(null) } } else se = function () { I(z, 0) }; function he(L) { k = L, C || (C = !0, se()) } function Ce(L, V) { A = I(function () { L(t.unstable_now()) }, V) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (L) { L.callback = null }, t.unstable_continueExecution = function () { S || g || (S = !0, he(E)) }, t.unstable_forceFrameRate = function (L) { 0 > L || 125 < L ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : N = 0 < L ? Math.floor(1e3 / L) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return h }, t.unstable_getFirstCallbackNode = function () { return n(c) }, t.unstable_next = function (L) { switch (h) { case 1: case 2: case 3: var V = 3; break; default: V = h }var H = h; h = V; try { return L() } finally { h = H } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (L, V) { switch (L) { case 1: case 2: case 3: case 4: case 5: break; default: L = 3 }var H = h; h = L; try { return V() } finally { h = H } }, t.unstable_scheduleCallback = function (L, V, H) { var O = t.unstable_now(); switch (typeof H == "object" && H !== null ? (H = H.delay, H = typeof H == "number" && 0 < H ? O + H : O) : H = O, L) { case 1: var X = -1; break; case 2: X = 250; break; case 5: X = 1073741823; break; case 4: X = 1e4; break; default: X = 5e3 }return X = H + X, L = { id: f++, callback: V, priorityLevel: L, startTime: H, expirationTime: X, sortIndex: -1 }, H > O ? (L.sortIndex = H, e(d, L), n(c) === null && L === n(d) && (w ? (x(A), A = -1) : w = !0, Ce(T, H - O))) : (L.sortIndex = X, e(c, L), S || g || (S = !0, he(E))), L }, t.unstable_shouldYield = b, t.unstable_wrapCallback = function (L) { var V = h; return function () { var H = h; h = V; try { return L.apply(this, arguments) } finally { h = H } } } })(Yd); Wd.exports = Yd; var rm = Wd.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var im = P, Ke = rm; function R(t) { for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++)e += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var Kd = new Set, Wo = {}; function En(t, e) { oo(t, e), oo(t + "Capture", e) } function oo(t, e) { for (Wo[t] = e, t = 0; t < e.length; t++)Kd.add(e[t]) } var Pt = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Us = Object.prototype.hasOwnProperty, sm = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Xa = {}, Za = {}; function lm(t) { return Us.call(Za, t) ? !0 : Us.call(Xa, t) ? !1 : sm.test(t) ? Za[t] = !0 : (Xa[t] = !0, !1) } function am(t, e, n, o) { if (n !== null && n.type === 0) return !1; switch (typeof e) { case "function": case "symbol": return !0; case "boolean": return o ? !1 : n !== null ? !n.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-"); default: return !1 } } function um(t, e, n, o) { if (e === null || typeof e > "u" || am(t, e, n, o)) return !0; if (o) return !1; if (n !== null) switch (n.type) { case 3: return !e; case 4: return e === !1; case 5: return isNaN(e); case 6: return isNaN(e) || 1 > e }return !1 } function Fe(t, e, n, o, r, i, s) { this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = o, this.attributeNamespace = r, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = i, this.removeEmptyString = s } var Ee = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (t) { Ee[t] = new Fe(t, 0, !1, t, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (t) { var e = t[0]; Ee[e] = new Fe(e, 1, !1, t[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) { Ee[t] = new Fe(t, 2, !1, t.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (t) { Ee[t] = new Fe(t, 2, !1, t, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (t) { Ee[t] = new Fe(t, 3, !1, t.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (t) { Ee[t] = new Fe(t, 3, !0, t, null, !1, !1) });["capture", "download"].forEach(function (t) { Ee[t] = new Fe(t, 4, !1, t, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (t) { Ee[t] = new Fe(t, 6, !1, t, null, !1, !1) });["rowSpan", "start"].forEach(function (t) { Ee[t] = new Fe(t, 5, !1, t.toLowerCase(), null, !1, !1) }); var Hl = /[\-:]([a-z])/g; function zl(t) { return t[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (t) { var e = t.replace(Hl, zl); Ee[e] = new Fe(e, 1, !1, t, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (t) { var e = t.replace(Hl, zl); Ee[e] = new Fe(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (t) { var e = t.replace(Hl, zl); Ee[e] = new Fe(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (t) { Ee[t] = new Fe(t, 1, !1, t.toLowerCase(), null, !1, !1) }); Ee.xlinkHref = new Fe("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (t) { Ee[t] = new Fe(t, 1, !1, t.toLowerCase(), null, !0, !0) }); function Bl(t, e, n, o) { var r = Ee.hasOwnProperty(e) ? Ee[e] : null; (r !== null ? r.type !== 0 : o || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (um(e, n, r, o) && (n = null), o || r === null ? lm(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : r.mustUseProperty ? t[r.propertyName] = n === null ? r.type === 3 ? !1 : "" : n : (e = r.attributeName, o = r.attributeNamespace, n === null ? t.removeAttribute(e) : (r = r.type, n = r === 3 || r === 4 && n === !0 ? "" : "" + n, o ? t.setAttributeNS(o, e, n) : t.setAttribute(e, n)))) } var Ft = im.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, _r = Symbol.for("react.element"), Ln = Symbol.for("react.portal"), Un = Symbol.for("react.fragment"), Jl = Symbol.for("react.strict_mode"), Fs = Symbol.for("react.profiler"), Od = Symbol.for("react.provider"), Qd = Symbol.for("react.context"), Wl = Symbol.for("react.forward_ref"), bs = Symbol.for("react.suspense"), Vs = Symbol.for("react.suspense_list"), Yl = Symbol.for("react.memo"), Bt = Symbol.for("react.lazy"), Xd = Symbol.for("react.offscreen"), ja = Symbol.iterator; function wo(t) { return t === null || typeof t != "object" ? null : (t = ja && t[ja] || t["@@iterator"], typeof t == "function" ? t : null) } var ue = Object.assign, us; function Ro(t) {
  if (us === void 0) try { throw Error() } catch (n) { var e = n.stack.trim().match(/\n( *(at )?)/); us = e && e[1] || "" } return `
`+ us + t
} var cs = !1; function ds(t, e) {
  if (!t || cs) return ""; cs = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (e) if (e = function () { throw Error() }, Object.defineProperty(e.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(e, []) } catch (d) { var o = d } Reflect.construct(t, [], e) } else { try { e.call() } catch (d) { o = d } t.call(e.prototype) } else { try { throw Error() } catch (d) { o = d } t() } } catch (d) {
    if (d && o && typeof d.stack == "string") {
      for (var r = d.stack.split(`
`), i = o.stack.split(`
`), s = r.length - 1, u = i.length - 1; 1 <= s && 0 <= u && r[s] !== i[u];)u--; for (; 1 <= s && 0 <= u; s--, u--)if (r[s] !== i[u]) {
        if (s !== 1 || u !== 1) do if (s--, u--, 0 > u || r[s] !== i[u]) {
          var c = `
`+ r[s].replace(" at new ", " at "); return t.displayName && c.includes("<anonymous>") && (c = c.replace("<anonymous>", t.displayName)), c
        } while (1 <= s && 0 <= u); break
      }
    }
  } finally { cs = !1, Error.prepareStackTrace = n } return (t = t ? t.displayName || t.name : "") ? Ro(t) : ""
} function cm(t) { switch (t.tag) { case 5: return Ro(t.type); case 16: return Ro("Lazy"); case 13: return Ro("Suspense"); case 19: return Ro("SuspenseList"); case 0: case 2: case 15: return t = ds(t.type, !1), t; case 11: return t = ds(t.type.render, !1), t; case 1: return t = ds(t.type, !0), t; default: return "" } } function Gs(t) { if (t == null) return null; if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t; switch (t) { case Un: return "Fragment"; case Ln: return "Portal"; case Fs: return "Profiler"; case Jl: return "StrictMode"; case bs: return "Suspense"; case Vs: return "SuspenseList" }if (typeof t == "object") switch (t.$$typeof) { case Qd: return (t.displayName || "Context") + ".Consumer"; case Od: return (t._context.displayName || "Context") + ".Provider"; case Wl: var e = t.render; return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t; case Yl: return e = t.displayName || null, e !== null ? e : Gs(t.type) || "Memo"; case Bt: e = t._payload, t = t._init; try { return Gs(t(e)) } catch { } }return null } function dm(t) { var e = t.type; switch (t.tag) { case 24: return "Cache"; case 9: return (e.displayName || "Context") + ".Consumer"; case 10: return (e._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return e; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Gs(e); case 8: return e === Jl ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e }return null } function sn(t) { switch (typeof t) { case "boolean": case "number": case "string": case "undefined": return t; case "object": return t; default: return "" } } function Zd(t) { var e = t.type; return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio") } function fm(t) { var e = Zd(t) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e), o = "" + t[e]; if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var r = n.get, i = n.set; return Object.defineProperty(t, e, { configurable: !0, get: function () { return r.call(this) }, set: function (s) { o = "" + s, i.call(this, s) } }), Object.defineProperty(t, e, { enumerable: n.enumerable }), { getValue: function () { return o }, setValue: function (s) { o = "" + s }, stopTracking: function () { t._valueTracker = null, delete t[e] } } } } function Er(t) { t._valueTracker || (t._valueTracker = fm(t)) } function jd(t) { if (!t) return !1; var e = t._valueTracker; if (!e) return !0; var n = e.getValue(), o = ""; return t && (o = Zd(t) ? t.checked ? "true" : "false" : t.value), t = o, t !== n ? (e.setValue(t), !0) : !1 } function oi(t) { if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null; try { return t.activeElement || t.body } catch { return t.body } } function $s(t, e) { var n = e.checked; return ue({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? t._wrapperState.initialChecked }) } function eu(t, e) { var n = e.defaultValue == null ? "" : e.defaultValue, o = e.checked != null ? e.checked : e.defaultChecked; n = sn(e.value != null ? e.value : n), t._wrapperState = { initialChecked: o, initialValue: n, controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null } } function ef(t, e) { e = e.checked, e != null && Bl(t, "checked", e, !1) } function qs(t, e) { ef(t, e); var n = sn(e.value), o = e.type; if (n != null) o === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n); else if (o === "submit" || o === "reset") { t.removeAttribute("value"); return } e.hasOwnProperty("value") ? Hs(t, e.type, n) : e.hasOwnProperty("defaultValue") && Hs(t, e.type, sn(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked) } function tu(t, e, n) { if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) { var o = e.type; if (!(o !== "submit" && o !== "reset" || e.value !== void 0 && e.value !== null)) return; e = "" + t._wrapperState.initialValue, n || e === t.value || (t.value = e), t.defaultValue = e } n = t.name, n !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, n !== "" && (t.name = n) } function Hs(t, e, n) { (e !== "number" || oi(t.ownerDocument) !== t) && (n == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n)) } var Po = Array.isArray; function Kn(t, e, n, o) { if (t = t.options, e) { e = {}; for (var r = 0; r < n.length; r++)e["$" + n[r]] = !0; for (n = 0; n < t.length; n++)r = e.hasOwnProperty("$" + t[n].value), t[n].selected !== r && (t[n].selected = r), r && o && (t[n].defaultSelected = !0) } else { for (n = "" + sn(n), e = null, r = 0; r < t.length; r++) { if (t[r].value === n) { t[r].selected = !0, o && (t[r].defaultSelected = !0); return } e !== null || t[r].disabled || (e = t[r]) } e !== null && (e.selected = !0) } } function zs(t, e) { if (e.dangerouslySetInnerHTML != null) throw Error(R(91)); return ue({}, e, { value: void 0, defaultValue: void 0, children: "" + t._wrapperState.initialValue }) } function nu(t, e) { var n = e.value; if (n == null) { if (n = e.children, e = e.defaultValue, n != null) { if (e != null) throw Error(R(92)); if (Po(n)) { if (1 < n.length) throw Error(R(93)); n = n[0] } e = n } e == null && (e = ""), n = e } t._wrapperState = { initialValue: sn(n) } } function tf(t, e) { var n = sn(e.value), o = sn(e.defaultValue); n != null && (n = "" + n, n !== t.value && (t.value = n), e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)), o != null && (t.defaultValue = "" + o) } function ou(t) { var e = t.textContent; e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e) } function nf(t) { switch (t) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Bs(t, e) { return t == null || t === "http://www.w3.org/1999/xhtml" ? nf(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t } var kr, of = function (t) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (e, n, o, r) { MSApp.execUnsafeLocalFunction(function () { return t(e, n, o, r) }) } : t }(function (t, e) { if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = e; else { for (kr = kr || document.createElement("div"), kr.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = kr.firstChild; t.firstChild;)t.removeChild(t.firstChild); for (; e.firstChild;)t.appendChild(e.firstChild) } }); function Yo(t, e) { if (e) { var n = t.firstChild; if (n && n === t.lastChild && n.nodeType === 3) { n.nodeValue = e; return } } t.textContent = e } var Lo = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, pm = ["Webkit", "ms", "Moz", "O"]; Object.keys(Lo).forEach(function (t) { pm.forEach(function (e) { e = e + t.charAt(0).toUpperCase() + t.substring(1), Lo[e] = Lo[t] }) }); function rf(t, e, n) { return e == null || typeof e == "boolean" || e === "" ? "" : n || typeof e != "number" || e === 0 || Lo.hasOwnProperty(t) && Lo[t] ? ("" + e).trim() : e + "px" } function sf(t, e) { t = t.style; for (var n in e) if (e.hasOwnProperty(n)) { var o = n.indexOf("--") === 0, r = rf(n, e[n], o); n === "float" && (n = "cssFloat"), o ? t.setProperty(n, r) : t[n] = r } } var hm = ue({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Js(t, e) { if (e) { if (hm[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(R(137, t)); if (e.dangerouslySetInnerHTML != null) { if (e.children != null) throw Error(R(60)); if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(R(61)) } if (e.style != null && typeof e.style != "object") throw Error(R(62)) } } function Ws(t, e) { if (t.indexOf("-") === -1) return typeof e.is == "string"; switch (t) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Ys = null; function Kl(t) { return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t } var Ks = null, On = null, Qn = null; function ru(t) { if (t = pr(t)) { if (typeof Ks != "function") throw Error(R(280)); var e = t.stateNode; e && (e = $i(e), Ks(t.stateNode, t.type, e)) } } function lf(t) { On ? Qn ? Qn.push(t) : Qn = [t] : On = t } function af() { if (On) { var t = On, e = Qn; if (Qn = On = null, ru(t), e) for (t = 0; t < e.length; t++)ru(e[t]) } } function uf(t, e) { return t(e) } function cf() { } var fs = !1; function df(t, e, n) { if (fs) return t(e, n); fs = !0; try { return uf(t, e, n) } finally { fs = !1, (On !== null || Qn !== null) && (cf(), af()) } } function Ko(t, e) { var n = t.stateNode; if (n === null) return null; var o = $i(n); if (o === null) return null; n = o[e]; e: switch (e) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (o = !o.disabled) || (t = t.type, o = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !o; break e; default: t = !1 }if (t) return null; if (n && typeof n != "function") throw Error(R(231, e, typeof n)); return n } var Os = !1; if (Pt) try { var Co = {}; Object.defineProperty(Co, "passive", { get: function () { Os = !0 } }), window.addEventListener("test", Co, Co), window.removeEventListener("test", Co, Co) } catch { Os = !1 } function mm(t, e, n, o, r, i, s, u, c) { var d = Array.prototype.slice.call(arguments, 3); try { e.apply(n, d) } catch (f) { this.onError(f) } } var Uo = !1, ri = null, ii = !1, Qs = null, gm = { onError: function (t) { Uo = !0, ri = t } }; function ym(t, e, n, o, r, i, s, u, c) { Uo = !1, ri = null, mm.apply(gm, arguments) } function vm(t, e, n, o, r, i, s, u, c) { if (ym.apply(this, arguments), Uo) { if (Uo) { var d = ri; Uo = !1, ri = null } else throw Error(R(198)); ii || (ii = !0, Qs = d) } } function kn(t) { var e = t, n = t; if (t.alternate) for (; e.return;)e = e.return; else { t = e; do e = t, e.flags & 4098 && (n = e.return), t = e.return; while (t) } return e.tag === 3 ? n : null } function ff(t) { if (t.tag === 13) { var e = t.memoizedState; if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated } return null } function iu(t) { if (kn(t) !== t) throw Error(R(188)) } function xm(t) { var e = t.alternate; if (!e) { if (e = kn(t), e === null) throw Error(R(188)); return e !== t ? null : t } for (var n = t, o = e; ;) { var r = n.return; if (r === null) break; var i = r.alternate; if (i === null) { if (o = r.return, o !== null) { n = o; continue } break } if (r.child === i.child) { for (i = r.child; i;) { if (i === n) return iu(r), t; if (i === o) return iu(r), e; i = i.sibling } throw Error(R(188)) } if (n.return !== o.return) n = r, o = i; else { for (var s = !1, u = r.child; u;) { if (u === n) { s = !0, n = r, o = i; break } if (u === o) { s = !0, o = r, n = i; break } u = u.sibling } if (!s) { for (u = i.child; u;) { if (u === n) { s = !0, n = i, o = r; break } if (u === o) { s = !0, o = i, n = r; break } u = u.sibling } if (!s) throw Error(R(189)) } } if (n.alternate !== o) throw Error(R(190)) } if (n.tag !== 3) throw Error(R(188)); return n.stateNode.current === n ? t : e } function pf(t) { return t = xm(t), t !== null ? hf(t) : null } function hf(t) { if (t.tag === 5 || t.tag === 6) return t; for (t = t.child; t !== null;) { var e = hf(t); if (e !== null) return e; t = t.sibling } return null } var mf = Ke.unstable_scheduleCallback, su = Ke.unstable_cancelCallback, wm = Ke.unstable_shouldYield, Cm = Ke.unstable_requestPaint, pe = Ke.unstable_now, Sm = Ke.unstable_getCurrentPriorityLevel, Ol = Ke.unstable_ImmediatePriority, gf = Ke.unstable_UserBlockingPriority, si = Ke.unstable_NormalPriority, Tm = Ke.unstable_LowPriority, yf = Ke.unstable_IdlePriority, Fi = null, Tt = null; function _m(t) { if (Tt && typeof Tt.onCommitFiberRoot == "function") try { Tt.onCommitFiberRoot(Fi, t, void 0, (t.current.flags & 128) === 128) } catch { } } var ct = Math.clz32 ? Math.clz32 : Im, Em = Math.log, km = Math.LN2; function Im(t) { return t >>>= 0, t === 0 ? 32 : 31 - (Em(t) / km | 0) | 0 } var Ir = 64, Nr = 4194304; function Mo(t) { switch (t & -t) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return t & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return t } } function li(t, e) { var n = t.pendingLanes; if (n === 0) return 0; var o = 0, r = t.suspendedLanes, i = t.pingedLanes, s = n & 268435455; if (s !== 0) { var u = s & ~r; u !== 0 ? o = Mo(u) : (i &= s, i !== 0 && (o = Mo(i))) } else s = n & ~r, s !== 0 ? o = Mo(s) : i !== 0 && (o = Mo(i)); if (o === 0) return 0; if (e !== 0 && e !== o && !(e & r) && (r = o & -o, i = e & -e, r >= i || r === 16 && (i & 4194240) !== 0)) return e; if (o & 4 && (o |= n & 16), e = t.entangledLanes, e !== 0) for (t = t.entanglements, e &= o; 0 < e;)n = 31 - ct(e), r = 1 << n, o |= t[n], e &= ~r; return o } function Nm(t, e) { switch (t) { case 1: case 2: case 4: return e + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function Am(t, e) { for (var n = t.suspendedLanes, o = t.pingedLanes, r = t.expirationTimes, i = t.pendingLanes; 0 < i;) { var s = 31 - ct(i), u = 1 << s, c = r[s]; c === -1 ? (!(u & n) || u & o) && (r[s] = Nm(u, e)) : c <= e && (t.expiredLanes |= u), i &= ~u } } function Xs(t) { return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0 } function vf() { var t = Ir; return Ir <<= 1, !(Ir & 4194240) && (Ir = 64), t } function ps(t) { for (var e = [], n = 0; 31 > n; n++)e.push(t); return e } function dr(t, e, n) { t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - ct(e), t[e] = n } function Rm(t, e) { var n = t.pendingLanes & ~e; t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements; var o = t.eventTimes; for (t = t.expirationTimes; 0 < n;) { var r = 31 - ct(n), i = 1 << r; e[r] = 0, o[r] = -1, t[r] = -1, n &= ~i } } function Ql(t, e) { var n = t.entangledLanes |= e; for (t = t.entanglements; n;) { var o = 31 - ct(n), r = 1 << o; r & e | t[o] & e && (t[o] |= e), n &= ~r } } var K = 0; function xf(t) { return t &= -t, 1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1 } var wf, Xl, Cf, Sf, Tf, Zs = !1, Ar = [], Xt = null, Zt = null, jt = null, Oo = new Map, Qo = new Map, Wt = [], Pm = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function lu(t, e) { switch (t) { case "focusin": case "focusout": Xt = null; break; case "dragenter": case "dragleave": Zt = null; break; case "mouseover": case "mouseout": jt = null; break; case "pointerover": case "pointerout": Oo.delete(e.pointerId); break; case "gotpointercapture": case "lostpointercapture": Qo.delete(e.pointerId) } } function So(t, e, n, o, r, i) { return t === null || t.nativeEvent !== i ? (t = { blockedOn: e, domEventName: n, eventSystemFlags: o, nativeEvent: i, targetContainers: [r] }, e !== null && (e = pr(e), e !== null && Xl(e)), t) : (t.eventSystemFlags |= o, e = t.targetContainers, r !== null && e.indexOf(r) === -1 && e.push(r), t) } function Mm(t, e, n, o, r) { switch (e) { case "focusin": return Xt = So(Xt, t, e, n, o, r), !0; case "dragenter": return Zt = So(Zt, t, e, n, o, r), !0; case "mouseover": return jt = So(jt, t, e, n, o, r), !0; case "pointerover": var i = r.pointerId; return Oo.set(i, So(Oo.get(i) || null, t, e, n, o, r)), !0; case "gotpointercapture": return i = r.pointerId, Qo.set(i, So(Qo.get(i) || null, t, e, n, o, r)), !0 }return !1 } function _f(t) { var e = hn(t.target); if (e !== null) { var n = kn(e); if (n !== null) { if (e = n.tag, e === 13) { if (e = ff(n), e !== null) { t.blockedOn = e, Tf(t.priority, function () { Cf(n) }); return } } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) { t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } t.blockedOn = null } function Br(t) { if (t.blockedOn !== null) return !1; for (var e = t.targetContainers; 0 < e.length;) { var n = js(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent); if (n === null) { n = t.nativeEvent; var o = new n.constructor(n.type, n); Ys = o, n.target.dispatchEvent(o), Ys = null } else return e = pr(n), e !== null && Xl(e), t.blockedOn = n, !1; e.shift() } return !0 } function au(t, e, n) { Br(t) && n.delete(e) } function Dm() { Zs = !1, Xt !== null && Br(Xt) && (Xt = null), Zt !== null && Br(Zt) && (Zt = null), jt !== null && Br(jt) && (jt = null), Oo.forEach(au), Qo.forEach(au) } function To(t, e) { t.blockedOn === e && (t.blockedOn = null, Zs || (Zs = !0, Ke.unstable_scheduleCallback(Ke.unstable_NormalPriority, Dm))) } function Xo(t) { function e(r) { return To(r, t) } if (0 < Ar.length) { To(Ar[0], t); for (var n = 1; n < Ar.length; n++) { var o = Ar[n]; o.blockedOn === t && (o.blockedOn = null) } } for (Xt !== null && To(Xt, t), Zt !== null && To(Zt, t), jt !== null && To(jt, t), Oo.forEach(e), Qo.forEach(e), n = 0; n < Wt.length; n++)o = Wt[n], o.blockedOn === t && (o.blockedOn = null); for (; 0 < Wt.length && (n = Wt[0], n.blockedOn === null);)_f(n), n.blockedOn === null && Wt.shift() } var Xn = Ft.ReactCurrentBatchConfig, ai = !0; function Lm(t, e, n, o) { var r = K, i = Xn.transition; Xn.transition = null; try { K = 1, Zl(t, e, n, o) } finally { K = r, Xn.transition = i } } function Um(t, e, n, o) { var r = K, i = Xn.transition; Xn.transition = null; try { K = 4, Zl(t, e, n, o) } finally { K = r, Xn.transition = i } } function Zl(t, e, n, o) { if (ai) { var r = js(t, e, n, o); if (r === null) Ts(t, e, o, ui, n), lu(t, o); else if (Mm(r, t, e, n, o)) o.stopPropagation(); else if (lu(t, o), e & 4 && -1 < Pm.indexOf(t)) { for (; r !== null;) { var i = pr(r); if (i !== null && wf(i), i = js(t, e, n, o), i === null && Ts(t, e, o, ui, n), i === r) break; r = i } r !== null && o.stopPropagation() } else Ts(t, e, o, null, n) } } var ui = null; function js(t, e, n, o) { if (ui = null, t = Kl(o), t = hn(t), t !== null) if (e = kn(t), e === null) t = null; else if (n = e.tag, n === 13) { if (t = ff(e), t !== null) return t; t = null } else if (n === 3) { if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null; t = null } else e !== t && (t = null); return ui = t, null } function Ef(t) { switch (t) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Sm()) { case Ol: return 1; case gf: return 4; case si: case Tm: return 16; case yf: return 536870912; default: return 16 }default: return 16 } } var Kt = null, jl = null, Jr = null; function kf() { if (Jr) return Jr; var t, e = jl, n = e.length, o, r = "value" in Kt ? Kt.value : Kt.textContent, i = r.length; for (t = 0; t < n && e[t] === r[t]; t++); var s = n - t; for (o = 1; o <= s && e[n - o] === r[i - o]; o++); return Jr = r.slice(t, 1 < o ? 1 - o : void 0) } function Wr(t) { var e = t.keyCode; return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0 } function Rr() { return !0 } function uu() { return !1 } function Qe(t) { function e(n, o, r, i, s) { this._reactName = n, this._targetInst = r, this.type = o, this.nativeEvent = i, this.target = s, this.currentTarget = null; for (var u in t) t.hasOwnProperty(u) && (n = t[u], this[u] = n ? n(i) : i[u]); return this.isDefaultPrevented = (i.defaultPrevented != null ? i.defaultPrevented : i.returnValue === !1) ? Rr : uu, this.isPropagationStopped = uu, this } return ue(e.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = Rr) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = Rr) }, persist: function () { }, isPersistent: Rr }), e } var fo = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (t) { return t.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, ea = Qe(fo), fr = ue({}, fo, { view: 0, detail: 0 }), Fm = Qe(fr), hs, ms, _o, bi = ue({}, fr, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: ta, button: 0, buttons: 0, relatedTarget: function (t) { return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget }, movementX: function (t) { return "movementX" in t ? t.movementX : (t !== _o && (_o && t.type === "mousemove" ? (hs = t.screenX - _o.screenX, ms = t.screenY - _o.screenY) : ms = hs = 0, _o = t), hs) }, movementY: function (t) { return "movementY" in t ? t.movementY : ms } }), cu = Qe(bi), bm = ue({}, bi, { dataTransfer: 0 }), Vm = Qe(bm), Gm = ue({}, fr, { relatedTarget: 0 }), gs = Qe(Gm), $m = ue({}, fo, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), qm = Qe($m), Hm = ue({}, fo, { clipboardData: function (t) { return "clipboardData" in t ? t.clipboardData : window.clipboardData } }), zm = Qe(Hm), Bm = ue({}, fo, { data: 0 }), du = Qe(Bm), Jm = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Wm = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Ym = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Km(t) { var e = this.nativeEvent; return e.getModifierState ? e.getModifierState(t) : (t = Ym[t]) ? !!e[t] : !1 } function ta() { return Km } var Om = ue({}, fr, { key: function (t) { if (t.key) { var e = Jm[t.key] || t.key; if (e !== "Unidentified") return e } return t.type === "keypress" ? (t = Wr(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? Wm[t.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: ta, charCode: function (t) { return t.type === "keypress" ? Wr(t) : 0 }, keyCode: function (t) { return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 }, which: function (t) { return t.type === "keypress" ? Wr(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 } }), Qm = Qe(Om), Xm = ue({}, bi, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), fu = Qe(Xm), Zm = ue({}, fr, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: ta }), jm = Qe(Zm), eg = ue({}, fo, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), tg = Qe(eg), ng = ue({}, bi, { deltaX: function (t) { return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0 }, deltaY: function (t) { return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), og = Qe(ng), rg = [9, 13, 27, 32], na = Pt && "CompositionEvent" in window, Fo = null; Pt && "documentMode" in document && (Fo = document.documentMode); var ig = Pt && "TextEvent" in window && !Fo, If = Pt && (!na || Fo && 8 < Fo && 11 >= Fo), pu = String.fromCharCode(32), hu = !1; function Nf(t, e) { switch (t) { case "keyup": return rg.indexOf(e.keyCode) !== -1; case "keydown": return e.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Af(t) { return t = t.detail, typeof t == "object" && "data" in t ? t.data : null } var Fn = !1; function sg(t, e) { switch (t) { case "compositionend": return Af(e); case "keypress": return e.which !== 32 ? null : (hu = !0, pu); case "textInput": return t = e.data, t === pu && hu ? null : t; default: return null } } function lg(t, e) { if (Fn) return t === "compositionend" || !na && Nf(t, e) ? (t = kf(), Jr = jl = Kt = null, Fn = !1, t) : null; switch (t) { case "paste": return null; case "keypress": if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) { if (e.char && 1 < e.char.length) return e.char; if (e.which) return String.fromCharCode(e.which) } return null; case "compositionend": return If && e.locale !== "ko" ? null : e.data; default: return null } } var ag = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function mu(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e === "input" ? !!ag[t.type] : e === "textarea" } function Rf(t, e, n, o) { lf(o), e = ci(e, "onChange"), 0 < e.length && (n = new ea("onChange", "change", null, n, o), t.push({ event: n, listeners: e })) } var bo = null, Zo = null; function ug(t) { qf(t, 0) } function Vi(t) { var e = Gn(t); if (jd(e)) return t } function cg(t, e) { if (t === "change") return e } var Pf = !1; if (Pt) { var ys; if (Pt) { var vs = "oninput" in document; if (!vs) { var gu = document.createElement("div"); gu.setAttribute("oninput", "return;"), vs = typeof gu.oninput == "function" } ys = vs } else ys = !1; Pf = ys && (!document.documentMode || 9 < document.documentMode) } function yu() { bo && (bo.detachEvent("onpropertychange", Mf), Zo = bo = null) } function Mf(t) { if (t.propertyName === "value" && Vi(Zo)) { var e = []; Rf(e, Zo, t, Kl(t)), df(ug, e) } } function dg(t, e, n) { t === "focusin" ? (yu(), bo = e, Zo = n, bo.attachEvent("onpropertychange", Mf)) : t === "focusout" && yu() } function fg(t) { if (t === "selectionchange" || t === "keyup" || t === "keydown") return Vi(Zo) } function pg(t, e) { if (t === "click") return Vi(e) } function hg(t, e) { if (t === "input" || t === "change") return Vi(e) } function mg(t, e) { return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e } var ft = typeof Object.is == "function" ? Object.is : mg; function jo(t, e) { if (ft(t, e)) return !0; if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1; var n = Object.keys(t), o = Object.keys(e); if (n.length !== o.length) return !1; for (o = 0; o < n.length; o++) { var r = n[o]; if (!Us.call(e, r) || !ft(t[r], e[r])) return !1 } return !0 } function vu(t) { for (; t && t.firstChild;)t = t.firstChild; return t } function xu(t, e) { var n = vu(t); t = 0; for (var o; n;) { if (n.nodeType === 3) { if (o = t + n.textContent.length, t <= e && o >= e) return { node: n, offset: e - t }; t = o } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = vu(n) } } function Df(t, e) { return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? Df(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1 } function Lf() { for (var t = window, e = oi(); e instanceof t.HTMLIFrameElement;) { try { var n = typeof e.contentWindow.location.href == "string" } catch { n = !1 } if (n) t = e.contentWindow; else break; e = oi(t.document) } return e } function oa(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true") } function gg(t) { var e = Lf(), n = t.focusedElem, o = t.selectionRange; if (e !== n && n && n.ownerDocument && Df(n.ownerDocument.documentElement, n)) { if (o !== null && oa(n)) { if (e = o.start, t = o.end, t === void 0 && (t = e), "selectionStart" in n) n.selectionStart = e, n.selectionEnd = Math.min(t, n.value.length); else if (t = (e = n.ownerDocument || document) && e.defaultView || window, t.getSelection) { t = t.getSelection(); var r = n.textContent.length, i = Math.min(o.start, r); o = o.end === void 0 ? i : Math.min(o.end, r), !t.extend && i > o && (r = o, o = i, i = r), r = xu(n, i); var s = xu(n, o); r && s && (t.rangeCount !== 1 || t.anchorNode !== r.node || t.anchorOffset !== r.offset || t.focusNode !== s.node || t.focusOffset !== s.offset) && (e = e.createRange(), e.setStart(r.node, r.offset), t.removeAllRanges(), i > o ? (t.addRange(e), t.extend(s.node, s.offset)) : (e.setEnd(s.node, s.offset), t.addRange(e))) } } for (e = [], t = n; t = t.parentNode;)t.nodeType === 1 && e.push({ element: t, left: t.scrollLeft, top: t.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)t = e[n], t.element.scrollLeft = t.left, t.element.scrollTop = t.top } } var yg = Pt && "documentMode" in document && 11 >= document.documentMode, bn = null, el = null, Vo = null, tl = !1; function wu(t, e, n) { var o = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; tl || bn == null || bn !== oi(o) || (o = bn, "selectionStart" in o && oa(o) ? o = { start: o.selectionStart, end: o.selectionEnd } : (o = (o.ownerDocument && o.ownerDocument.defaultView || window).getSelection(), o = { anchorNode: o.anchorNode, anchorOffset: o.anchorOffset, focusNode: o.focusNode, focusOffset: o.focusOffset }), Vo && jo(Vo, o) || (Vo = o, o = ci(el, "onSelect"), 0 < o.length && (e = new ea("onSelect", "select", null, e, n), t.push({ event: e, listeners: o }), e.target = bn))) } function Pr(t, e) { var n = {}; return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit" + t] = "webkit" + e, n["Moz" + t] = "moz" + e, n } var Vn = { animationend: Pr("Animation", "AnimationEnd"), animationiteration: Pr("Animation", "AnimationIteration"), animationstart: Pr("Animation", "AnimationStart"), transitionend: Pr("Transition", "TransitionEnd") }, xs = {}, Uf = {}; Pt && (Uf = document.createElement("div").style, "AnimationEvent" in window || (delete Vn.animationend.animation, delete Vn.animationiteration.animation, delete Vn.animationstart.animation), "TransitionEvent" in window || delete Vn.transitionend.transition); function Gi(t) { if (xs[t]) return xs[t]; if (!Vn[t]) return t; var e = Vn[t], n; for (n in e) if (e.hasOwnProperty(n) && n in Uf) return xs[t] = e[n]; return t } var Ff = Gi("animationend"), bf = Gi("animationiteration"), Vf = Gi("animationstart"), Gf = Gi("transitionend"), $f = new Map, Cu = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function an(t, e) { $f.set(t, e), En(e, [t]) } for (var ws = 0; ws < Cu.length; ws++) { var Cs = Cu[ws], vg = Cs.toLowerCase(), xg = Cs[0].toUpperCase() + Cs.slice(1); an(vg, "on" + xg) } an(Ff, "onAnimationEnd"); an(bf, "onAnimationIteration"); an(Vf, "onAnimationStart"); an("dblclick", "onDoubleClick"); an("focusin", "onFocus"); an("focusout", "onBlur"); an(Gf, "onTransitionEnd"); oo("onMouseEnter", ["mouseout", "mouseover"]); oo("onMouseLeave", ["mouseout", "mouseover"]); oo("onPointerEnter", ["pointerout", "pointerover"]); oo("onPointerLeave", ["pointerout", "pointerover"]); En("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); En("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); En("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); En("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); En("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); En("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Do = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), wg = new Set("cancel close invalid load scroll toggle".split(" ").concat(Do)); function Su(t, e, n) { var o = t.type || "unknown-event"; t.currentTarget = n, vm(o, e, void 0, t), t.currentTarget = null } function qf(t, e) { e = (e & 4) !== 0; for (var n = 0; n < t.length; n++) { var o = t[n], r = o.event; o = o.listeners; e: { var i = void 0; if (e) for (var s = o.length - 1; 0 <= s; s--) { var u = o[s], c = u.instance, d = u.currentTarget; if (u = u.listener, c !== i && r.isPropagationStopped()) break e; Su(r, u, d), i = c } else for (s = 0; s < o.length; s++) { if (u = o[s], c = u.instance, d = u.currentTarget, u = u.listener, c !== i && r.isPropagationStopped()) break e; Su(r, u, d), i = c } } } if (ii) throw t = Qs, ii = !1, Qs = null, t } function ne(t, e) { var n = e[sl]; n === void 0 && (n = e[sl] = new Set); var o = t + "__bubble"; n.has(o) || (Hf(e, t, 2, !1), n.add(o)) } function Ss(t, e, n) { var o = 0; e && (o |= 4), Hf(n, t, o, e) } var Mr = "_reactListening" + Math.random().toString(36).slice(2); function er(t) { if (!t[Mr]) { t[Mr] = !0, Kd.forEach(function (n) { n !== "selectionchange" && (wg.has(n) || Ss(n, !1, t), Ss(n, !0, t)) }); var e = t.nodeType === 9 ? t : t.ownerDocument; e === null || e[Mr] || (e[Mr] = !0, Ss("selectionchange", !1, e)) } } function Hf(t, e, n, o) { switch (Ef(e)) { case 1: var r = Lm; break; case 4: r = Um; break; default: r = Zl }n = r.bind(null, e, n, t), r = void 0, !Os || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (r = !0), o ? r !== void 0 ? t.addEventListener(e, n, { capture: !0, passive: r }) : t.addEventListener(e, n, !0) : r !== void 0 ? t.addEventListener(e, n, { passive: r }) : t.addEventListener(e, n, !1) } function Ts(t, e, n, o, r) { var i = o; if (!(e & 1) && !(e & 2) && o !== null) e: for (; ;) { if (o === null) return; var s = o.tag; if (s === 3 || s === 4) { var u = o.stateNode.containerInfo; if (u === r || u.nodeType === 8 && u.parentNode === r) break; if (s === 4) for (s = o.return; s !== null;) { var c = s.tag; if ((c === 3 || c === 4) && (c = s.stateNode.containerInfo, c === r || c.nodeType === 8 && c.parentNode === r)) return; s = s.return } for (; u !== null;) { if (s = hn(u), s === null) return; if (c = s.tag, c === 5 || c === 6) { o = i = s; continue e } u = u.parentNode } } o = o.return } df(function () { var d = i, f = Kl(n), p = []; e: { var h = $f.get(t); if (h !== void 0) { var g = ea, S = t; switch (t) { case "keypress": if (Wr(n) === 0) break e; case "keydown": case "keyup": g = Qm; break; case "focusin": S = "focus", g = gs; break; case "focusout": S = "blur", g = gs; break; case "beforeblur": case "afterblur": g = gs; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": g = cu; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": g = Vm; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": g = jm; break; case Ff: case bf: case Vf: g = qm; break; case Gf: g = tg; break; case "scroll": g = Fm; break; case "wheel": g = og; break; case "copy": case "cut": case "paste": g = zm; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": g = fu }var w = (e & 4) !== 0, I = !w && t === "scroll", x = w ? h !== null ? h + "Capture" : null : h; w = []; for (var y = d, v; y !== null;) { v = y; var T = v.stateNode; if (v.tag === 5 && T !== null && (v = T, x !== null && (T = Ko(y, x), T != null && w.push(tr(y, T, v)))), I) break; y = y.return } 0 < w.length && (h = new g(h, S, null, n, f), p.push({ event: h, listeners: w })) } } if (!(e & 7)) { e: { if (h = t === "mouseover" || t === "pointerover", g = t === "mouseout" || t === "pointerout", h && n !== Ys && (S = n.relatedTarget || n.fromElement) && (hn(S) || S[Mt])) break e; if ((g || h) && (h = f.window === f ? f : (h = f.ownerDocument) ? h.defaultView || h.parentWindow : window, g ? (S = n.relatedTarget || n.toElement, g = d, S = S ? hn(S) : null, S !== null && (I = kn(S), S !== I || S.tag !== 5 && S.tag !== 6) && (S = null)) : (g = null, S = d), g !== S)) { if (w = cu, T = "onMouseLeave", x = "onMouseEnter", y = "mouse", (t === "pointerout" || t === "pointerover") && (w = fu, T = "onPointerLeave", x = "onPointerEnter", y = "pointer"), I = g == null ? h : Gn(g), v = S == null ? h : Gn(S), h = new w(T, y + "leave", g, n, f), h.target = I, h.relatedTarget = v, T = null, hn(f) === d && (w = new w(x, y + "enter", S, n, f), w.target = v, w.relatedTarget = I, T = w), I = T, g && S) t: { for (w = g, x = S, y = 0, v = w; v; v = Mn(v))y++; for (v = 0, T = x; T; T = Mn(T))v++; for (; 0 < y - v;)w = Mn(w), y--; for (; 0 < v - y;)x = Mn(x), v--; for (; y--;) { if (w === x || x !== null && w === x.alternate) break t; w = Mn(w), x = Mn(x) } w = null } else w = null; g !== null && Tu(p, h, g, w, !1), S !== null && I !== null && Tu(p, I, S, w, !0) } } e: { if (h = d ? Gn(d) : window, g = h.nodeName && h.nodeName.toLowerCase(), g === "select" || g === "input" && h.type === "file") var E = cg; else if (mu(h)) if (Pf) E = hg; else { E = fg; var C = dg } else (g = h.nodeName) && g.toLowerCase() === "input" && (h.type === "checkbox" || h.type === "radio") && (E = pg); if (E && (E = E(t, d))) { Rf(p, E, n, f); break e } C && C(t, h, d), t === "focusout" && (C = h._wrapperState) && C.controlled && h.type === "number" && Hs(h, "number", h.value) } switch (C = d ? Gn(d) : window, t) { case "focusin": (mu(C) || C.contentEditable === "true") && (bn = C, el = d, Vo = null); break; case "focusout": Vo = el = bn = null; break; case "mousedown": tl = !0; break; case "contextmenu": case "mouseup": case "dragend": tl = !1, wu(p, n, f); break; case "selectionchange": if (yg) break; case "keydown": case "keyup": wu(p, n, f) }var k; if (na) e: { switch (t) { case "compositionstart": var A = "onCompositionStart"; break e; case "compositionend": A = "onCompositionEnd"; break e; case "compositionupdate": A = "onCompositionUpdate"; break e }A = void 0 } else Fn ? Nf(t, n) && (A = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (A = "onCompositionStart"); A && (If && n.locale !== "ko" && (Fn || A !== "onCompositionStart" ? A === "onCompositionEnd" && Fn && (k = kf()) : (Kt = f, jl = "value" in Kt ? Kt.value : Kt.textContent, Fn = !0)), C = ci(d, A), 0 < C.length && (A = new du(A, t, null, n, f), p.push({ event: A, listeners: C }), k ? A.data = k : (k = Af(n), k !== null && (A.data = k)))), (k = ig ? sg(t, n) : lg(t, n)) && (d = ci(d, "onBeforeInput"), 0 < d.length && (f = new du("onBeforeInput", "beforeinput", null, n, f), p.push({ event: f, listeners: d }), f.data = k)) } qf(p, e) }) } function tr(t, e, n) { return { instance: t, listener: e, currentTarget: n } } function ci(t, e) { for (var n = e + "Capture", o = []; t !== null;) { var r = t, i = r.stateNode; r.tag === 5 && i !== null && (r = i, i = Ko(t, n), i != null && o.unshift(tr(t, i, r)), i = Ko(t, e), i != null && o.push(tr(t, i, r))), t = t.return } return o } function Mn(t) { if (t === null) return null; do t = t.return; while (t && t.tag !== 5); return t || null } function Tu(t, e, n, o, r) { for (var i = e._reactName, s = []; n !== null && n !== o;) { var u = n, c = u.alternate, d = u.stateNode; if (c !== null && c === o) break; u.tag === 5 && d !== null && (u = d, r ? (c = Ko(n, i), c != null && s.unshift(tr(n, c, u))) : r || (c = Ko(n, i), c != null && s.push(tr(n, c, u)))), n = n.return } s.length !== 0 && t.push({ event: e, listeners: s }) } var Cg = /\r\n?/g, Sg = /\u0000|\uFFFD/g; function _u(t) {
  return (typeof t == "string" ? t : "" + t).replace(Cg, `
`).replace(Sg, "")
} function Dr(t, e, n) { if (e = _u(e), _u(t) !== e && n) throw Error(R(425)) } function di() { } var nl = null, ol = null; function rl(t, e) { return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null } var il = typeof setTimeout == "function" ? setTimeout : void 0, Tg = typeof clearTimeout == "function" ? clearTimeout : void 0, Eu = typeof Promise == "function" ? Promise : void 0, _g = typeof queueMicrotask == "function" ? queueMicrotask : typeof Eu < "u" ? function (t) { return Eu.resolve(null).then(t).catch(Eg) } : il; function Eg(t) { setTimeout(function () { throw t }) } function _s(t, e) { var n = e, o = 0; do { var r = n.nextSibling; if (t.removeChild(n), r && r.nodeType === 8) if (n = r.data, n === "/$") { if (o === 0) { t.removeChild(r), Xo(e); return } o-- } else n !== "$" && n !== "$?" && n !== "$!" || o++; n = r } while (n); Xo(e) } function en(t) { for (; t != null; t = t.nextSibling) { var e = t.nodeType; if (e === 1 || e === 3) break; if (e === 8) { if (e = t.data, e === "$" || e === "$!" || e === "$?") break; if (e === "/$") return null } } return t } function ku(t) { t = t.previousSibling; for (var e = 0; t;) { if (t.nodeType === 8) { var n = t.data; if (n === "$" || n === "$!" || n === "$?") { if (e === 0) return t; e-- } else n === "/$" && e++ } t = t.previousSibling } return null } var po = Math.random().toString(36).slice(2), wt = "__reactFiber$" + po, nr = "__reactProps$" + po, Mt = "__reactContainer$" + po, sl = "__reactEvents$" + po, kg = "__reactListeners$" + po, Ig = "__reactHandles$" + po; function hn(t) { var e = t[wt]; if (e) return e; for (var n = t.parentNode; n;) { if (e = n[Mt] || n[wt]) { if (n = e.alternate, e.child !== null || n !== null && n.child !== null) for (t = ku(t); t !== null;) { if (n = t[wt]) return n; t = ku(t) } return e } t = n, n = t.parentNode } return null } function pr(t) { return t = t[wt] || t[Mt], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t } function Gn(t) { if (t.tag === 5 || t.tag === 6) return t.stateNode; throw Error(R(33)) } function $i(t) { return t[nr] || null } var ll = [], $n = -1; function un(t) { return { current: t } } function re(t) { 0 > $n || (t.current = ll[$n], ll[$n] = null, $n--) } function ee(t, e) { $n++, ll[$n] = t.current, t.current = e } var ln = {}, Pe = un(ln), Ge = un(!1), xn = ln; function ro(t, e) { var n = t.type.contextTypes; if (!n) return ln; var o = t.stateNode; if (o && o.__reactInternalMemoizedUnmaskedChildContext === e) return o.__reactInternalMemoizedMaskedChildContext; var r = {}, i; for (i in n) r[i] = e[i]; return o && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = r), r } function $e(t) { return t = t.childContextTypes, t != null } function fi() { re(Ge), re(Pe) } function Iu(t, e, n) { if (Pe.current !== ln) throw Error(R(168)); ee(Pe, e), ee(Ge, n) } function zf(t, e, n) { var o = t.stateNode; if (e = e.childContextTypes, typeof o.getChildContext != "function") return n; o = o.getChildContext(); for (var r in o) if (!(r in e)) throw Error(R(108, dm(t) || "Unknown", r)); return ue({}, n, o) } function pi(t) { return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || ln, xn = Pe.current, ee(Pe, t), ee(Ge, Ge.current), !0 } function Nu(t, e, n) { var o = t.stateNode; if (!o) throw Error(R(169)); n ? (t = zf(t, e, xn), o.__reactInternalMemoizedMergedChildContext = t, re(Ge), re(Pe), ee(Pe, t)) : re(Ge), ee(Ge, n) } var It = null, qi = !1, Es = !1; function Bf(t) { It === null ? It = [t] : It.push(t) } function Ng(t) { qi = !0, Bf(t) } function cn() { if (!Es && It !== null) { Es = !0; var t = 0, e = K; try { var n = It; for (K = 1; t < n.length; t++) { var o = n[t]; do o = o(!0); while (o !== null) } It = null, qi = !1 } catch (r) { throw It !== null && (It = It.slice(t + 1)), mf(Ol, cn), r } finally { K = e, Es = !1 } } return null } var qn = [], Hn = 0, hi = null, mi = 0, je = [], et = 0, wn = null, Nt = 1, At = ""; function fn(t, e) { qn[Hn++] = mi, qn[Hn++] = hi, hi = t, mi = e } function Jf(t, e, n) { je[et++] = Nt, je[et++] = At, je[et++] = wn, wn = t; var o = Nt; t = At; var r = 32 - ct(o) - 1; o &= ~(1 << r), n += 1; var i = 32 - ct(e) + r; if (30 < i) { var s = r - r % 5; i = (o & (1 << s) - 1).toString(32), o >>= s, r -= s, Nt = 1 << 32 - ct(e) + r | n << r | o, At = i + t } else Nt = 1 << i | n << r | o, At = t } function ra(t) { t.return !== null && (fn(t, 1), Jf(t, 1, 0)) } function ia(t) { for (; t === hi;)hi = qn[--Hn], qn[Hn] = null, mi = qn[--Hn], qn[Hn] = null; for (; t === wn;)wn = je[--et], je[et] = null, At = je[--et], je[et] = null, Nt = je[--et], je[et] = null } var Ye = null, We = null, ie = !1, ut = null; function Wf(t, e) { var n = tt(5, null, null, 0); n.elementType = "DELETED", n.stateNode = e, n.return = t, e = t.deletions, e === null ? (t.deletions = [n], t.flags |= 16) : e.push(n) } function Au(t, e) { switch (t.tag) { case 5: var n = t.type; return e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, Ye = t, We = en(e.firstChild), !0) : !1; case 6: return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, Ye = t, We = null, !0) : !1; case 13: return e = e.nodeType !== 8 ? null : e, e !== null ? (n = wn !== null ? { id: Nt, overflow: At } : null, t.memoizedState = { dehydrated: e, treeContext: n, retryLane: 1073741824 }, n = tt(18, null, null, 0), n.stateNode = e, n.return = t, t.child = n, Ye = t, We = null, !0) : !1; default: return !1 } } function al(t) { return (t.mode & 1) !== 0 && (t.flags & 128) === 0 } function ul(t) { if (ie) { var e = We; if (e) { var n = e; if (!Au(t, e)) { if (al(t)) throw Error(R(418)); e = en(n.nextSibling); var o = Ye; e && Au(t, e) ? Wf(o, n) : (t.flags = t.flags & -4097 | 2, ie = !1, Ye = t) } } else { if (al(t)) throw Error(R(418)); t.flags = t.flags & -4097 | 2, ie = !1, Ye = t } } } function Ru(t) { for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;)t = t.return; Ye = t } function Lr(t) { if (t !== Ye) return !1; if (!ie) return Ru(t), ie = !0, !1; var e; if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !rl(t.type, t.memoizedProps)), e && (e = We)) { if (al(t)) throw Yf(), Error(R(418)); for (; e;)Wf(t, e), e = en(e.nextSibling) } if (Ru(t), t.tag === 13) { if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(R(317)); e: { for (t = t.nextSibling, e = 0; t;) { if (t.nodeType === 8) { var n = t.data; if (n === "/$") { if (e === 0) { We = en(t.nextSibling); break e } e-- } else n !== "$" && n !== "$!" && n !== "$?" || e++ } t = t.nextSibling } We = null } } else We = Ye ? en(t.stateNode.nextSibling) : null; return !0 } function Yf() { for (var t = We; t;)t = en(t.nextSibling) } function io() { We = Ye = null, ie = !1 } function sa(t) { ut === null ? ut = [t] : ut.push(t) } var Ag = Ft.ReactCurrentBatchConfig; function Eo(t, e, n) { if (t = n.ref, t !== null && typeof t != "function" && typeof t != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(R(309)); var o = n.stateNode } if (!o) throw Error(R(147, t)); var r = o, i = "" + t; return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === i ? e.ref : (e = function (s) { var u = r.refs; s === null ? delete u[i] : u[i] = s }, e._stringRef = i, e) } if (typeof t != "string") throw Error(R(284)); if (!n._owner) throw Error(R(290, t)) } return t } function Ur(t, e) { throw t = Object.prototype.toString.call(e), Error(R(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t)) } function Pu(t) { var e = t._init; return e(t._payload) } function Kf(t) { function e(x, y) { if (t) { var v = x.deletions; v === null ? (x.deletions = [y], x.flags |= 16) : v.push(y) } } function n(x, y) { if (!t) return null; for (; y !== null;)e(x, y), y = y.sibling; return null } function o(x, y) { for (x = new Map; y !== null;)y.key !== null ? x.set(y.key, y) : x.set(y.index, y), y = y.sibling; return x } function r(x, y) { return x = rn(x, y), x.index = 0, x.sibling = null, x } function i(x, y, v) { return x.index = v, t ? (v = x.alternate, v !== null ? (v = v.index, v < y ? (x.flags |= 2, y) : v) : (x.flags |= 2, y)) : (x.flags |= 1048576, y) } function s(x) { return t && x.alternate === null && (x.flags |= 2), x } function u(x, y, v, T) { return y === null || y.tag !== 6 ? (y = Ms(v, x.mode, T), y.return = x, y) : (y = r(y, v), y.return = x, y) } function c(x, y, v, T) { var E = v.type; return E === Un ? f(x, y, v.props.children, T, v.key) : y !== null && (y.elementType === E || typeof E == "object" && E !== null && E.$$typeof === Bt && Pu(E) === y.type) ? (T = r(y, v.props), T.ref = Eo(x, y, v), T.return = x, T) : (T = jr(v.type, v.key, v.props, null, x.mode, T), T.ref = Eo(x, y, v), T.return = x, T) } function d(x, y, v, T) { return y === null || y.tag !== 4 || y.stateNode.containerInfo !== v.containerInfo || y.stateNode.implementation !== v.implementation ? (y = Ds(v, x.mode, T), y.return = x, y) : (y = r(y, v.children || []), y.return = x, y) } function f(x, y, v, T, E) { return y === null || y.tag !== 7 ? (y = vn(v, x.mode, T, E), y.return = x, y) : (y = r(y, v), y.return = x, y) } function p(x, y, v) { if (typeof y == "string" && y !== "" || typeof y == "number") return y = Ms("" + y, x.mode, v), y.return = x, y; if (typeof y == "object" && y !== null) { switch (y.$$typeof) { case _r: return v = jr(y.type, y.key, y.props, null, x.mode, v), v.ref = Eo(x, null, y), v.return = x, v; case Ln: return y = Ds(y, x.mode, v), y.return = x, y; case Bt: var T = y._init; return p(x, T(y._payload), v) }if (Po(y) || wo(y)) return y = vn(y, x.mode, v, null), y.return = x, y; Ur(x, y) } return null } function h(x, y, v, T) { var E = y !== null ? y.key : null; if (typeof v == "string" && v !== "" || typeof v == "number") return E !== null ? null : u(x, y, "" + v, T); if (typeof v == "object" && v !== null) { switch (v.$$typeof) { case _r: return v.key === E ? c(x, y, v, T) : null; case Ln: return v.key === E ? d(x, y, v, T) : null; case Bt: return E = v._init, h(x, y, E(v._payload), T) }if (Po(v) || wo(v)) return E !== null ? null : f(x, y, v, T, null); Ur(x, v) } return null } function g(x, y, v, T, E) { if (typeof T == "string" && T !== "" || typeof T == "number") return x = x.get(v) || null, u(y, x, "" + T, E); if (typeof T == "object" && T !== null) { switch (T.$$typeof) { case _r: return x = x.get(T.key === null ? v : T.key) || null, c(y, x, T, E); case Ln: return x = x.get(T.key === null ? v : T.key) || null, d(y, x, T, E); case Bt: var C = T._init; return g(x, y, v, C(T._payload), E) }if (Po(T) || wo(T)) return x = x.get(v) || null, f(y, x, T, E, null); Ur(y, T) } return null } function S(x, y, v, T) { for (var E = null, C = null, k = y, A = y = 0, N = null; k !== null && A < v.length; A++) { k.index > A ? (N = k, k = null) : N = k.sibling; var M = h(x, k, v[A], T); if (M === null) { k === null && (k = N); break } t && k && M.alternate === null && e(x, k), y = i(M, y, A), C === null ? E = M : C.sibling = M, C = M, k = N } if (A === v.length) return n(x, k), ie && fn(x, A), E; if (k === null) { for (; A < v.length; A++)k = p(x, v[A], T), k !== null && (y = i(k, y, A), C === null ? E = k : C.sibling = k, C = k); return ie && fn(x, A), E } for (k = o(x, k); A < v.length; A++)N = g(k, x, A, v[A], T), N !== null && (t && N.alternate !== null && k.delete(N.key === null ? A : N.key), y = i(N, y, A), C === null ? E = N : C.sibling = N, C = N); return t && k.forEach(function (b) { return e(x, b) }), ie && fn(x, A), E } function w(x, y, v, T) { var E = wo(v); if (typeof E != "function") throw Error(R(150)); if (v = E.call(v), v == null) throw Error(R(151)); for (var C = E = null, k = y, A = y = 0, N = null, M = v.next(); k !== null && !M.done; A++, M = v.next()) { k.index > A ? (N = k, k = null) : N = k.sibling; var b = h(x, k, M.value, T); if (b === null) { k === null && (k = N); break } t && k && b.alternate === null && e(x, k), y = i(b, y, A), C === null ? E = b : C.sibling = b, C = b, k = N } if (M.done) return n(x, k), ie && fn(x, A), E; if (k === null) { for (; !M.done; A++, M = v.next())M = p(x, M.value, T), M !== null && (y = i(M, y, A), C === null ? E = M : C.sibling = M, C = M); return ie && fn(x, A), E } for (k = o(x, k); !M.done; A++, M = v.next())M = g(k, x, A, M.value, T), M !== null && (t && M.alternate !== null && k.delete(M.key === null ? A : M.key), y = i(M, y, A), C === null ? E = M : C.sibling = M, C = M); return t && k.forEach(function (z) { return e(x, z) }), ie && fn(x, A), E } function I(x, y, v, T) { if (typeof v == "object" && v !== null && v.type === Un && v.key === null && (v = v.props.children), typeof v == "object" && v !== null) { switch (v.$$typeof) { case _r: e: { for (var E = v.key, C = y; C !== null;) { if (C.key === E) { if (E = v.type, E === Un) { if (C.tag === 7) { n(x, C.sibling), y = r(C, v.props.children), y.return = x, x = y; break e } } else if (C.elementType === E || typeof E == "object" && E !== null && E.$$typeof === Bt && Pu(E) === C.type) { n(x, C.sibling), y = r(C, v.props), y.ref = Eo(x, C, v), y.return = x, x = y; break e } n(x, C); break } else e(x, C); C = C.sibling } v.type === Un ? (y = vn(v.props.children, x.mode, T, v.key), y.return = x, x = y) : (T = jr(v.type, v.key, v.props, null, x.mode, T), T.ref = Eo(x, y, v), T.return = x, x = T) } return s(x); case Ln: e: { for (C = v.key; y !== null;) { if (y.key === C) if (y.tag === 4 && y.stateNode.containerInfo === v.containerInfo && y.stateNode.implementation === v.implementation) { n(x, y.sibling), y = r(y, v.children || []), y.return = x, x = y; break e } else { n(x, y); break } else e(x, y); y = y.sibling } y = Ds(v, x.mode, T), y.return = x, x = y } return s(x); case Bt: return C = v._init, I(x, y, C(v._payload), T) }if (Po(v)) return S(x, y, v, T); if (wo(v)) return w(x, y, v, T); Ur(x, v) } return typeof v == "string" && v !== "" || typeof v == "number" ? (v = "" + v, y !== null && y.tag === 6 ? (n(x, y.sibling), y = r(y, v), y.return = x, x = y) : (n(x, y), y = Ms(v, x.mode, T), y.return = x, x = y), s(x)) : n(x, y) } return I } var so = Kf(!0), Of = Kf(!1), gi = un(null), yi = null, zn = null, la = null; function aa() { la = zn = yi = null } function ua(t) { var e = gi.current; re(gi), t._currentValue = e } function cl(t, e, n) { for (; t !== null;) { var o = t.alternate; if ((t.childLanes & e) !== e ? (t.childLanes |= e, o !== null && (o.childLanes |= e)) : o !== null && (o.childLanes & e) !== e && (o.childLanes |= e), t === n) break; t = t.return } } function Zn(t, e) { yi = t, la = zn = null, t = t.dependencies, t !== null && t.firstContext !== null && (t.lanes & e && (Ve = !0), t.firstContext = null) } function rt(t) { var e = t._currentValue; if (la !== t) if (t = { context: t, memoizedValue: e, next: null }, zn === null) { if (yi === null) throw Error(R(308)); zn = t, yi.dependencies = { lanes: 0, firstContext: t } } else zn = zn.next = t; return e } var mn = null; function ca(t) { mn === null ? mn = [t] : mn.push(t) } function Qf(t, e, n, o) { var r = e.interleaved; return r === null ? (n.next = n, ca(e)) : (n.next = r.next, r.next = n), e.interleaved = n, Dt(t, o) } function Dt(t, e) { t.lanes |= e; var n = t.alternate; for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null;)t.childLanes |= e, n = t.alternate, n !== null && (n.childLanes |= e), n = t, t = t.return; return n.tag === 3 ? n.stateNode : null } var Jt = !1; function da(t) { t.updateQueue = { baseState: t.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Xf(t, e) { t = t.updateQueue, e.updateQueue === t && (e.updateQueue = { baseState: t.baseState, firstBaseUpdate: t.firstBaseUpdate, lastBaseUpdate: t.lastBaseUpdate, shared: t.shared, effects: t.effects }) } function Rt(t, e) { return { eventTime: t, lane: e, tag: 0, payload: null, callback: null, next: null } } function tn(t, e, n) { var o = t.updateQueue; if (o === null) return null; if (o = o.shared, J & 2) { var r = o.pending; return r === null ? e.next = e : (e.next = r.next, r.next = e), o.pending = e, Dt(t, n) } return r = o.interleaved, r === null ? (e.next = e, ca(o)) : (e.next = r.next, r.next = e), o.interleaved = e, Dt(t, n) } function Yr(t, e, n) { if (e = e.updateQueue, e !== null && (e = e.shared, (n & 4194240) !== 0)) { var o = e.lanes; o &= t.pendingLanes, n |= o, e.lanes = n, Ql(t, n) } } function Mu(t, e) { var n = t.updateQueue, o = t.alternate; if (o !== null && (o = o.updateQueue, n === o)) { var r = null, i = null; if (n = n.firstBaseUpdate, n !== null) { do { var s = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; i === null ? r = i = s : i = i.next = s, n = n.next } while (n !== null); i === null ? r = i = e : i = i.next = e } else r = i = e; n = { baseState: o.baseState, firstBaseUpdate: r, lastBaseUpdate: i, shared: o.shared, effects: o.effects }, t.updateQueue = n; return } t = n.lastBaseUpdate, t === null ? n.firstBaseUpdate = e : t.next = e, n.lastBaseUpdate = e } function vi(t, e, n, o) { var r = t.updateQueue; Jt = !1; var i = r.firstBaseUpdate, s = r.lastBaseUpdate, u = r.shared.pending; if (u !== null) { r.shared.pending = null; var c = u, d = c.next; c.next = null, s === null ? i = d : s.next = d, s = c; var f = t.alternate; f !== null && (f = f.updateQueue, u = f.lastBaseUpdate, u !== s && (u === null ? f.firstBaseUpdate = d : u.next = d, f.lastBaseUpdate = c)) } if (i !== null) { var p = r.baseState; s = 0, f = d = c = null, u = i; do { var h = u.lane, g = u.eventTime; if ((o & h) === h) { f !== null && (f = f.next = { eventTime: g, lane: 0, tag: u.tag, payload: u.payload, callback: u.callback, next: null }); e: { var S = t, w = u; switch (h = e, g = n, w.tag) { case 1: if (S = w.payload, typeof S == "function") { p = S.call(g, p, h); break e } p = S; break e; case 3: S.flags = S.flags & -65537 | 128; case 0: if (S = w.payload, h = typeof S == "function" ? S.call(g, p, h) : S, h == null) break e; p = ue({}, p, h); break e; case 2: Jt = !0 } } u.callback !== null && u.lane !== 0 && (t.flags |= 64, h = r.effects, h === null ? r.effects = [u] : h.push(u)) } else g = { eventTime: g, lane: h, tag: u.tag, payload: u.payload, callback: u.callback, next: null }, f === null ? (d = f = g, c = p) : f = f.next = g, s |= h; if (u = u.next, u === null) { if (u = r.shared.pending, u === null) break; h = u, u = h.next, h.next = null, r.lastBaseUpdate = h, r.shared.pending = null } } while (1); if (f === null && (c = p), r.baseState = c, r.firstBaseUpdate = d, r.lastBaseUpdate = f, e = r.shared.interleaved, e !== null) { r = e; do s |= r.lane, r = r.next; while (r !== e) } else i === null && (r.shared.lanes = 0); Sn |= s, t.lanes = s, t.memoizedState = p } } function Du(t, e, n) { if (t = e.effects, e.effects = null, t !== null) for (e = 0; e < t.length; e++) { var o = t[e], r = o.callback; if (r !== null) { if (o.callback = null, o = n, typeof r != "function") throw Error(R(191, r)); r.call(o) } } } var hr = {}, _t = un(hr), or = un(hr), rr = un(hr); function gn(t) { if (t === hr) throw Error(R(174)); return t } function fa(t, e) { switch (ee(rr, e), ee(or, t), ee(_t, hr), t = e.nodeType, t) { case 9: case 11: e = (e = e.documentElement) ? e.namespaceURI : Bs(null, ""); break; default: t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = Bs(e, t) }re(_t), ee(_t, e) } function lo() { re(_t), re(or), re(rr) } function Zf(t) { gn(rr.current); var e = gn(_t.current), n = Bs(e, t.type); e !== n && (ee(or, t), ee(_t, n)) } function pa(t) { or.current === t && (re(_t), re(or)) } var le = un(0); function xi(t) { for (var e = t; e !== null;) { if (e.tag === 13) { var n = e.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return e } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) { if (e.flags & 128) return e } else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return null; e = e.return } e.sibling.return = e.return, e = e.sibling } return null } var ks = []; function ha() { for (var t = 0; t < ks.length; t++)ks[t]._workInProgressVersionPrimary = null; ks.length = 0 } var Kr = Ft.ReactCurrentDispatcher, Is = Ft.ReactCurrentBatchConfig, Cn = 0, ae = null, ge = null, xe = null, wi = !1, Go = !1, ir = 0, Rg = 0; function Ie() { throw Error(R(321)) } function ma(t, e) { if (e === null) return !1; for (var n = 0; n < e.length && n < t.length; n++)if (!ft(t[n], e[n])) return !1; return !0 } function ga(t, e, n, o, r, i) { if (Cn = i, ae = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, Kr.current = t === null || t.memoizedState === null ? Lg : Ug, t = n(o, r), Go) { i = 0; do { if (Go = !1, ir = 0, 25 <= i) throw Error(R(301)); i += 1, xe = ge = null, e.updateQueue = null, Kr.current = Fg, t = n(o, r) } while (Go) } if (Kr.current = Ci, e = ge !== null && ge.next !== null, Cn = 0, xe = ge = ae = null, wi = !1, e) throw Error(R(300)); return t } function ya() { var t = ir !== 0; return ir = 0, t } function xt() { var t = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return xe === null ? ae.memoizedState = xe = t : xe = xe.next = t, xe } function it() { if (ge === null) { var t = ae.alternate; t = t !== null ? t.memoizedState : null } else t = ge.next; var e = xe === null ? ae.memoizedState : xe.next; if (e !== null) xe = e, ge = t; else { if (t === null) throw Error(R(310)); ge = t, t = { memoizedState: ge.memoizedState, baseState: ge.baseState, baseQueue: ge.baseQueue, queue: ge.queue, next: null }, xe === null ? ae.memoizedState = xe = t : xe = xe.next = t } return xe } function sr(t, e) { return typeof e == "function" ? e(t) : e } function Ns(t) { var e = it(), n = e.queue; if (n === null) throw Error(R(311)); n.lastRenderedReducer = t; var o = ge, r = o.baseQueue, i = n.pending; if (i !== null) { if (r !== null) { var s = r.next; r.next = i.next, i.next = s } o.baseQueue = r = i, n.pending = null } if (r !== null) { i = r.next, o = o.baseState; var u = s = null, c = null, d = i; do { var f = d.lane; if ((Cn & f) === f) c !== null && (c = c.next = { lane: 0, action: d.action, hasEagerState: d.hasEagerState, eagerState: d.eagerState, next: null }), o = d.hasEagerState ? d.eagerState : t(o, d.action); else { var p = { lane: f, action: d.action, hasEagerState: d.hasEagerState, eagerState: d.eagerState, next: null }; c === null ? (u = c = p, s = o) : c = c.next = p, ae.lanes |= f, Sn |= f } d = d.next } while (d !== null && d !== i); c === null ? s = o : c.next = u, ft(o, e.memoizedState) || (Ve = !0), e.memoizedState = o, e.baseState = s, e.baseQueue = c, n.lastRenderedState = o } if (t = n.interleaved, t !== null) { r = t; do i = r.lane, ae.lanes |= i, Sn |= i, r = r.next; while (r !== t) } else r === null && (n.lanes = 0); return [e.memoizedState, n.dispatch] } function As(t) { var e = it(), n = e.queue; if (n === null) throw Error(R(311)); n.lastRenderedReducer = t; var o = n.dispatch, r = n.pending, i = e.memoizedState; if (r !== null) { n.pending = null; var s = r = r.next; do i = t(i, s.action), s = s.next; while (s !== r); ft(i, e.memoizedState) || (Ve = !0), e.memoizedState = i, e.baseQueue === null && (e.baseState = i), n.lastRenderedState = i } return [i, o] } function jf() { } function ep(t, e) { var n = ae, o = it(), r = e(), i = !ft(o.memoizedState, r); if (i && (o.memoizedState = r, Ve = !0), o = o.queue, va(op.bind(null, n, o, t), [t]), o.getSnapshot !== e || i || xe !== null && xe.memoizedState.tag & 1) { if (n.flags |= 2048, lr(9, np.bind(null, n, o, r, e), void 0, null), we === null) throw Error(R(349)); Cn & 30 || tp(n, e, r) } return r } function tp(t, e, n) { t.flags |= 16384, t = { getSnapshot: e, value: n }, e = ae.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, ae.updateQueue = e, e.stores = [t]) : (n = e.stores, n === null ? e.stores = [t] : n.push(t)) } function np(t, e, n, o) { e.value = n, e.getSnapshot = o, rp(e) && ip(t) } function op(t, e, n) { return n(function () { rp(e) && ip(t) }) } function rp(t) { var e = t.getSnapshot; t = t.value; try { var n = e(); return !ft(t, n) } catch { return !0 } } function ip(t) { var e = Dt(t, 1); e !== null && dt(e, t, 1, -1) } function Lu(t) { var e = xt(); return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: sr, lastRenderedState: t }, e.queue = t, t = t.dispatch = Dg.bind(null, ae, t), [e.memoizedState, t] } function lr(t, e, n, o) { return t = { tag: t, create: e, destroy: n, deps: o, next: null }, e = ae.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, ae.updateQueue = e, e.lastEffect = t.next = t) : (n = e.lastEffect, n === null ? e.lastEffect = t.next = t : (o = n.next, n.next = t, t.next = o, e.lastEffect = t)), t } function sp() { return it().memoizedState } function Or(t, e, n, o) { var r = xt(); ae.flags |= t, r.memoizedState = lr(1 | e, n, void 0, o === void 0 ? null : o) } function Hi(t, e, n, o) { var r = it(); o = o === void 0 ? null : o; var i = void 0; if (ge !== null) { var s = ge.memoizedState; if (i = s.destroy, o !== null && ma(o, s.deps)) { r.memoizedState = lr(e, n, i, o); return } } ae.flags |= t, r.memoizedState = lr(1 | e, n, i, o) } function Uu(t, e) { return Or(8390656, 8, t, e) } function va(t, e) { return Hi(2048, 8, t, e) } function lp(t, e) { return Hi(4, 2, t, e) } function ap(t, e) { return Hi(4, 4, t, e) } function up(t, e) { if (typeof e == "function") return t = t(), e(t), function () { e(null) }; if (e != null) return t = t(), e.current = t, function () { e.current = null } } function cp(t, e, n) { return n = n != null ? n.concat([t]) : null, Hi(4, 4, up.bind(null, e, t), n) } function xa() { } function dp(t, e) { var n = it(); e = e === void 0 ? null : e; var o = n.memoizedState; return o !== null && e !== null && ma(e, o[1]) ? o[0] : (n.memoizedState = [t, e], t) } function fp(t, e) { var n = it(); e = e === void 0 ? null : e; var o = n.memoizedState; return o !== null && e !== null && ma(e, o[1]) ? o[0] : (t = t(), n.memoizedState = [t, e], t) } function pp(t, e, n) { return Cn & 21 ? (ft(n, e) || (n = vf(), ae.lanes |= n, Sn |= n, t.baseState = !0), e) : (t.baseState && (t.baseState = !1, Ve = !0), t.memoizedState = n) } function Pg(t, e) { var n = K; K = n !== 0 && 4 > n ? n : 4, t(!0); var o = Is.transition; Is.transition = {}; try { t(!1), e() } finally { K = n, Is.transition = o } } function hp() { return it().memoizedState } function Mg(t, e, n) { var o = on(t); if (n = { lane: o, action: n, hasEagerState: !1, eagerState: null, next: null }, mp(t)) gp(e, n); else if (n = Qf(t, e, n, o), n !== null) { var r = Le(); dt(n, t, o, r), yp(n, e, o) } } function Dg(t, e, n) { var o = on(t), r = { lane: o, action: n, hasEagerState: !1, eagerState: null, next: null }; if (mp(t)) gp(e, r); else { var i = t.alternate; if (t.lanes === 0 && (i === null || i.lanes === 0) && (i = e.lastRenderedReducer, i !== null)) try { var s = e.lastRenderedState, u = i(s, n); if (r.hasEagerState = !0, r.eagerState = u, ft(u, s)) { var c = e.interleaved; c === null ? (r.next = r, ca(e)) : (r.next = c.next, c.next = r), e.interleaved = r; return } } catch { } finally { } n = Qf(t, e, r, o), n !== null && (r = Le(), dt(n, t, o, r), yp(n, e, o)) } } function mp(t) { var e = t.alternate; return t === ae || e !== null && e === ae } function gp(t, e) { Go = wi = !0; var n = t.pending; n === null ? e.next = e : (e.next = n.next, n.next = e), t.pending = e } function yp(t, e, n) { if (n & 4194240) { var o = e.lanes; o &= t.pendingLanes, n |= o, e.lanes = n, Ql(t, n) } } var Ci = { readContext: rt, useCallback: Ie, useContext: Ie, useEffect: Ie, useImperativeHandle: Ie, useInsertionEffect: Ie, useLayoutEffect: Ie, useMemo: Ie, useReducer: Ie, useRef: Ie, useState: Ie, useDebugValue: Ie, useDeferredValue: Ie, useTransition: Ie, useMutableSource: Ie, useSyncExternalStore: Ie, useId: Ie, unstable_isNewReconciler: !1 }, Lg = { readContext: rt, useCallback: function (t, e) { return xt().memoizedState = [t, e === void 0 ? null : e], t }, useContext: rt, useEffect: Uu, useImperativeHandle: function (t, e, n) { return n = n != null ? n.concat([t]) : null, Or(4194308, 4, up.bind(null, e, t), n) }, useLayoutEffect: function (t, e) { return Or(4194308, 4, t, e) }, useInsertionEffect: function (t, e) { return Or(4, 2, t, e) }, useMemo: function (t, e) { var n = xt(); return e = e === void 0 ? null : e, t = t(), n.memoizedState = [t, e], t }, useReducer: function (t, e, n) { var o = xt(); return e = n !== void 0 ? n(e) : e, o.memoizedState = o.baseState = e, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: t, lastRenderedState: e }, o.queue = t, t = t.dispatch = Mg.bind(null, ae, t), [o.memoizedState, t] }, useRef: function (t) { var e = xt(); return t = { current: t }, e.memoizedState = t }, useState: Lu, useDebugValue: xa, useDeferredValue: function (t) { return xt().memoizedState = t }, useTransition: function () { var t = Lu(!1), e = t[0]; return t = Pg.bind(null, t[1]), xt().memoizedState = t, [e, t] }, useMutableSource: function () { }, useSyncExternalStore: function (t, e, n) { var o = ae, r = xt(); if (ie) { if (n === void 0) throw Error(R(407)); n = n() } else { if (n = e(), we === null) throw Error(R(349)); Cn & 30 || tp(o, e, n) } r.memoizedState = n; var i = { value: n, getSnapshot: e }; return r.queue = i, Uu(op.bind(null, o, i, t), [t]), o.flags |= 2048, lr(9, np.bind(null, o, i, n, e), void 0, null), n }, useId: function () { var t = xt(), e = we.identifierPrefix; if (ie) { var n = At, o = Nt; n = (o & ~(1 << 32 - ct(o) - 1)).toString(32) + n, e = ":" + e + "R" + n, n = ir++, 0 < n && (e += "H" + n.toString(32)), e += ":" } else n = Rg++, e = ":" + e + "r" + n.toString(32) + ":"; return t.memoizedState = e }, unstable_isNewReconciler: !1 }, Ug = { readContext: rt, useCallback: dp, useContext: rt, useEffect: va, useImperativeHandle: cp, useInsertionEffect: lp, useLayoutEffect: ap, useMemo: fp, useReducer: Ns, useRef: sp, useState: function () { return Ns(sr) }, useDebugValue: xa, useDeferredValue: function (t) { var e = it(); return pp(e, ge.memoizedState, t) }, useTransition: function () { var t = Ns(sr)[0], e = it().memoizedState; return [t, e] }, useMutableSource: jf, useSyncExternalStore: ep, useId: hp, unstable_isNewReconciler: !1 }, Fg = { readContext: rt, useCallback: dp, useContext: rt, useEffect: va, useImperativeHandle: cp, useInsertionEffect: lp, useLayoutEffect: ap, useMemo: fp, useReducer: As, useRef: sp, useState: function () { return As(sr) }, useDebugValue: xa, useDeferredValue: function (t) { var e = it(); return ge === null ? e.memoizedState = t : pp(e, ge.memoizedState, t) }, useTransition: function () { var t = As(sr)[0], e = it().memoizedState; return [t, e] }, useMutableSource: jf, useSyncExternalStore: ep, useId: hp, unstable_isNewReconciler: !1 }; function lt(t, e) { if (t && t.defaultProps) { e = ue({}, e), t = t.defaultProps; for (var n in t) e[n] === void 0 && (e[n] = t[n]); return e } return e } function dl(t, e, n, o) { e = t.memoizedState, n = n(o, e), n = n == null ? e : ue({}, e, n), t.memoizedState = n, t.lanes === 0 && (t.updateQueue.baseState = n) } var zi = { isMounted: function (t) { return (t = t._reactInternals) ? kn(t) === t : !1 }, enqueueSetState: function (t, e, n) { t = t._reactInternals; var o = Le(), r = on(t), i = Rt(o, r); i.payload = e, n != null && (i.callback = n), e = tn(t, i, r), e !== null && (dt(e, t, r, o), Yr(e, t, r)) }, enqueueReplaceState: function (t, e, n) { t = t._reactInternals; var o = Le(), r = on(t), i = Rt(o, r); i.tag = 1, i.payload = e, n != null && (i.callback = n), e = tn(t, i, r), e !== null && (dt(e, t, r, o), Yr(e, t, r)) }, enqueueForceUpdate: function (t, e) { t = t._reactInternals; var n = Le(), o = on(t), r = Rt(n, o); r.tag = 2, e != null && (r.callback = e), e = tn(t, r, o), e !== null && (dt(e, t, o, n), Yr(e, t, o)) } }; function Fu(t, e, n, o, r, i, s) { return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(o, i, s) : e.prototype && e.prototype.isPureReactComponent ? !jo(n, o) || !jo(r, i) : !0 } function vp(t, e, n) { var o = !1, r = ln, i = e.contextType; return typeof i == "object" && i !== null ? i = rt(i) : (r = $e(e) ? xn : Pe.current, o = e.contextTypes, i = (o = o != null) ? ro(t, r) : ln), e = new e(n, i), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = zi, t.stateNode = e, e._reactInternals = t, o && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = r, t.__reactInternalMemoizedMaskedChildContext = i), e } function bu(t, e, n, o) { t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, o), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, o), e.state !== t && zi.enqueueReplaceState(e, e.state, null) } function fl(t, e, n, o) { var r = t.stateNode; r.props = n, r.state = t.memoizedState, r.refs = {}, da(t); var i = e.contextType; typeof i == "object" && i !== null ? r.context = rt(i) : (i = $e(e) ? xn : Pe.current, r.context = ro(t, i)), r.state = t.memoizedState, i = e.getDerivedStateFromProps, typeof i == "function" && (dl(t, e, i, n), r.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (e = r.state, typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), e !== r.state && zi.enqueueReplaceState(r, r.state, null), vi(t, n, r, o), r.state = t.memoizedState), typeof r.componentDidMount == "function" && (t.flags |= 4194308) } function ao(t, e) {
  try { var n = "", o = e; do n += cm(o), o = o.return; while (o); var r = n } catch (i) {
    r = `
Error generating stack: `+ i.message + `
`+ i.stack
  } return { value: t, source: e, stack: r, digest: null }
} function Rs(t, e, n) { return { value: t, source: null, stack: n ?? null, digest: e ?? null } } function pl(t, e) { try { console.error(e.value) } catch (n) { setTimeout(function () { throw n }) } } var bg = typeof WeakMap == "function" ? WeakMap : Map; function xp(t, e, n) { n = Rt(-1, n), n.tag = 3, n.payload = { element: null }; var o = e.value; return n.callback = function () { Ti || (Ti = !0, Tl = o), pl(t, e) }, n } function wp(t, e, n) { n = Rt(-1, n), n.tag = 3; var o = t.type.getDerivedStateFromError; if (typeof o == "function") { var r = e.value; n.payload = function () { return o(r) }, n.callback = function () { pl(t, e) } } var i = t.stateNode; return i !== null && typeof i.componentDidCatch == "function" && (n.callback = function () { pl(t, e), typeof o != "function" && (nn === null ? nn = new Set([this]) : nn.add(this)); var s = e.stack; this.componentDidCatch(e.value, { componentStack: s !== null ? s : "" }) }), n } function Vu(t, e, n) { var o = t.pingCache; if (o === null) { o = t.pingCache = new bg; var r = new Set; o.set(e, r) } else r = o.get(e), r === void 0 && (r = new Set, o.set(e, r)); r.has(n) || (r.add(n), t = Xg.bind(null, t, e, n), e.then(t, t)) } function Gu(t) { do { var e; if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return t; t = t.return } while (t !== null); return null } function $u(t, e, n, o, r) { return t.mode & 1 ? (t.flags |= 65536, t.lanes = r, t) : (t === e ? t.flags |= 65536 : (t.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (e = Rt(-1, 1), e.tag = 2, tn(n, e, 1))), n.lanes |= 1), t) } var Vg = Ft.ReactCurrentOwner, Ve = !1; function De(t, e, n, o) { e.child = t === null ? Of(e, null, n, o) : so(e, t.child, n, o) } function qu(t, e, n, o, r) { n = n.render; var i = e.ref; return Zn(e, r), o = ga(t, e, n, o, i, r), n = ya(), t !== null && !Ve ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~r, Lt(t, e, r)) : (ie && n && ra(e), e.flags |= 1, De(t, e, o, r), e.child) } function Hu(t, e, n, o, r) { if (t === null) { var i = n.type; return typeof i == "function" && !Ia(i) && i.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (e.tag = 15, e.type = i, Cp(t, e, i, o, r)) : (t = jr(n.type, null, o, e, e.mode, r), t.ref = e.ref, t.return = e, e.child = t) } if (i = t.child, !(t.lanes & r)) { var s = i.memoizedProps; if (n = n.compare, n = n !== null ? n : jo, n(s, o) && t.ref === e.ref) return Lt(t, e, r) } return e.flags |= 1, t = rn(i, o), t.ref = e.ref, t.return = e, e.child = t } function Cp(t, e, n, o, r) { if (t !== null) { var i = t.memoizedProps; if (jo(i, o) && t.ref === e.ref) if (Ve = !1, e.pendingProps = o = i, (t.lanes & r) !== 0) t.flags & 131072 && (Ve = !0); else return e.lanes = t.lanes, Lt(t, e, r) } return hl(t, e, n, o, r) } function Sp(t, e, n) { var o = e.pendingProps, r = o.children, i = t !== null ? t.memoizedState : null; if (o.mode === "hidden") if (!(e.mode & 1)) e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, ee(Jn, Be), Be |= n; else { if (!(n & 1073741824)) return t = i !== null ? i.baseLanes | n : n, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: t, cachePool: null, transitions: null }, e.updateQueue = null, ee(Jn, Be), Be |= t, null; e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, o = i !== null ? i.baseLanes : n, ee(Jn, Be), Be |= o } else i !== null ? (o = i.baseLanes | n, e.memoizedState = null) : o = n, ee(Jn, Be), Be |= o; return De(t, e, r, n), e.child } function Tp(t, e) { var n = e.ref; (t === null && n !== null || t !== null && t.ref !== n) && (e.flags |= 512, e.flags |= 2097152) } function hl(t, e, n, o, r) { var i = $e(n) ? xn : Pe.current; return i = ro(e, i), Zn(e, r), n = ga(t, e, n, o, i, r), o = ya(), t !== null && !Ve ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~r, Lt(t, e, r)) : (ie && o && ra(e), e.flags |= 1, De(t, e, n, r), e.child) } function zu(t, e, n, o, r) { if ($e(n)) { var i = !0; pi(e) } else i = !1; if (Zn(e, r), e.stateNode === null) Qr(t, e), vp(e, n, o), fl(e, n, o, r), o = !0; else if (t === null) { var s = e.stateNode, u = e.memoizedProps; s.props = u; var c = s.context, d = n.contextType; typeof d == "object" && d !== null ? d = rt(d) : (d = $e(n) ? xn : Pe.current, d = ro(e, d)); var f = n.getDerivedStateFromProps, p = typeof f == "function" || typeof s.getSnapshotBeforeUpdate == "function"; p || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (u !== o || c !== d) && bu(e, s, o, d), Jt = !1; var h = e.memoizedState; s.state = h, vi(e, o, s, r), c = e.memoizedState, u !== o || h !== c || Ge.current || Jt ? (typeof f == "function" && (dl(e, n, f, o), c = e.memoizedState), (u = Jt || Fu(e, n, u, o, h, c, d)) ? (p || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()), typeof s.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = o, e.memoizedState = c), s.props = o, s.state = c, s.context = d, o = u) : (typeof s.componentDidMount == "function" && (e.flags |= 4194308), o = !1) } else { s = e.stateNode, Xf(t, e), u = e.memoizedProps, d = e.type === e.elementType ? u : lt(e.type, u), s.props = d, p = e.pendingProps, h = s.context, c = n.contextType, typeof c == "object" && c !== null ? c = rt(c) : (c = $e(n) ? xn : Pe.current, c = ro(e, c)); var g = n.getDerivedStateFromProps; (f = typeof g == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (u !== p || h !== c) && bu(e, s, o, c), Jt = !1, h = e.memoizedState, s.state = h, vi(e, o, s, r); var S = e.memoizedState; u !== p || h !== S || Ge.current || Jt ? (typeof g == "function" && (dl(e, n, g, o), S = e.memoizedState), (d = Jt || Fu(e, n, d, o, h, S, c) || !1) ? (f || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(o, S, c), typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(o, S, c)), typeof s.componentDidUpdate == "function" && (e.flags |= 4), typeof s.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || u === t.memoizedProps && h === t.memoizedState || (e.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || u === t.memoizedProps && h === t.memoizedState || (e.flags |= 1024), e.memoizedProps = o, e.memoizedState = S), s.props = o, s.state = S, s.context = c, o = d) : (typeof s.componentDidUpdate != "function" || u === t.memoizedProps && h === t.memoizedState || (e.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || u === t.memoizedProps && h === t.memoizedState || (e.flags |= 1024), o = !1) } return ml(t, e, n, o, i, r) } function ml(t, e, n, o, r, i) { Tp(t, e); var s = (e.flags & 128) !== 0; if (!o && !s) return r && Nu(e, n, !1), Lt(t, e, i); o = e.stateNode, Vg.current = e; var u = s && typeof n.getDerivedStateFromError != "function" ? null : o.render(); return e.flags |= 1, t !== null && s ? (e.child = so(e, t.child, null, i), e.child = so(e, null, u, i)) : De(t, e, u, i), e.memoizedState = o.state, r && Nu(e, n, !0), e.child } function _p(t) { var e = t.stateNode; e.pendingContext ? Iu(t, e.pendingContext, e.pendingContext !== e.context) : e.context && Iu(t, e.context, !1), fa(t, e.containerInfo) } function Bu(t, e, n, o, r) { return io(), sa(r), e.flags |= 256, De(t, e, n, o), e.child } var gl = { dehydrated: null, treeContext: null, retryLane: 0 }; function yl(t) { return { baseLanes: t, cachePool: null, transitions: null } } function Ep(t, e, n) { var o = e.pendingProps, r = le.current, i = !1, s = (e.flags & 128) !== 0, u; if ((u = s) || (u = t !== null && t.memoizedState === null ? !1 : (r & 2) !== 0), u ? (i = !0, e.flags &= -129) : (t === null || t.memoizedState !== null) && (r |= 1), ee(le, r & 1), t === null) return ul(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (s = o.children, t = o.fallback, i ? (o = e.mode, i = e.child, s = { mode: "hidden", children: s }, !(o & 1) && i !== null ? (i.childLanes = 0, i.pendingProps = s) : i = Wi(s, o, 0, null), t = vn(t, o, n, null), i.return = e, t.return = e, i.sibling = t, e.child = i, e.child.memoizedState = yl(n), e.memoizedState = gl, t) : wa(e, s)); if (r = t.memoizedState, r !== null && (u = r.dehydrated, u !== null)) return Gg(t, e, s, o, u, r, n); if (i) { i = o.fallback, s = e.mode, r = t.child, u = r.sibling; var c = { mode: "hidden", children: o.children }; return !(s & 1) && e.child !== r ? (o = e.child, o.childLanes = 0, o.pendingProps = c, e.deletions = null) : (o = rn(r, c), o.subtreeFlags = r.subtreeFlags & 14680064), u !== null ? i = rn(u, i) : (i = vn(i, s, n, null), i.flags |= 2), i.return = e, o.return = e, o.sibling = i, e.child = o, o = i, i = e.child, s = t.child.memoizedState, s = s === null ? yl(n) : { baseLanes: s.baseLanes | n, cachePool: null, transitions: s.transitions }, i.memoizedState = s, i.childLanes = t.childLanes & ~n, e.memoizedState = gl, o } return i = t.child, t = i.sibling, o = rn(i, { mode: "visible", children: o.children }), !(e.mode & 1) && (o.lanes = n), o.return = e, o.sibling = null, t !== null && (n = e.deletions, n === null ? (e.deletions = [t], e.flags |= 16) : n.push(t)), e.child = o, e.memoizedState = null, o } function wa(t, e) { return e = Wi({ mode: "visible", children: e }, t.mode, 0, null), e.return = t, t.child = e } function Fr(t, e, n, o) { return o !== null && sa(o), so(e, t.child, null, n), t = wa(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t } function Gg(t, e, n, o, r, i, s) { if (n) return e.flags & 256 ? (e.flags &= -257, o = Rs(Error(R(422))), Fr(t, e, s, o)) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (i = o.fallback, r = e.mode, o = Wi({ mode: "visible", children: o.children }, r, 0, null), i = vn(i, r, s, null), i.flags |= 2, o.return = e, i.return = e, o.sibling = i, e.child = o, e.mode & 1 && so(e, t.child, null, s), e.child.memoizedState = yl(s), e.memoizedState = gl, i); if (!(e.mode & 1)) return Fr(t, e, s, null); if (r.data === "$!") { if (o = r.nextSibling && r.nextSibling.dataset, o) var u = o.dgst; return o = u, i = Error(R(419)), o = Rs(i, o, void 0), Fr(t, e, s, o) } if (u = (s & t.childLanes) !== 0, Ve || u) { if (o = we, o !== null) { switch (s & -s) { case 4: r = 2; break; case 16: r = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: r = 32; break; case 536870912: r = 268435456; break; default: r = 0 }r = r & (o.suspendedLanes | s) ? 0 : r, r !== 0 && r !== i.retryLane && (i.retryLane = r, Dt(t, r), dt(o, t, r, -1)) } return ka(), o = Rs(Error(R(421))), Fr(t, e, s, o) } return r.data === "$?" ? (e.flags |= 128, e.child = t.child, e = Zg.bind(null, t), r._reactRetry = e, null) : (t = i.treeContext, We = en(r.nextSibling), Ye = e, ie = !0, ut = null, t !== null && (je[et++] = Nt, je[et++] = At, je[et++] = wn, Nt = t.id, At = t.overflow, wn = e), e = wa(e, o.children), e.flags |= 4096, e) } function Ju(t, e, n) { t.lanes |= e; var o = t.alternate; o !== null && (o.lanes |= e), cl(t.return, e, n) } function Ps(t, e, n, o, r) { var i = t.memoizedState; i === null ? t.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: o, tail: n, tailMode: r } : (i.isBackwards = e, i.rendering = null, i.renderingStartTime = 0, i.last = o, i.tail = n, i.tailMode = r) } function kp(t, e, n) { var o = e.pendingProps, r = o.revealOrder, i = o.tail; if (De(t, e, o.children, n), o = le.current, o & 2) o = o & 1 | 2, e.flags |= 128; else { if (t !== null && t.flags & 128) e: for (t = e.child; t !== null;) { if (t.tag === 13) t.memoizedState !== null && Ju(t, n, e); else if (t.tag === 19) Ju(t, n, e); else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break e; for (; t.sibling === null;) { if (t.return === null || t.return === e) break e; t = t.return } t.sibling.return = t.return, t = t.sibling } o &= 1 } if (ee(le, o), !(e.mode & 1)) e.memoizedState = null; else switch (r) { case "forwards": for (n = e.child, r = null; n !== null;)t = n.alternate, t !== null && xi(t) === null && (r = n), n = n.sibling; n = r, n === null ? (r = e.child, e.child = null) : (r = n.sibling, n.sibling = null), Ps(e, !1, r, n, i); break; case "backwards": for (n = null, r = e.child, e.child = null; r !== null;) { if (t = r.alternate, t !== null && xi(t) === null) { e.child = r; break } t = r.sibling, r.sibling = n, n = r, r = t } Ps(e, !0, n, null, i); break; case "together": Ps(e, !1, null, null, void 0); break; default: e.memoizedState = null }return e.child } function Qr(t, e) { !(e.mode & 1) && t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2) } function Lt(t, e, n) { if (t !== null && (e.dependencies = t.dependencies), Sn |= e.lanes, !(n & e.childLanes)) return null; if (t !== null && e.child !== t.child) throw Error(R(153)); if (e.child !== null) { for (t = e.child, n = rn(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null;)t = t.sibling, n = n.sibling = rn(t, t.pendingProps), n.return = e; n.sibling = null } return e.child } function $g(t, e, n) { switch (e.tag) { case 3: _p(e), io(); break; case 5: Zf(e); break; case 1: $e(e.type) && pi(e); break; case 4: fa(e, e.stateNode.containerInfo); break; case 10: var o = e.type._context, r = e.memoizedProps.value; ee(gi, o._currentValue), o._currentValue = r; break; case 13: if (o = e.memoizedState, o !== null) return o.dehydrated !== null ? (ee(le, le.current & 1), e.flags |= 128, null) : n & e.child.childLanes ? Ep(t, e, n) : (ee(le, le.current & 1), t = Lt(t, e, n), t !== null ? t.sibling : null); ee(le, le.current & 1); break; case 19: if (o = (n & e.childLanes) !== 0, t.flags & 128) { if (o) return kp(t, e, n); e.flags |= 128 } if (r = e.memoizedState, r !== null && (r.rendering = null, r.tail = null, r.lastEffect = null), ee(le, le.current), o) break; return null; case 22: case 23: return e.lanes = 0, Sp(t, e, n) }return Lt(t, e, n) } var Ip, vl, Np, Ap; Ip = function (t, e) { for (var n = e.child; n !== null;) { if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; vl = function () { }; Np = function (t, e, n, o) { var r = t.memoizedProps; if (r !== o) { t = e.stateNode, gn(_t.current); var i = null; switch (n) { case "input": r = $s(t, r), o = $s(t, o), i = []; break; case "select": r = ue({}, r, { value: void 0 }), o = ue({}, o, { value: void 0 }), i = []; break; case "textarea": r = zs(t, r), o = zs(t, o), i = []; break; default: typeof r.onClick != "function" && typeof o.onClick == "function" && (t.onclick = di) }Js(n, o); var s; n = null; for (d in r) if (!o.hasOwnProperty(d) && r.hasOwnProperty(d) && r[d] != null) if (d === "style") { var u = r[d]; for (s in u) u.hasOwnProperty(s) && (n || (n = {}), n[s] = "") } else d !== "dangerouslySetInnerHTML" && d !== "children" && d !== "suppressContentEditableWarning" && d !== "suppressHydrationWarning" && d !== "autoFocus" && (Wo.hasOwnProperty(d) ? i || (i = []) : (i = i || []).push(d, null)); for (d in o) { var c = o[d]; if (u = r != null ? r[d] : void 0, o.hasOwnProperty(d) && c !== u && (c != null || u != null)) if (d === "style") if (u) { for (s in u) !u.hasOwnProperty(s) || c && c.hasOwnProperty(s) || (n || (n = {}), n[s] = ""); for (s in c) c.hasOwnProperty(s) && u[s] !== c[s] && (n || (n = {}), n[s] = c[s]) } else n || (i || (i = []), i.push(d, n)), n = c; else d === "dangerouslySetInnerHTML" ? (c = c ? c.__html : void 0, u = u ? u.__html : void 0, c != null && u !== c && (i = i || []).push(d, c)) : d === "children" ? typeof c != "string" && typeof c != "number" || (i = i || []).push(d, "" + c) : d !== "suppressContentEditableWarning" && d !== "suppressHydrationWarning" && (Wo.hasOwnProperty(d) ? (c != null && d === "onScroll" && ne("scroll", t), i || u === c || (i = [])) : (i = i || []).push(d, c)) } n && (i = i || []).push("style", n); var d = i; (e.updateQueue = d) && (e.flags |= 4) } }; Ap = function (t, e, n, o) { n !== o && (e.flags |= 4) }; function ko(t, e) { if (!ie) switch (t.tailMode) { case "hidden": e = t.tail; for (var n = null; e !== null;)e.alternate !== null && (n = e), e = e.sibling; n === null ? t.tail = null : n.sibling = null; break; case "collapsed": n = t.tail; for (var o = null; n !== null;)n.alternate !== null && (o = n), n = n.sibling; o === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : o.sibling = null } } function Ne(t) { var e = t.alternate !== null && t.alternate.child === t.child, n = 0, o = 0; if (e) for (var r = t.child; r !== null;)n |= r.lanes | r.childLanes, o |= r.subtreeFlags & 14680064, o |= r.flags & 14680064, r.return = t, r = r.sibling; else for (r = t.child; r !== null;)n |= r.lanes | r.childLanes, o |= r.subtreeFlags, o |= r.flags, r.return = t, r = r.sibling; return t.subtreeFlags |= o, t.childLanes = n, e } function qg(t, e, n) { var o = e.pendingProps; switch (ia(e), e.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Ne(e), null; case 1: return $e(e.type) && fi(), Ne(e), null; case 3: return o = e.stateNode, lo(), re(Ge), re(Pe), ha(), o.pendingContext && (o.context = o.pendingContext, o.pendingContext = null), (t === null || t.child === null) && (Lr(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, ut !== null && (kl(ut), ut = null))), vl(t, e), Ne(e), null; case 5: pa(e); var r = gn(rr.current); if (n = e.type, t !== null && e.stateNode != null) Np(t, e, n, o, r), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152); else { if (!o) { if (e.stateNode === null) throw Error(R(166)); return Ne(e), null } if (t = gn(_t.current), Lr(e)) { o = e.stateNode, n = e.type; var i = e.memoizedProps; switch (o[wt] = e, o[nr] = i, t = (e.mode & 1) !== 0, n) { case "dialog": ne("cancel", o), ne("close", o); break; case "iframe": case "object": case "embed": ne("load", o); break; case "video": case "audio": for (r = 0; r < Do.length; r++)ne(Do[r], o); break; case "source": ne("error", o); break; case "img": case "image": case "link": ne("error", o), ne("load", o); break; case "details": ne("toggle", o); break; case "input": eu(o, i), ne("invalid", o); break; case "select": o._wrapperState = { wasMultiple: !!i.multiple }, ne("invalid", o); break; case "textarea": nu(o, i), ne("invalid", o) }Js(n, i), r = null; for (var s in i) if (i.hasOwnProperty(s)) { var u = i[s]; s === "children" ? typeof u == "string" ? o.textContent !== u && (i.suppressHydrationWarning !== !0 && Dr(o.textContent, u, t), r = ["children", u]) : typeof u == "number" && o.textContent !== "" + u && (i.suppressHydrationWarning !== !0 && Dr(o.textContent, u, t), r = ["children", "" + u]) : Wo.hasOwnProperty(s) && u != null && s === "onScroll" && ne("scroll", o) } switch (n) { case "input": Er(o), tu(o, i, !0); break; case "textarea": Er(o), ou(o); break; case "select": case "option": break; default: typeof i.onClick == "function" && (o.onclick = di) }o = r, e.updateQueue = o, o !== null && (e.flags |= 4) } else { s = r.nodeType === 9 ? r : r.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = nf(n)), t === "http://www.w3.org/1999/xhtml" ? n === "script" ? (t = s.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof o.is == "string" ? t = s.createElement(n, { is: o.is }) : (t = s.createElement(n), n === "select" && (s = t, o.multiple ? s.multiple = !0 : o.size && (s.size = o.size))) : t = s.createElementNS(t, n), t[wt] = e, t[nr] = o, Ip(t, e, !1, !1), e.stateNode = t; e: { switch (s = Ws(n, o), n) { case "dialog": ne("cancel", t), ne("close", t), r = o; break; case "iframe": case "object": case "embed": ne("load", t), r = o; break; case "video": case "audio": for (r = 0; r < Do.length; r++)ne(Do[r], t); r = o; break; case "source": ne("error", t), r = o; break; case "img": case "image": case "link": ne("error", t), ne("load", t), r = o; break; case "details": ne("toggle", t), r = o; break; case "input": eu(t, o), r = $s(t, o), ne("invalid", t); break; case "option": r = o; break; case "select": t._wrapperState = { wasMultiple: !!o.multiple }, r = ue({}, o, { value: void 0 }), ne("invalid", t); break; case "textarea": nu(t, o), r = zs(t, o), ne("invalid", t); break; default: r = o }Js(n, r), u = r; for (i in u) if (u.hasOwnProperty(i)) { var c = u[i]; i === "style" ? sf(t, c) : i === "dangerouslySetInnerHTML" ? (c = c ? c.__html : void 0, c != null && of(t, c)) : i === "children" ? typeof c == "string" ? (n !== "textarea" || c !== "") && Yo(t, c) : typeof c == "number" && Yo(t, "" + c) : i !== "suppressContentEditableWarning" && i !== "suppressHydrationWarning" && i !== "autoFocus" && (Wo.hasOwnProperty(i) ? c != null && i === "onScroll" && ne("scroll", t) : c != null && Bl(t, i, c, s)) } switch (n) { case "input": Er(t), tu(t, o, !1); break; case "textarea": Er(t), ou(t); break; case "option": o.value != null && t.setAttribute("value", "" + sn(o.value)); break; case "select": t.multiple = !!o.multiple, i = o.value, i != null ? Kn(t, !!o.multiple, i, !1) : o.defaultValue != null && Kn(t, !!o.multiple, o.defaultValue, !0); break; default: typeof r.onClick == "function" && (t.onclick = di) }switch (n) { case "button": case "input": case "select": case "textarea": o = !!o.autoFocus; break e; case "img": o = !0; break e; default: o = !1 } } o && (e.flags |= 4) } e.ref !== null && (e.flags |= 512, e.flags |= 2097152) } return Ne(e), null; case 6: if (t && e.stateNode != null) Ap(t, e, t.memoizedProps, o); else { if (typeof o != "string" && e.stateNode === null) throw Error(R(166)); if (n = gn(rr.current), gn(_t.current), Lr(e)) { if (o = e.stateNode, n = e.memoizedProps, o[wt] = e, (i = o.nodeValue !== n) && (t = Ye, t !== null)) switch (t.tag) { case 3: Dr(o.nodeValue, n, (t.mode & 1) !== 0); break; case 5: t.memoizedProps.suppressHydrationWarning !== !0 && Dr(o.nodeValue, n, (t.mode & 1) !== 0) }i && (e.flags |= 4) } else o = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(o), o[wt] = e, e.stateNode = o } return Ne(e), null; case 13: if (re(le), o = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) { if (ie && We !== null && e.mode & 1 && !(e.flags & 128)) Yf(), io(), e.flags |= 98560, i = !1; else if (i = Lr(e), o !== null && o.dehydrated !== null) { if (t === null) { if (!i) throw Error(R(318)); if (i = e.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(R(317)); i[wt] = e } else io(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4; Ne(e), i = !1 } else ut !== null && (kl(ut), ut = null), i = !0; if (!i) return e.flags & 65536 ? e : null } return e.flags & 128 ? (e.lanes = n, e) : (o = o !== null, o !== (t !== null && t.memoizedState !== null) && o && (e.child.flags |= 8192, e.mode & 1 && (t === null || le.current & 1 ? ye === 0 && (ye = 3) : ka())), e.updateQueue !== null && (e.flags |= 4), Ne(e), null); case 4: return lo(), vl(t, e), t === null && er(e.stateNode.containerInfo), Ne(e), null; case 10: return ua(e.type._context), Ne(e), null; case 17: return $e(e.type) && fi(), Ne(e), null; case 19: if (re(le), i = e.memoizedState, i === null) return Ne(e), null; if (o = (e.flags & 128) !== 0, s = i.rendering, s === null) if (o) ko(i, !1); else { if (ye !== 0 || t !== null && t.flags & 128) for (t = e.child; t !== null;) { if (s = xi(t), s !== null) { for (e.flags |= 128, ko(i, !1), o = s.updateQueue, o !== null && (e.updateQueue = o, e.flags |= 4), e.subtreeFlags = 0, o = n, n = e.child; n !== null;)i = n, t = o, i.flags &= 14680066, s = i.alternate, s === null ? (i.childLanes = 0, i.lanes = t, i.child = null, i.subtreeFlags = 0, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null) : (i.childLanes = s.childLanes, i.lanes = s.lanes, i.child = s.child, i.subtreeFlags = 0, i.deletions = null, i.memoizedProps = s.memoizedProps, i.memoizedState = s.memoizedState, i.updateQueue = s.updateQueue, i.type = s.type, t = s.dependencies, i.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }), n = n.sibling; return ee(le, le.current & 1 | 2), e.child } t = t.sibling } i.tail !== null && pe() > uo && (e.flags |= 128, o = !0, ko(i, !1), e.lanes = 4194304) } else { if (!o) if (t = xi(s), t !== null) { if (e.flags |= 128, o = !0, n = t.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), ko(i, !0), i.tail === null && i.tailMode === "hidden" && !s.alternate && !ie) return Ne(e), null } else 2 * pe() - i.renderingStartTime > uo && n !== 1073741824 && (e.flags |= 128, o = !0, ko(i, !1), e.lanes = 4194304); i.isBackwards ? (s.sibling = e.child, e.child = s) : (n = i.last, n !== null ? n.sibling = s : e.child = s, i.last = s) } return i.tail !== null ? (e = i.tail, i.rendering = e, i.tail = e.sibling, i.renderingStartTime = pe(), e.sibling = null, n = le.current, ee(le, o ? n & 1 | 2 : n & 1), e) : (Ne(e), null); case 22: case 23: return Ea(), o = e.memoizedState !== null, t !== null && t.memoizedState !== null !== o && (e.flags |= 8192), o && e.mode & 1 ? Be & 1073741824 && (Ne(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : Ne(e), null; case 24: return null; case 25: return null }throw Error(R(156, e.tag)) } function Hg(t, e) { switch (ia(e), e.tag) { case 1: return $e(e.type) && fi(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 3: return lo(), re(Ge), re(Pe), ha(), t = e.flags, t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128, e) : null; case 5: return pa(e), null; case 13: if (re(le), t = e.memoizedState, t !== null && t.dehydrated !== null) { if (e.alternate === null) throw Error(R(340)); io() } return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 19: return re(le), null; case 4: return lo(), null; case 10: return ua(e.type._context), null; case 22: case 23: return Ea(), null; case 24: return null; default: return null } } var br = !1, Ae = !1, zg = typeof WeakSet == "function" ? WeakSet : Set, F = null; function Bn(t, e) { var n = t.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (o) { de(t, e, o) } else n.current = null } function xl(t, e, n) { try { n() } catch (o) { de(t, e, o) } } var Wu = !1; function Bg(t, e) { if (nl = ai, t = Lf(), oa(t)) { if ("selectionStart" in t) var n = { start: t.selectionStart, end: t.selectionEnd }; else e: { n = (n = t.ownerDocument) && n.defaultView || window; var o = n.getSelection && n.getSelection(); if (o && o.rangeCount !== 0) { n = o.anchorNode; var r = o.anchorOffset, i = o.focusNode; o = o.focusOffset; try { n.nodeType, i.nodeType } catch { n = null; break e } var s = 0, u = -1, c = -1, d = 0, f = 0, p = t, h = null; t: for (; ;) { for (var g; p !== n || r !== 0 && p.nodeType !== 3 || (u = s + r), p !== i || o !== 0 && p.nodeType !== 3 || (c = s + o), p.nodeType === 3 && (s += p.nodeValue.length), (g = p.firstChild) !== null;)h = p, p = g; for (; ;) { if (p === t) break t; if (h === n && ++d === r && (u = s), h === i && ++f === o && (c = s), (g = p.nextSibling) !== null) break; p = h, h = p.parentNode } p = g } n = u === -1 || c === -1 ? null : { start: u, end: c } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (ol = { focusedElem: t, selectionRange: n }, ai = !1, F = e; F !== null;)if (e = F, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null) t.return = e, F = t; else for (; F !== null;) { e = F; try { var S = e.alternate; if (e.flags & 1024) switch (e.tag) { case 0: case 11: case 15: break; case 1: if (S !== null) { var w = S.memoizedProps, I = S.memoizedState, x = e.stateNode, y = x.getSnapshotBeforeUpdate(e.elementType === e.type ? w : lt(e.type, w), I); x.__reactInternalSnapshotBeforeUpdate = y } break; case 3: var v = e.stateNode.containerInfo; v.nodeType === 1 ? v.textContent = "" : v.nodeType === 9 && v.documentElement && v.removeChild(v.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(R(163)) } } catch (T) { de(e, e.return, T) } if (t = e.sibling, t !== null) { t.return = e.return, F = t; break } F = e.return } return S = Wu, Wu = !1, S } function $o(t, e, n) { var o = e.updateQueue; if (o = o !== null ? o.lastEffect : null, o !== null) { var r = o = o.next; do { if ((r.tag & t) === t) { var i = r.destroy; r.destroy = void 0, i !== void 0 && xl(e, n, i) } r = r.next } while (r !== o) } } function Bi(t, e) { if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) { var n = e = e.next; do { if ((n.tag & t) === t) { var o = n.create; n.destroy = o() } n = n.next } while (n !== e) } } function wl(t) { var e = t.ref; if (e !== null) { var n = t.stateNode; switch (t.tag) { case 5: t = n; break; default: t = n }typeof e == "function" ? e(t) : e.current = t } } function Rp(t) { var e = t.alternate; e !== null && (t.alternate = null, Rp(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[wt], delete e[nr], delete e[sl], delete e[kg], delete e[Ig])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null } function Pp(t) { return t.tag === 5 || t.tag === 3 || t.tag === 4 } function Yu(t) { e: for (; ;) { for (; t.sibling === null;) { if (t.return === null || Pp(t.return)) return null; t = t.return } for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) { if (t.flags & 2 || t.child === null || t.tag === 4) continue e; t.child.return = t, t = t.child } if (!(t.flags & 2)) return t.stateNode } } function Cl(t, e, n) { var o = t.tag; if (o === 5 || o === 6) t = t.stateNode, e ? n.nodeType === 8 ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (n.nodeType === 8 ? (e = n.parentNode, e.insertBefore(t, n)) : (e = n, e.appendChild(t)), n = n._reactRootContainer, n != null || e.onclick !== null || (e.onclick = di)); else if (o !== 4 && (t = t.child, t !== null)) for (Cl(t, e, n), t = t.sibling; t !== null;)Cl(t, e, n), t = t.sibling } function Sl(t, e, n) { var o = t.tag; if (o === 5 || o === 6) t = t.stateNode, e ? n.insertBefore(t, e) : n.appendChild(t); else if (o !== 4 && (t = t.child, t !== null)) for (Sl(t, e, n), t = t.sibling; t !== null;)Sl(t, e, n), t = t.sibling } var Te = null, at = !1; function zt(t, e, n) { for (n = n.child; n !== null;)Mp(t, e, n), n = n.sibling } function Mp(t, e, n) { if (Tt && typeof Tt.onCommitFiberUnmount == "function") try { Tt.onCommitFiberUnmount(Fi, n) } catch { } switch (n.tag) { case 5: Ae || Bn(n, e); case 6: var o = Te, r = at; Te = null, zt(t, e, n), Te = o, at = r, Te !== null && (at ? (t = Te, n = n.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n)) : Te.removeChild(n.stateNode)); break; case 18: Te !== null && (at ? (t = Te, n = n.stateNode, t.nodeType === 8 ? _s(t.parentNode, n) : t.nodeType === 1 && _s(t, n), Xo(t)) : _s(Te, n.stateNode)); break; case 4: o = Te, r = at, Te = n.stateNode.containerInfo, at = !0, zt(t, e, n), Te = o, at = r; break; case 0: case 11: case 14: case 15: if (!Ae && (o = n.updateQueue, o !== null && (o = o.lastEffect, o !== null))) { r = o = o.next; do { var i = r, s = i.destroy; i = i.tag, s !== void 0 && (i & 2 || i & 4) && xl(n, e, s), r = r.next } while (r !== o) } zt(t, e, n); break; case 1: if (!Ae && (Bn(n, e), o = n.stateNode, typeof o.componentWillUnmount == "function")) try { o.props = n.memoizedProps, o.state = n.memoizedState, o.componentWillUnmount() } catch (u) { de(n, e, u) } zt(t, e, n); break; case 21: zt(t, e, n); break; case 22: n.mode & 1 ? (Ae = (o = Ae) || n.memoizedState !== null, zt(t, e, n), Ae = o) : zt(t, e, n); break; default: zt(t, e, n) } } function Ku(t) { var e = t.updateQueue; if (e !== null) { t.updateQueue = null; var n = t.stateNode; n === null && (n = t.stateNode = new zg), e.forEach(function (o) { var r = jg.bind(null, t, o); n.has(o) || (n.add(o), o.then(r, r)) }) } } function st(t, e) { var n = e.deletions; if (n !== null) for (var o = 0; o < n.length; o++) { var r = n[o]; try { var i = t, s = e, u = s; e: for (; u !== null;) { switch (u.tag) { case 5: Te = u.stateNode, at = !1; break e; case 3: Te = u.stateNode.containerInfo, at = !0; break e; case 4: Te = u.stateNode.containerInfo, at = !0; break e }u = u.return } if (Te === null) throw Error(R(160)); Mp(i, s, r), Te = null, at = !1; var c = r.alternate; c !== null && (c.return = null), r.return = null } catch (d) { de(r, e, d) } } if (e.subtreeFlags & 12854) for (e = e.child; e !== null;)Dp(e, t), e = e.sibling } function Dp(t, e) { var n = t.alternate, o = t.flags; switch (t.tag) { case 0: case 11: case 14: case 15: if (st(e, t), vt(t), o & 4) { try { $o(3, t, t.return), Bi(3, t) } catch (w) { de(t, t.return, w) } try { $o(5, t, t.return) } catch (w) { de(t, t.return, w) } } break; case 1: st(e, t), vt(t), o & 512 && n !== null && Bn(n, n.return); break; case 5: if (st(e, t), vt(t), o & 512 && n !== null && Bn(n, n.return), t.flags & 32) { var r = t.stateNode; try { Yo(r, "") } catch (w) { de(t, t.return, w) } } if (o & 4 && (r = t.stateNode, r != null)) { var i = t.memoizedProps, s = n !== null ? n.memoizedProps : i, u = t.type, c = t.updateQueue; if (t.updateQueue = null, c !== null) try { u === "input" && i.type === "radio" && i.name != null && ef(r, i), Ws(u, s); var d = Ws(u, i); for (s = 0; s < c.length; s += 2) { var f = c[s], p = c[s + 1]; f === "style" ? sf(r, p) : f === "dangerouslySetInnerHTML" ? of(r, p) : f === "children" ? Yo(r, p) : Bl(r, f, p, d) } switch (u) { case "input": qs(r, i); break; case "textarea": tf(r, i); break; case "select": var h = r._wrapperState.wasMultiple; r._wrapperState.wasMultiple = !!i.multiple; var g = i.value; g != null ? Kn(r, !!i.multiple, g, !1) : h !== !!i.multiple && (i.defaultValue != null ? Kn(r, !!i.multiple, i.defaultValue, !0) : Kn(r, !!i.multiple, i.multiple ? [] : "", !1)) }r[nr] = i } catch (w) { de(t, t.return, w) } } break; case 6: if (st(e, t), vt(t), o & 4) { if (t.stateNode === null) throw Error(R(162)); r = t.stateNode, i = t.memoizedProps; try { r.nodeValue = i } catch (w) { de(t, t.return, w) } } break; case 3: if (st(e, t), vt(t), o & 4 && n !== null && n.memoizedState.isDehydrated) try { Xo(e.containerInfo) } catch (w) { de(t, t.return, w) } break; case 4: st(e, t), vt(t); break; case 13: st(e, t), vt(t), r = t.child, r.flags & 8192 && (i = r.memoizedState !== null, r.stateNode.isHidden = i, !i || r.alternate !== null && r.alternate.memoizedState !== null || (Ta = pe())), o & 4 && Ku(t); break; case 22: if (f = n !== null && n.memoizedState !== null, t.mode & 1 ? (Ae = (d = Ae) || f, st(e, t), Ae = d) : st(e, t), vt(t), o & 8192) { if (d = t.memoizedState !== null, (t.stateNode.isHidden = d) && !f && t.mode & 1) for (F = t, f = t.child; f !== null;) { for (p = F = f; F !== null;) { switch (h = F, g = h.child, h.tag) { case 0: case 11: case 14: case 15: $o(4, h, h.return); break; case 1: Bn(h, h.return); var S = h.stateNode; if (typeof S.componentWillUnmount == "function") { o = h, n = h.return; try { e = o, S.props = e.memoizedProps, S.state = e.memoizedState, S.componentWillUnmount() } catch (w) { de(o, n, w) } } break; case 5: Bn(h, h.return); break; case 22: if (h.memoizedState !== null) { Qu(p); continue } }g !== null ? (g.return = h, F = g) : Qu(p) } f = f.sibling } e: for (f = null, p = t; ;) { if (p.tag === 5) { if (f === null) { f = p; try { r = p.stateNode, d ? (i = r.style, typeof i.setProperty == "function" ? i.setProperty("display", "none", "important") : i.display = "none") : (u = p.stateNode, c = p.memoizedProps.style, s = c != null && c.hasOwnProperty("display") ? c.display : null, u.style.display = rf("display", s)) } catch (w) { de(t, t.return, w) } } } else if (p.tag === 6) { if (f === null) try { p.stateNode.nodeValue = d ? "" : p.memoizedProps } catch (w) { de(t, t.return, w) } } else if ((p.tag !== 22 && p.tag !== 23 || p.memoizedState === null || p === t) && p.child !== null) { p.child.return = p, p = p.child; continue } if (p === t) break e; for (; p.sibling === null;) { if (p.return === null || p.return === t) break e; f === p && (f = null), p = p.return } f === p && (f = null), p.sibling.return = p.return, p = p.sibling } } break; case 19: st(e, t), vt(t), o & 4 && Ku(t); break; case 21: break; default: st(e, t), vt(t) } } function vt(t) { var e = t.flags; if (e & 2) { try { e: { for (var n = t.return; n !== null;) { if (Pp(n)) { var o = n; break e } n = n.return } throw Error(R(160)) } switch (o.tag) { case 5: var r = o.stateNode; o.flags & 32 && (Yo(r, ""), o.flags &= -33); var i = Yu(t); Sl(t, i, r); break; case 3: case 4: var s = o.stateNode.containerInfo, u = Yu(t); Cl(t, u, s); break; default: throw Error(R(161)) } } catch (c) { de(t, t.return, c) } t.flags &= -3 } e & 4096 && (t.flags &= -4097) } function Jg(t, e, n) { F = t, Lp(t) } function Lp(t, e, n) { for (var o = (t.mode & 1) !== 0; F !== null;) { var r = F, i = r.child; if (r.tag === 22 && o) { var s = r.memoizedState !== null || br; if (!s) { var u = r.alternate, c = u !== null && u.memoizedState !== null || Ae; u = br; var d = Ae; if (br = s, (Ae = c) && !d) for (F = r; F !== null;)s = F, c = s.child, s.tag === 22 && s.memoizedState !== null ? Xu(r) : c !== null ? (c.return = s, F = c) : Xu(r); for (; i !== null;)F = i, Lp(i), i = i.sibling; F = r, br = u, Ae = d } Ou(t) } else r.subtreeFlags & 8772 && i !== null ? (i.return = r, F = i) : Ou(t) } } function Ou(t) { for (; F !== null;) { var e = F; if (e.flags & 8772) { var n = e.alternate; try { if (e.flags & 8772) switch (e.tag) { case 0: case 11: case 15: Ae || Bi(5, e); break; case 1: var o = e.stateNode; if (e.flags & 4 && !Ae) if (n === null) o.componentDidMount(); else { var r = e.elementType === e.type ? n.memoizedProps : lt(e.type, n.memoizedProps); o.componentDidUpdate(r, n.memoizedState, o.__reactInternalSnapshotBeforeUpdate) } var i = e.updateQueue; i !== null && Du(e, i, o); break; case 3: var s = e.updateQueue; if (s !== null) { if (n = null, e.child !== null) switch (e.child.tag) { case 5: n = e.child.stateNode; break; case 1: n = e.child.stateNode }Du(e, s, n) } break; case 5: var u = e.stateNode; if (n === null && e.flags & 4) { n = u; var c = e.memoizedProps; switch (e.type) { case "button": case "input": case "select": case "textarea": c.autoFocus && n.focus(); break; case "img": c.src && (n.src = c.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (e.memoizedState === null) { var d = e.alternate; if (d !== null) { var f = d.memoizedState; if (f !== null) { var p = f.dehydrated; p !== null && Xo(p) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(R(163)) }Ae || e.flags & 512 && wl(e) } catch (h) { de(e, e.return, h) } } if (e === t) { F = null; break } if (n = e.sibling, n !== null) { n.return = e.return, F = n; break } F = e.return } } function Qu(t) { for (; F !== null;) { var e = F; if (e === t) { F = null; break } var n = e.sibling; if (n !== null) { n.return = e.return, F = n; break } F = e.return } } function Xu(t) { for (; F !== null;) { var e = F; try { switch (e.tag) { case 0: case 11: case 15: var n = e.return; try { Bi(4, e) } catch (c) { de(e, n, c) } break; case 1: var o = e.stateNode; if (typeof o.componentDidMount == "function") { var r = e.return; try { o.componentDidMount() } catch (c) { de(e, r, c) } } var i = e.return; try { wl(e) } catch (c) { de(e, i, c) } break; case 5: var s = e.return; try { wl(e) } catch (c) { de(e, s, c) } } } catch (c) { de(e, e.return, c) } if (e === t) { F = null; break } var u = e.sibling; if (u !== null) { u.return = e.return, F = u; break } F = e.return } } var Wg = Math.ceil, Si = Ft.ReactCurrentDispatcher, Ca = Ft.ReactCurrentOwner, nt = Ft.ReactCurrentBatchConfig, J = 0, we = null, me = null, _e = 0, Be = 0, Jn = un(0), ye = 0, ar = null, Sn = 0, Ji = 0, Sa = 0, qo = null, be = null, Ta = 0, uo = 1 / 0, kt = null, Ti = !1, Tl = null, nn = null, Vr = !1, Ot = null, _i = 0, Ho = 0, _l = null, Xr = -1, Zr = 0; function Le() { return J & 6 ? pe() : Xr !== -1 ? Xr : Xr = pe() } function on(t) { return t.mode & 1 ? J & 2 && _e !== 0 ? _e & -_e : Ag.transition !== null ? (Zr === 0 && (Zr = vf()), Zr) : (t = K, t !== 0 || (t = window.event, t = t === void 0 ? 16 : Ef(t.type)), t) : 1 } function dt(t, e, n, o) { if (50 < Ho) throw Ho = 0, _l = null, Error(R(185)); dr(t, n, o), (!(J & 2) || t !== we) && (t === we && (!(J & 2) && (Ji |= n), ye === 4 && Yt(t, _e)), qe(t, o), n === 1 && J === 0 && !(e.mode & 1) && (uo = pe() + 500, qi && cn())) } function qe(t, e) { var n = t.callbackNode; Am(t, e); var o = li(t, t === we ? _e : 0); if (o === 0) n !== null && su(n), t.callbackNode = null, t.callbackPriority = 0; else if (e = o & -o, t.callbackPriority !== e) { if (n != null && su(n), e === 1) t.tag === 0 ? Ng(Zu.bind(null, t)) : Bf(Zu.bind(null, t)), _g(function () { !(J & 6) && cn() }), n = null; else { switch (xf(o)) { case 1: n = Ol; break; case 4: n = gf; break; case 16: n = si; break; case 536870912: n = yf; break; default: n = si }n = Hp(n, Up.bind(null, t)) } t.callbackPriority = e, t.callbackNode = n } } function Up(t, e) { if (Xr = -1, Zr = 0, J & 6) throw Error(R(327)); var n = t.callbackNode; if (jn() && t.callbackNode !== n) return null; var o = li(t, t === we ? _e : 0); if (o === 0) return null; if (o & 30 || o & t.expiredLanes || e) e = Ei(t, o); else { e = o; var r = J; J |= 2; var i = bp(); (we !== t || _e !== e) && (kt = null, uo = pe() + 500, yn(t, e)); do try { Og(); break } catch (u) { Fp(t, u) } while (1); aa(), Si.current = i, J = r, me !== null ? e = 0 : (we = null, _e = 0, e = ye) } if (e !== 0) { if (e === 2 && (r = Xs(t), r !== 0 && (o = r, e = El(t, r))), e === 1) throw n = ar, yn(t, 0), Yt(t, o), qe(t, pe()), n; if (e === 6) Yt(t, o); else { if (r = t.current.alternate, !(o & 30) && !Yg(r) && (e = Ei(t, o), e === 2 && (i = Xs(t), i !== 0 && (o = i, e = El(t, i))), e === 1)) throw n = ar, yn(t, 0), Yt(t, o), qe(t, pe()), n; switch (t.finishedWork = r, t.finishedLanes = o, e) { case 0: case 1: throw Error(R(345)); case 2: pn(t, be, kt); break; case 3: if (Yt(t, o), (o & 130023424) === o && (e = Ta + 500 - pe(), 10 < e)) { if (li(t, 0) !== 0) break; if (r = t.suspendedLanes, (r & o) !== o) { Le(), t.pingedLanes |= t.suspendedLanes & r; break } t.timeoutHandle = il(pn.bind(null, t, be, kt), e); break } pn(t, be, kt); break; case 4: if (Yt(t, o), (o & 4194240) === o) break; for (e = t.eventTimes, r = -1; 0 < o;) { var s = 31 - ct(o); i = 1 << s, s = e[s], s > r && (r = s), o &= ~i } if (o = r, o = pe() - o, o = (120 > o ? 120 : 480 > o ? 480 : 1080 > o ? 1080 : 1920 > o ? 1920 : 3e3 > o ? 3e3 : 4320 > o ? 4320 : 1960 * Wg(o / 1960)) - o, 10 < o) { t.timeoutHandle = il(pn.bind(null, t, be, kt), o); break } pn(t, be, kt); break; case 5: pn(t, be, kt); break; default: throw Error(R(329)) } } } return qe(t, pe()), t.callbackNode === n ? Up.bind(null, t) : null } function El(t, e) { var n = qo; return t.current.memoizedState.isDehydrated && (yn(t, e).flags |= 256), t = Ei(t, e), t !== 2 && (e = be, be = n, e !== null && kl(e)), t } function kl(t) { be === null ? be = t : be.push.apply(be, t) } function Yg(t) { for (var e = t; ;) { if (e.flags & 16384) { var n = e.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var o = 0; o < n.length; o++) { var r = n[o], i = r.getSnapshot; r = r.value; try { if (!ft(i(), r)) return !1 } catch { return !1 } } } if (n = e.child, e.subtreeFlags & 16384 && n !== null) n.return = e, e = n; else { if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return !0; e = e.return } e.sibling.return = e.return, e = e.sibling } } return !0 } function Yt(t, e) { for (e &= ~Sa, e &= ~Ji, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e;) { var n = 31 - ct(e), o = 1 << n; t[n] = -1, e &= ~o } } function Zu(t) { if (J & 6) throw Error(R(327)); jn(); var e = li(t, 0); if (!(e & 1)) return qe(t, pe()), null; var n = Ei(t, e); if (t.tag !== 0 && n === 2) { var o = Xs(t); o !== 0 && (e = o, n = El(t, o)) } if (n === 1) throw n = ar, yn(t, 0), Yt(t, e), qe(t, pe()), n; if (n === 6) throw Error(R(345)); return t.finishedWork = t.current.alternate, t.finishedLanes = e, pn(t, be, kt), qe(t, pe()), null } function _a(t, e) { var n = J; J |= 1; try { return t(e) } finally { J = n, J === 0 && (uo = pe() + 500, qi && cn()) } } function Tn(t) { Ot !== null && Ot.tag === 0 && !(J & 6) && jn(); var e = J; J |= 1; var n = nt.transition, o = K; try { if (nt.transition = null, K = 1, t) return t() } finally { K = o, nt.transition = n, J = e, !(J & 6) && cn() } } function Ea() { Be = Jn.current, re(Jn) } function yn(t, e) { t.finishedWork = null, t.finishedLanes = 0; var n = t.timeoutHandle; if (n !== -1 && (t.timeoutHandle = -1, Tg(n)), me !== null) for (n = me.return; n !== null;) { var o = n; switch (ia(o), o.tag) { case 1: o = o.type.childContextTypes, o != null && fi(); break; case 3: lo(), re(Ge), re(Pe), ha(); break; case 5: pa(o); break; case 4: lo(); break; case 13: re(le); break; case 19: re(le); break; case 10: ua(o.type._context); break; case 22: case 23: Ea() }n = n.return } if (we = t, me = t = rn(t.current, null), _e = Be = e, ye = 0, ar = null, Sa = Ji = Sn = 0, be = qo = null, mn !== null) { for (e = 0; e < mn.length; e++)if (n = mn[e], o = n.interleaved, o !== null) { n.interleaved = null; var r = o.next, i = n.pending; if (i !== null) { var s = i.next; i.next = r, o.next = s } n.pending = o } mn = null } return t } function Fp(t, e) { do { var n = me; try { if (aa(), Kr.current = Ci, wi) { for (var o = ae.memoizedState; o !== null;) { var r = o.queue; r !== null && (r.pending = null), o = o.next } wi = !1 } if (Cn = 0, xe = ge = ae = null, Go = !1, ir = 0, Ca.current = null, n === null || n.return === null) { ye = 1, ar = e, me = null; break } e: { var i = t, s = n.return, u = n, c = e; if (e = _e, u.flags |= 32768, c !== null && typeof c == "object" && typeof c.then == "function") { var d = c, f = u, p = f.tag; if (!(f.mode & 1) && (p === 0 || p === 11 || p === 15)) { var h = f.alternate; h ? (f.updateQueue = h.updateQueue, f.memoizedState = h.memoizedState, f.lanes = h.lanes) : (f.updateQueue = null, f.memoizedState = null) } var g = Gu(s); if (g !== null) { g.flags &= -257, $u(g, s, u, i, e), g.mode & 1 && Vu(i, d, e), e = g, c = d; var S = e.updateQueue; if (S === null) { var w = new Set; w.add(c), e.updateQueue = w } else S.add(c); break e } else { if (!(e & 1)) { Vu(i, d, e), ka(); break e } c = Error(R(426)) } } else if (ie && u.mode & 1) { var I = Gu(s); if (I !== null) { !(I.flags & 65536) && (I.flags |= 256), $u(I, s, u, i, e), sa(ao(c, u)); break e } } i = c = ao(c, u), ye !== 4 && (ye = 2), qo === null ? qo = [i] : qo.push(i), i = s; do { switch (i.tag) { case 3: i.flags |= 65536, e &= -e, i.lanes |= e; var x = xp(i, c, e); Mu(i, x); break e; case 1: u = c; var y = i.type, v = i.stateNode; if (!(i.flags & 128) && (typeof y.getDerivedStateFromError == "function" || v !== null && typeof v.componentDidCatch == "function" && (nn === null || !nn.has(v)))) { i.flags |= 65536, e &= -e, i.lanes |= e; var T = wp(i, u, e); Mu(i, T); break e } }i = i.return } while (i !== null) } Gp(n) } catch (E) { e = E, me === n && n !== null && (me = n = n.return); continue } break } while (1) } function bp() { var t = Si.current; return Si.current = Ci, t === null ? Ci : t } function ka() { (ye === 0 || ye === 3 || ye === 2) && (ye = 4), we === null || !(Sn & 268435455) && !(Ji & 268435455) || Yt(we, _e) } function Ei(t, e) { var n = J; J |= 2; var o = bp(); (we !== t || _e !== e) && (kt = null, yn(t, e)); do try { Kg(); break } catch (r) { Fp(t, r) } while (1); if (aa(), J = n, Si.current = o, me !== null) throw Error(R(261)); return we = null, _e = 0, ye } function Kg() { for (; me !== null;)Vp(me) } function Og() { for (; me !== null && !wm();)Vp(me) } function Vp(t) { var e = qp(t.alternate, t, Be); t.memoizedProps = t.pendingProps, e === null ? Gp(t) : me = e, Ca.current = null } function Gp(t) { var e = t; do { var n = e.alternate; if (t = e.return, e.flags & 32768) { if (n = Hg(n, e), n !== null) { n.flags &= 32767, me = n; return } if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null; else { ye = 6, me = null; return } } else if (n = qg(n, e, Be), n !== null) { me = n; return } if (e = e.sibling, e !== null) { me = e; return } me = e = t } while (e !== null); ye === 0 && (ye = 5) } function pn(t, e, n) { var o = K, r = nt.transition; try { nt.transition = null, K = 1, Qg(t, e, n, o) } finally { nt.transition = r, K = o } return null } function Qg(t, e, n, o) { do jn(); while (Ot !== null); if (J & 6) throw Error(R(327)); n = t.finishedWork; var r = t.finishedLanes; if (n === null) return null; if (t.finishedWork = null, t.finishedLanes = 0, n === t.current) throw Error(R(177)); t.callbackNode = null, t.callbackPriority = 0; var i = n.lanes | n.childLanes; if (Rm(t, i), t === we && (me = we = null, _e = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || Vr || (Vr = !0, Hp(si, function () { return jn(), null })), i = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || i) { i = nt.transition, nt.transition = null; var s = K; K = 1; var u = J; J |= 4, Ca.current = null, Bg(t, n), Dp(n, t), gg(ol), ai = !!nl, ol = nl = null, t.current = n, Jg(n), Cm(), J = u, K = s, nt.transition = i } else t.current = n; if (Vr && (Vr = !1, Ot = t, _i = r), i = t.pendingLanes, i === 0 && (nn = null), _m(n.stateNode), qe(t, pe()), e !== null) for (o = t.onRecoverableError, n = 0; n < e.length; n++)r = e[n], o(r.value, { componentStack: r.stack, digest: r.digest }); if (Ti) throw Ti = !1, t = Tl, Tl = null, t; return _i & 1 && t.tag !== 0 && jn(), i = t.pendingLanes, i & 1 ? t === _l ? Ho++ : (Ho = 0, _l = t) : Ho = 0, cn(), null } function jn() { if (Ot !== null) { var t = xf(_i), e = nt.transition, n = K; try { if (nt.transition = null, K = 16 > t ? 16 : t, Ot === null) var o = !1; else { if (t = Ot, Ot = null, _i = 0, J & 6) throw Error(R(331)); var r = J; for (J |= 4, F = t.current; F !== null;) { var i = F, s = i.child; if (F.flags & 16) { var u = i.deletions; if (u !== null) { for (var c = 0; c < u.length; c++) { var d = u[c]; for (F = d; F !== null;) { var f = F; switch (f.tag) { case 0: case 11: case 15: $o(8, f, i) }var p = f.child; if (p !== null) p.return = f, F = p; else for (; F !== null;) { f = F; var h = f.sibling, g = f.return; if (Rp(f), f === d) { F = null; break } if (h !== null) { h.return = g, F = h; break } F = g } } } var S = i.alternate; if (S !== null) { var w = S.child; if (w !== null) { S.child = null; do { var I = w.sibling; w.sibling = null, w = I } while (w !== null) } } F = i } } if (i.subtreeFlags & 2064 && s !== null) s.return = i, F = s; else e: for (; F !== null;) { if (i = F, i.flags & 2048) switch (i.tag) { case 0: case 11: case 15: $o(9, i, i.return) }var x = i.sibling; if (x !== null) { x.return = i.return, F = x; break e } F = i.return } } var y = t.current; for (F = y; F !== null;) { s = F; var v = s.child; if (s.subtreeFlags & 2064 && v !== null) v.return = s, F = v; else e: for (s = y; F !== null;) { if (u = F, u.flags & 2048) try { switch (u.tag) { case 0: case 11: case 15: Bi(9, u) } } catch (E) { de(u, u.return, E) } if (u === s) { F = null; break e } var T = u.sibling; if (T !== null) { T.return = u.return, F = T; break e } F = u.return } } if (J = r, cn(), Tt && typeof Tt.onPostCommitFiberRoot == "function") try { Tt.onPostCommitFiberRoot(Fi, t) } catch { } o = !0 } return o } finally { K = n, nt.transition = e } } return !1 } function ju(t, e, n) { e = ao(n, e), e = xp(t, e, 1), t = tn(t, e, 1), e = Le(), t !== null && (dr(t, 1, e), qe(t, e)) } function de(t, e, n) { if (t.tag === 3) ju(t, t, n); else for (; e !== null;) { if (e.tag === 3) { ju(e, t, n); break } else if (e.tag === 1) { var o = e.stateNode; if (typeof e.type.getDerivedStateFromError == "function" || typeof o.componentDidCatch == "function" && (nn === null || !nn.has(o))) { t = ao(n, t), t = wp(e, t, 1), e = tn(e, t, 1), t = Le(), e !== null && (dr(e, 1, t), qe(e, t)); break } } e = e.return } } function Xg(t, e, n) { var o = t.pingCache; o !== null && o.delete(e), e = Le(), t.pingedLanes |= t.suspendedLanes & n, we === t && (_e & n) === n && (ye === 4 || ye === 3 && (_e & 130023424) === _e && 500 > pe() - Ta ? yn(t, 0) : Sa |= n), qe(t, e) } function $p(t, e) { e === 0 && (t.mode & 1 ? (e = Nr, Nr <<= 1, !(Nr & 130023424) && (Nr = 4194304)) : e = 1); var n = Le(); t = Dt(t, e), t !== null && (dr(t, e, n), qe(t, n)) } function Zg(t) { var e = t.memoizedState, n = 0; e !== null && (n = e.retryLane), $p(t, n) } function jg(t, e) { var n = 0; switch (t.tag) { case 13: var o = t.stateNode, r = t.memoizedState; r !== null && (n = r.retryLane); break; case 19: o = t.stateNode; break; default: throw Error(R(314)) }o !== null && o.delete(e), $p(t, n) } var qp; qp = function (t, e, n) { if (t !== null) if (t.memoizedProps !== e.pendingProps || Ge.current) Ve = !0; else { if (!(t.lanes & n) && !(e.flags & 128)) return Ve = !1, $g(t, e, n); Ve = !!(t.flags & 131072) } else Ve = !1, ie && e.flags & 1048576 && Jf(e, mi, e.index); switch (e.lanes = 0, e.tag) { case 2: var o = e.type; Qr(t, e), t = e.pendingProps; var r = ro(e, Pe.current); Zn(e, n), r = ga(null, e, o, t, r, n); var i = ya(); return e.flags |= 1, typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, $e(o) ? (i = !0, pi(e)) : i = !1, e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null, da(e), r.updater = zi, e.stateNode = r, r._reactInternals = e, fl(e, o, t, n), e = ml(null, e, o, !0, i, n)) : (e.tag = 0, ie && i && ra(e), De(null, e, r, n), e = e.child), e; case 16: o = e.elementType; e: { switch (Qr(t, e), t = e.pendingProps, r = o._init, o = r(o._payload), e.type = o, r = e.tag = ty(o), t = lt(o, t), r) { case 0: e = hl(null, e, o, t, n); break e; case 1: e = zu(null, e, o, t, n); break e; case 11: e = qu(null, e, o, t, n); break e; case 14: e = Hu(null, e, o, lt(o.type, t), n); break e }throw Error(R(306, o, "")) } return e; case 0: return o = e.type, r = e.pendingProps, r = e.elementType === o ? r : lt(o, r), hl(t, e, o, r, n); case 1: return o = e.type, r = e.pendingProps, r = e.elementType === o ? r : lt(o, r), zu(t, e, o, r, n); case 3: e: { if (_p(e), t === null) throw Error(R(387)); o = e.pendingProps, i = e.memoizedState, r = i.element, Xf(t, e), vi(e, o, null, n); var s = e.memoizedState; if (o = s.element, i.isDehydrated) if (i = { element: o, isDehydrated: !1, cache: s.cache, pendingSuspenseBoundaries: s.pendingSuspenseBoundaries, transitions: s.transitions }, e.updateQueue.baseState = i, e.memoizedState = i, e.flags & 256) { r = ao(Error(R(423)), e), e = Bu(t, e, o, n, r); break e } else if (o !== r) { r = ao(Error(R(424)), e), e = Bu(t, e, o, n, r); break e } else for (We = en(e.stateNode.containerInfo.firstChild), Ye = e, ie = !0, ut = null, n = Of(e, null, o, n), e.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (io(), o === r) { e = Lt(t, e, n); break e } De(t, e, o, n) } e = e.child } return e; case 5: return Zf(e), t === null && ul(e), o = e.type, r = e.pendingProps, i = t !== null ? t.memoizedProps : null, s = r.children, rl(o, r) ? s = null : i !== null && rl(o, i) && (e.flags |= 32), Tp(t, e), De(t, e, s, n), e.child; case 6: return t === null && ul(e), null; case 13: return Ep(t, e, n); case 4: return fa(e, e.stateNode.containerInfo), o = e.pendingProps, t === null ? e.child = so(e, null, o, n) : De(t, e, o, n), e.child; case 11: return o = e.type, r = e.pendingProps, r = e.elementType === o ? r : lt(o, r), qu(t, e, o, r, n); case 7: return De(t, e, e.pendingProps, n), e.child; case 8: return De(t, e, e.pendingProps.children, n), e.child; case 12: return De(t, e, e.pendingProps.children, n), e.child; case 10: e: { if (o = e.type._context, r = e.pendingProps, i = e.memoizedProps, s = r.value, ee(gi, o._currentValue), o._currentValue = s, i !== null) if (ft(i.value, s)) { if (i.children === r.children && !Ge.current) { e = Lt(t, e, n); break e } } else for (i = e.child, i !== null && (i.return = e); i !== null;) { var u = i.dependencies; if (u !== null) { s = i.child; for (var c = u.firstContext; c !== null;) { if (c.context === o) { if (i.tag === 1) { c = Rt(-1, n & -n), c.tag = 2; var d = i.updateQueue; if (d !== null) { d = d.shared; var f = d.pending; f === null ? c.next = c : (c.next = f.next, f.next = c), d.pending = c } } i.lanes |= n, c = i.alternate, c !== null && (c.lanes |= n), cl(i.return, n, e), u.lanes |= n; break } c = c.next } } else if (i.tag === 10) s = i.type === e.type ? null : i.child; else if (i.tag === 18) { if (s = i.return, s === null) throw Error(R(341)); s.lanes |= n, u = s.alternate, u !== null && (u.lanes |= n), cl(s, n, e), s = i.sibling } else s = i.child; if (s !== null) s.return = i; else for (s = i; s !== null;) { if (s === e) { s = null; break } if (i = s.sibling, i !== null) { i.return = s.return, s = i; break } s = s.return } i = s } De(t, e, r.children, n), e = e.child } return e; case 9: return r = e.type, o = e.pendingProps.children, Zn(e, n), r = rt(r), o = o(r), e.flags |= 1, De(t, e, o, n), e.child; case 14: return o = e.type, r = lt(o, e.pendingProps), r = lt(o.type, r), Hu(t, e, o, r, n); case 15: return Cp(t, e, e.type, e.pendingProps, n); case 17: return o = e.type, r = e.pendingProps, r = e.elementType === o ? r : lt(o, r), Qr(t, e), e.tag = 1, $e(o) ? (t = !0, pi(e)) : t = !1, Zn(e, n), vp(e, o, r), fl(e, o, r, n), ml(null, e, o, !0, t, n); case 19: return kp(t, e, n); case 22: return Sp(t, e, n) }throw Error(R(156, e.tag)) }; function Hp(t, e) { return mf(t, e) } function ey(t, e, n, o) { this.tag = t, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = o, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function tt(t, e, n, o) { return new ey(t, e, n, o) } function Ia(t) { return t = t.prototype, !(!t || !t.isReactComponent) } function ty(t) { if (typeof t == "function") return Ia(t) ? 1 : 0; if (t != null) { if (t = t.$$typeof, t === Wl) return 11; if (t === Yl) return 14 } return 2 } function rn(t, e) { var n = t.alternate; return n === null ? (n = tt(t.tag, e, t.key, t.mode), n.elementType = t.elementType, n.type = t.type, n.stateNode = t.stateNode, n.alternate = t, t.alternate = n) : (n.pendingProps = e, n.type = t.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = t.flags & 14680064, n.childLanes = t.childLanes, n.lanes = t.lanes, n.child = t.child, n.memoizedProps = t.memoizedProps, n.memoizedState = t.memoizedState, n.updateQueue = t.updateQueue, e = t.dependencies, n.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, n.sibling = t.sibling, n.index = t.index, n.ref = t.ref, n } function jr(t, e, n, o, r, i) { var s = 2; if (o = t, typeof t == "function") Ia(t) && (s = 1); else if (typeof t == "string") s = 5; else e: switch (t) { case Un: return vn(n.children, r, i, e); case Jl: s = 8, r |= 8; break; case Fs: return t = tt(12, n, e, r | 2), t.elementType = Fs, t.lanes = i, t; case bs: return t = tt(13, n, e, r), t.elementType = bs, t.lanes = i, t; case Vs: return t = tt(19, n, e, r), t.elementType = Vs, t.lanes = i, t; case Xd: return Wi(n, r, i, e); default: if (typeof t == "object" && t !== null) switch (t.$$typeof) { case Od: s = 10; break e; case Qd: s = 9; break e; case Wl: s = 11; break e; case Yl: s = 14; break e; case Bt: s = 16, o = null; break e }throw Error(R(130, t == null ? t : typeof t, "")) }return e = tt(s, n, e, r), e.elementType = t, e.type = o, e.lanes = i, e } function vn(t, e, n, o) { return t = tt(7, t, o, e), t.lanes = n, t } function Wi(t, e, n, o) { return t = tt(22, t, o, e), t.elementType = Xd, t.lanes = n, t.stateNode = { isHidden: !1 }, t } function Ms(t, e, n) { return t = tt(6, t, null, e), t.lanes = n, t } function Ds(t, e, n) { return e = tt(4, t.children !== null ? t.children : [], t.key, e), e.lanes = n, e.stateNode = { containerInfo: t.containerInfo, pendingChildren: null, implementation: t.implementation }, e } function ny(t, e, n, o, r) { this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = ps(0), this.expirationTimes = ps(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ps(0), this.identifierPrefix = o, this.onRecoverableError = r, this.mutableSourceEagerHydrationData = null } function Na(t, e, n, o, r, i, s, u, c) { return t = new ny(t, e, n, u, c), e === 1 ? (e = 1, i === !0 && (e |= 8)) : e = 0, i = tt(3, null, null, e), t.current = i, i.stateNode = t, i.memoizedState = { element: o, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, da(i), t } function oy(t, e, n) { var o = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Ln, key: o == null ? null : "" + o, children: t, containerInfo: e, implementation: n } } function zp(t) { if (!t) return ln; t = t._reactInternals; e: { if (kn(t) !== t || t.tag !== 1) throw Error(R(170)); var e = t; do { switch (e.tag) { case 3: e = e.stateNode.context; break e; case 1: if ($e(e.type)) { e = e.stateNode.__reactInternalMemoizedMergedChildContext; break e } }e = e.return } while (e !== null); throw Error(R(171)) } if (t.tag === 1) { var n = t.type; if ($e(n)) return zf(t, n, e) } return e } function Bp(t, e, n, o, r, i, s, u, c) { return t = Na(n, o, !0, t, r, i, s, u, c), t.context = zp(null), n = t.current, o = Le(), r = on(n), i = Rt(o, r), i.callback = e ?? null, tn(n, i, r), t.current.lanes = r, dr(t, r, o), qe(t, o), t } function Yi(t, e, n, o) { var r = e.current, i = Le(), s = on(r); return n = zp(n), e.context === null ? e.context = n : e.pendingContext = n, e = Rt(i, s), e.payload = { element: t }, o = o === void 0 ? null : o, o !== null && (e.callback = o), t = tn(r, e, s), t !== null && (dt(t, r, s, i), Yr(t, r, s)), s } function ki(t) { if (t = t.current, !t.child) return null; switch (t.child.tag) { case 5: return t.child.stateNode; default: return t.child.stateNode } } function ec(t, e) { if (t = t.memoizedState, t !== null && t.dehydrated !== null) { var n = t.retryLane; t.retryLane = n !== 0 && n < e ? n : e } } function Aa(t, e) { ec(t, e), (t = t.alternate) && ec(t, e) } function ry() { return null } var Jp = typeof reportError == "function" ? reportError : function (t) { console.error(t) }; function Ra(t) { this._internalRoot = t } Ki.prototype.render = Ra.prototype.render = function (t) { var e = this._internalRoot; if (e === null) throw Error(R(409)); Yi(t, e, null, null) }; Ki.prototype.unmount = Ra.prototype.unmount = function () { var t = this._internalRoot; if (t !== null) { this._internalRoot = null; var e = t.containerInfo; Tn(function () { Yi(null, t, null, null) }), e[Mt] = null } }; function Ki(t) { this._internalRoot = t } Ki.prototype.unstable_scheduleHydration = function (t) { if (t) { var e = Sf(); t = { blockedOn: null, target: t, priority: e }; for (var n = 0; n < Wt.length && e !== 0 && e < Wt[n].priority; n++); Wt.splice(n, 0, t), n === 0 && _f(t) } }; function Pa(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11) } function Oi(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable ")) } function tc() { } function iy(t, e, n, o, r) { if (r) { if (typeof o == "function") { var i = o; o = function () { var d = ki(s); i.call(d) } } var s = Bp(e, o, t, 0, null, !1, !1, "", tc); return t._reactRootContainer = s, t[Mt] = s.current, er(t.nodeType === 8 ? t.parentNode : t), Tn(), s } for (; r = t.lastChild;)t.removeChild(r); if (typeof o == "function") { var u = o; o = function () { var d = ki(c); u.call(d) } } var c = Na(t, 0, !1, null, null, !1, !1, "", tc); return t._reactRootContainer = c, t[Mt] = c.current, er(t.nodeType === 8 ? t.parentNode : t), Tn(function () { Yi(e, c, n, o) }), c } function Qi(t, e, n, o, r) { var i = n._reactRootContainer; if (i) { var s = i; if (typeof r == "function") { var u = r; r = function () { var c = ki(s); u.call(c) } } Yi(e, s, t, r) } else s = iy(n, e, t, r, o); return ki(s) } wf = function (t) { switch (t.tag) { case 3: var e = t.stateNode; if (e.current.memoizedState.isDehydrated) { var n = Mo(e.pendingLanes); n !== 0 && (Ql(e, n | 1), qe(e, pe()), !(J & 6) && (uo = pe() + 500, cn())) } break; case 13: Tn(function () { var o = Dt(t, 1); if (o !== null) { var r = Le(); dt(o, t, 1, r) } }), Aa(t, 1) } }; Xl = function (t) { if (t.tag === 13) { var e = Dt(t, 134217728); if (e !== null) { var n = Le(); dt(e, t, 134217728, n) } Aa(t, 134217728) } }; Cf = function (t) { if (t.tag === 13) { var e = on(t), n = Dt(t, e); if (n !== null) { var o = Le(); dt(n, t, e, o) } Aa(t, e) } }; Sf = function () { return K }; Tf = function (t, e) { var n = K; try { return K = t, e() } finally { K = n } }; Ks = function (t, e, n) { switch (e) { case "input": if (qs(t, n), e = n.name, n.type === "radio" && e != null) { for (n = t; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < n.length; e++) { var o = n[e]; if (o !== t && o.form === t.form) { var r = $i(o); if (!r) throw Error(R(90)); jd(o), qs(o, r) } } } break; case "textarea": tf(t, n); break; case "select": e = n.value, e != null && Kn(t, !!n.multiple, e, !1) } }; uf = _a; cf = Tn; var sy = { usingClientEntryPoint: !1, Events: [pr, Gn, $i, lf, af, _a] }, Io = { findFiberByHostInstance: hn, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, ly = { bundleType: Io.bundleType, version: Io.version, rendererPackageName: Io.rendererPackageName, rendererConfig: Io.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Ft.ReactCurrentDispatcher, findHostInstanceByFiber: function (t) { return t = pf(t), t === null ? null : t.stateNode }, findFiberByHostInstance: Io.findFiberByHostInstance || ry, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Gr = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Gr.isDisabled && Gr.supportsFiber) try { Fi = Gr.inject(ly), Tt = Gr } catch { } } Oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sy; Oe.createPortal = function (t, e) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Pa(e)) throw Error(R(200)); return oy(t, e, null, n) }; Oe.createRoot = function (t, e) { if (!Pa(t)) throw Error(R(299)); var n = !1, o = "", r = Jp; return e != null && (e.unstable_strictMode === !0 && (n = !0), e.identifierPrefix !== void 0 && (o = e.identifierPrefix), e.onRecoverableError !== void 0 && (r = e.onRecoverableError)), e = Na(t, 1, !1, null, null, n, !1, o, r), t[Mt] = e.current, er(t.nodeType === 8 ? t.parentNode : t), new Ra(e) }; Oe.findDOMNode = function (t) { if (t == null) return null; if (t.nodeType === 1) return t; var e = t._reactInternals; if (e === void 0) throw typeof t.render == "function" ? Error(R(188)) : (t = Object.keys(t).join(","), Error(R(268, t))); return t = pf(e), t = t === null ? null : t.stateNode, t }; Oe.flushSync = function (t) { return Tn(t) }; Oe.hydrate = function (t, e, n) { if (!Oi(e)) throw Error(R(200)); return Qi(null, t, e, !0, n) }; Oe.hydrateRoot = function (t, e, n) { if (!Pa(t)) throw Error(R(405)); var o = n != null && n.hydratedSources || null, r = !1, i = "", s = Jp; if (n != null && (n.unstable_strictMode === !0 && (r = !0), n.identifierPrefix !== void 0 && (i = n.identifierPrefix), n.onRecoverableError !== void 0 && (s = n.onRecoverableError)), e = Bp(e, null, t, 1, n ?? null, r, !1, i, s), t[Mt] = e.current, er(t), o) for (t = 0; t < o.length; t++)n = o[t], r = n._getVersion, r = r(n._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [n, r] : e.mutableSourceEagerHydrationData.push(n, r); return new Ki(e) }; Oe.render = function (t, e, n) { if (!Oi(e)) throw Error(R(200)); return Qi(null, t, e, !1, n) }; Oe.unmountComponentAtNode = function (t) { if (!Oi(t)) throw Error(R(40)); return t._reactRootContainer ? (Tn(function () { Qi(null, null, t, !1, function () { t._reactRootContainer = null, t[Mt] = null }) }), !0) : !1 }; Oe.unstable_batchedUpdates = _a; Oe.unstable_renderSubtreeIntoContainer = function (t, e, n, o) { if (!Oi(n)) throw Error(R(200)); if (t == null || t._reactInternals === void 0) throw Error(R(38)); return Qi(t, e, n, !1, o) }; Oe.version = "18.3.1-next-f1338f8080-20240426"; function Wp() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Wp) } catch (t) { console.error(t) } } Wp(), Jd.exports = Oe; var ay = Jd.exports, nc = ay; Ls.createRoot = nc.createRoot, Ls.hydrateRoot = nc.hydrateRoot; const oc = "1.5.1", uy = "https://sdis-authenticator.saikoudevelopment.workers.dev", ei = [{ id: "saikou", name: "Saikou Dark", background: "radial-gradient(circle at 50% 50%, #111 0%, #000 100%)", windowBg: "#0a0a0a", windowHeader: "#000000", windowBorder: "1px solid #333", taskbarBg: "rgba(10, 10, 10, 0.85)", taskbarStyle: "default", accentColor: "#3b82f6", font: "'Inter', sans-serif", iconStyle: "modern", iconShape: "squircle", windowControlPosition: "right", desktopAlignment: "middle-left" }, { id: "macos", name: "Cupertino", background: 'url("https://images.unsplash.com/photo-1618005182384-a83a8bd57fbe?q=80&w=2564&auto=format&fit=crop")', windowBg: "rgba(20, 20, 30, 0.65)", windowHeader: "rgba(20, 20, 30, 0.65)", windowBorder: "1px solid rgba(255, 255, 255, 0.05)", taskbarBg: "rgba(20, 20, 30, 0.4)", taskbarStyle: "dock", accentColor: "#0A84FF", font: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif", iconStyle: "glass", iconShape: "squircle", windowControlPosition: "left", desktopAlignment: "top-center" }, { id: "cyber", name: "Night City", background: "linear-gradient(45deg, #1a0b2e 0%, #2d1b4e 100%)", windowBg: "rgba(20, 10, 30, 0.9)", windowHeader: "#2d1b4e", windowBorder: "1px solid #ff00ff", taskbarBg: "rgba(20, 10, 30, 0.95)", taskbarStyle: "default", accentColor: "#00ffff", font: "'JetBrains Mono', monospace", iconStyle: "modern", iconShape: "squircle", windowControlPosition: "right", desktopAlignment: "middle-left" }, { id: "bellflower", name: "Bellflower", background: 'url("https://images.unsplash.com/photo-1629196914375-f7e48f477b6d?q=80&w=2546&auto=format&fit=crop")', windowBg: "rgba(20, 15, 30, 0.65)", windowHeader: "rgba(20, 15, 30, 0.8)", windowBorder: "1px solid rgba(236, 72, 153, 0.2)", taskbarBg: "rgba(15, 10, 20, 0.6)", taskbarStyle: "vertical", accentColor: "#d946ef", font: "'Montserrat', sans-serif", iconStyle: "glass", iconShape: "circle", windowControlPosition: "left", desktopAlignment: "top-right" }], cy = [{ name: "Bellflower", value: 'url("https://images.unsplash.com/photo-1629196914375-f7e48f477b6d?q=80&w=2546&auto=format&fit=crop")', preview: "https://images.unsplash.com/photo-1629196914375-f7e48f477b6d?q=80&w=200&auto=format&fit=crop" }, { name: "Void", value: "radial-gradient(circle at 50% 50%, #111 0%, #000 100%)", preview: "#111" }, { name: "Abstract", value: 'url("https://images.unsplash.com/photo-1618005182384-a83a8bd57fbe?q=80&w=2564&auto=format&fit=crop")', preview: "https://images.unsplash.com/photo-1618005182384-a83a8bd57fbe?q=80&w=200&auto=format&fit=crop" }, { name: "Dune", value: 'url("https://images.unsplash.com/photo-1478760329108-5c3ed9d495a0?q=80&w=1974&auto=format&fit=crop")', preview: "https://images.unsplash.com/photo-1478760329108-5c3ed9d495a0?q=80&w=200&auto=format&fit=crop" }, { name: "Neon", value: "linear-gradient(45deg, #1a0b2e 0%, #2d1b4e 100%)", preview: "linear-gradient(45deg, #1a0b2e 0%, #2d1b4e 100%)" }, { name: "Waves", value: 'url("https://images.unsplash.com/photo-1550684848-fac1c5b4e853?q=80&w=2070&auto=format&fit=crop")', preview: "https://images.unsplash.com/photo-1550684848-fac1c5b4e853?q=80&w=200&auto=format&fit=crop" }, { name: "Mountain", value: 'url("https://images.unsplash.com/photo-1464822759023-fed622ff2c3b?q=80&w=2070&auto=format&fit=crop")', preview: "https://images.unsplash.com/photo-1464822759023-fed622ff2c3b?q=80&w=200&auto=format&fit=crop" }, { name: "Ocean", value: 'url("https://images.unsplash.com/photo-1507525428034-b723cf961d3e?q=80&w=2073&auto=format&fit=crop")', preview: "https://images.unsplash.com/photo-1507525428034-b723cf961d3e?q=80&w=200&auto=format&fit=crop" }, { name: "Desert", value: 'url("https://images.unsplash.com/photo-1473580044384-7ba9967e16a0?q=80&w=2070&auto=format&fit=crop")', preview: "https://images.unsplash.com/photo-1473580044384-7ba9967e16a0?q=80&w=200&auto=format&fit=crop" }], dy = [{ name: "Inter (Modern)", value: "'Inter', sans-serif" }, { name: "Montserrat (Clean)", value: "'Montserrat', sans-serif" }, { name: "JetBrains (Code)", value: "'JetBrains Mono', monospace" }, { name: "System (Standard)", value: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif" }, { name: "Serif (Retro)", value: "Georgia, 'Times New Roman', Times, serif" }, { name: "Helvetica", value: "'Helvetica Neue', Helvetica, Arial, sans-serif" }, { name: "Arial", value: "Arial, sans-serif" }, { name: "Roboto", value: "'Roboto', sans-serif" }, { name: "Roboto Slab", value: "'Roboto Slab', serif" }, { name: "Calibri", value: "Calibri, 'Gill Sans', 'Gill Sans MT', sans-serif" }], fy = ["#3b82f6", "#0A84FF", "#ef4444", "#10b981", "#8b5cf6", "#f59e0b", "#ec4899", "#d946ef", "#ffffff"], Dn = [{ id: "settings", title: "Settings", icon: "settings", color: "from-gray-500 to-slate-600", restricted: !1, component: "settings", width: 800, height: 600 }, { id: "rings", title: "Ring Manager", icon: "link", color: "from-rose-500 to-red-500", restricted: !0, url: "sdis-rings.html", width: 1e3, height: 700 }, { id: "netvis", title: "Network Visualizer", icon: "lan", color: "from-blue-600 to-cyan-500", restricted: !1, url: "netvis.html", width: 1e3, height: 700 }, { id: "lookup", title: "Player Lookup", icon: "person_search", color: "from-purple-600 to-pink-500", restricted: !1, url: "lookup.html", width: 900, height: 800 }, { id: "dislookup", title: "DisLookup", icon: "fa-brands fa-discord", color: "from-indigo-500 to-purple-600", restricted: !1, url: "dislookup.html", width: 850, height: 700 }, { id: "panel", title: "User Panel", icon: "manage_accounts", color: "from-emerald-500 to-green-500", restricted: !0, url: "panel.html", width: 800, height: 600, iconStyle: { transform: "translateX(2px)" } }, { id: "sdis", title: "SDIS Admin", icon: "admin_panel_settings", color: "from-red-600 to-orange-600", restricted: !0, url: "sdis.html", width: 1100, height: 750 }, { id: "timestamp", title: "Time Gen", icon: "schedule", color: "from-yellow-500 to-orange-500", restricted: !1, url: "timestamp.html", width: 500, height: 600 }, { id: "scheduler", title: "Scheduler", icon: "calendar_month", color: "from-indigo-500 to-blue-500", restricted: !0, url: "scheduler.html", width: 800, height: 700 }, { id: "docusend", title: "File Sender", icon: "send", color: "from-gray-600 to-gray-800", restricted: !0, url: "docusend.html", width: 600, height: 500 }, { id: "decipher", title: "Decipher", icon: "lock_open", color: "from-slate-700 to-slate-900", restricted: !1, url: "decrypt.html", width: 1e3, height: 800 }, { id: "worldclock", title: "World Clock", icon: "public", color: "from-blue-500 to-cyan-400", restricted: !1, url: "clock.html", width: 800, height: 600 }]; function Ma() { return { async: !1, breaks: !1, extensions: null, gfm: !0, hooks: null, pedantic: !1, renderer: null, silent: !1, tokenizer: null, walkTokens: null } } let In = Ma(); function Yp(t) { In = t } const Kp = /[&<>"']/, py = new RegExp(Kp.source, "g"), Op = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, hy = new RegExp(Op.source, "g"), my = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, rc = t => my[t]; function Je(t, e) { if (e) { if (Kp.test(t)) return t.replace(py, rc) } else if (Op.test(t)) return t.replace(hy, rc); return t } const gy = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig; function yy(t) { return t.replace(gy, (e, n) => (n = n.toLowerCase(), n === "colon" ? ":" : n.charAt(0) === "#" ? n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1)) : "")) } const vy = /(^|[^\[])\^/g; function Q(t, e) { let n = typeof t == "string" ? t : t.source; e = e || ""; const o = { replace: (r, i) => { let s = typeof i == "string" ? i : i.source; return s = s.replace(vy, "$1"), n = n.replace(r, s), o }, getRegex: () => new RegExp(n, e) }; return o } function ic(t) { try { t = encodeURI(t).replace(/%25/g, "%") } catch { return null } return t } const zo = { exec: () => null }; function sc(t, e) { const n = t.replace(/\|/g, (i, s, u) => { let c = !1, d = s; for (; --d >= 0 && u[d] === "\\";)c = !c; return c ? "|" : " |" }), o = n.split(/ \|/); let r = 0; if (o[0].trim() || o.shift(), o.length > 0 && !o[o.length - 1].trim() && o.pop(), e) if (o.length > e) o.splice(e); else for (; o.length < e;)o.push(""); for (; r < o.length; r++)o[r] = o[r].trim().replace(/\\\|/g, "|"); return o } function $r(t, e, n) { const o = t.length; if (o === 0) return ""; let r = 0; for (; r < o;) { const i = t.charAt(o - r - 1); if (i === e && !n) r++; else if (i !== e && n) r++; else break } return t.slice(0, o - r) } function xy(t, e) { if (t.indexOf(e[1]) === -1) return -1; let n = 0; for (let o = 0; o < t.length; o++)if (t[o] === "\\") o++; else if (t[o] === e[0]) n++; else if (t[o] === e[1] && (n--, n < 0)) return o; return -1 } function lc(t, e, n, o) { const r = e.href, i = e.title ? Je(e.title) : null, s = t[1].replace(/\\([\[\]])/g, "$1"); if (t[0].charAt(0) !== "!") { o.state.inLink = !0; const u = { type: "link", raw: n, href: r, title: i, text: s, tokens: o.inlineTokens(s) }; return o.state.inLink = !1, u } return { type: "image", raw: n, href: r, title: i, text: Je(s) } } function wy(t, e) {
  const n = t.match(/^(\s+)(?:```)/); if (n === null) return e; const o = n[1]; return e.split(`
`).map(r => { const i = r.match(/^\s+/); if (i === null) return r; const [s] = i; return s.length >= o.length ? r.slice(o.length) : r }).join(`
`)
} class Ii {
  constructor(e) { te(this, "options"); te(this, "rules"); te(this, "lexer"); this.options = e || In } space(e) { const n = this.rules.block.newline.exec(e); if (n && n[0].length > 0) return { type: "space", raw: n[0] } } code(e) {
    const n = this.rules.block.code.exec(e); if (n) {
      const o = n[0].replace(/^ {1,4}/gm, ""); return {
        type: "code", raw: n[0], codeBlockStyle: "indented", text: this.options.pedantic ? o : $r(o, `
`)
      }
    }
  } fences(e) { const n = this.rules.block.fences.exec(e); if (n) { const o = n[0], r = wy(o, n[3] || ""); return { type: "code", raw: o, lang: n[2] ? n[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : n[2], text: r } } } heading(e) { const n = this.rules.block.heading.exec(e); if (n) { let o = n[2].trim(); if (/#$/.test(o)) { const r = $r(o, "#"); (this.options.pedantic || !r || / $/.test(r)) && (o = r.trim()) } return { type: "heading", raw: n[0], depth: n[1].length, text: o, tokens: this.lexer.inline(o) } } } hr(e) { const n = this.rules.block.hr.exec(e); if (n) return { type: "hr", raw: n[0] } } blockquote(e) {
    const n = this.rules.block.blockquote.exec(e); if (n) {
      let o = n[0].replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g, `
    $1`); o = $r(o.replace(/^ *>[ \t]?/gm, ""), `
`); const r = this.lexer.state.top; this.lexer.state.top = !0; const i = this.lexer.blockTokens(o); return this.lexer.state.top = r, { type: "blockquote", raw: n[0], tokens: i, text: o }
    }
  } list(e) {
    let n = this.rules.block.list.exec(e); if (n) {
      let o = n[1].trim(); const r = o.length > 1, i = { type: "list", raw: "", ordered: r, start: r ? +o.slice(0, -1) : "", loose: !1, items: [] }; o = r ? `\\d{1,9}\\${o.slice(-1)}` : `\\${o}`, this.options.pedantic && (o = r ? o : "[*+-]"); const s = new RegExp(`^( {0,3}${o})((?:[	 ][^\\n]*)?(?:\\n|$))`); let u = "", c = "", d = !1; for (; e;) {
        let f = !1; if (!(n = s.exec(e)) || this.rules.block.hr.test(e)) break; u = n[0], e = e.substring(u.length); let p = n[2].split(`
`, 1)[0].replace(/^\t+/, x => " ".repeat(3 * x.length)), h = e.split(`
`, 1)[0], g = 0; this.options.pedantic ? (g = 2, c = p.trimStart()) : (g = n[2].search(/[^ ]/), g = g > 4 ? 1 : g, c = p.slice(g), g += n[1].length); let S = !1; if (!p && /^ *$/.test(h) && (u += h + `
`, e = e.substring(h.length + 1), f = !0), !f) {
          const x = new RegExp(`^ {0,${Math.min(3, g - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), y = new RegExp(`^ {0,${Math.min(3, g - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), v = new RegExp(`^ {0,${Math.min(3, g - 1)}}(?:\`\`\`|~~~)`), T = new RegExp(`^ {0,${Math.min(3, g - 1)}}#`); for (; e;) {
            const E = e.split(`
`, 1)[0]; if (h = E, this.options.pedantic && (h = h.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), v.test(h) || T.test(h) || x.test(h) || y.test(e)) break; if (h.search(/[^ ]/) >= g || !h.trim()) c += `
`+ h.slice(g); else {
              if (S || p.search(/[^ ]/) >= 4 || v.test(p) || T.test(p) || y.test(p)) break; c += `
`+ h
            } !S && !h.trim() && (S = !0), u += E + `
`, e = e.substring(E.length + 1), p = h.slice(g)
          }
        } i.loose || (d ? i.loose = !0 : /\n *\n *$/.test(u) && (d = !0)); let w = null, I; this.options.gfm && (w = /^\[[ xX]\] /.exec(c), w && (I = w[0] !== "[ ] ", c = c.replace(/^\[[ xX]\] +/, ""))), i.items.push({ type: "list_item", raw: u, task: !!w, checked: I, loose: !1, text: c, tokens: [] }), i.raw += u
      } i.items[i.items.length - 1].raw = u.trimEnd(), i.items[i.items.length - 1].text = c.trimEnd(), i.raw = i.raw.trimEnd(); for (let f = 0; f < i.items.length; f++)if (this.lexer.state.top = !1, i.items[f].tokens = this.lexer.blockTokens(i.items[f].text, []), !i.loose) { const p = i.items[f].tokens.filter(g => g.type === "space"), h = p.length > 0 && p.some(g => /\n.*\n/.test(g.raw)); i.loose = h } if (i.loose) for (let f = 0; f < i.items.length; f++)i.items[f].loose = !0; return i
    }
  } html(e) { const n = this.rules.block.html.exec(e); if (n) return { type: "html", block: !0, raw: n[0], pre: n[1] === "pre" || n[1] === "script" || n[1] === "style", text: n[0] } } def(e) { const n = this.rules.block.def.exec(e); if (n) { const o = n[1].toLowerCase().replace(/\s+/g, " "), r = n[2] ? n[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = n[3] ? n[3].substring(1, n[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : n[3]; return { type: "def", tag: o, raw: n[0], href: r, title: i } } } table(e) {
    const n = this.rules.block.table.exec(e); if (!n || !/[:|]/.test(n[2])) return; const o = sc(n[1]), r = n[2].replace(/^\||\| *$/g, "").split("|"), i = n[3] && n[3].trim() ? n[3].replace(/\n[ \t]*$/, "").split(`
`) : [], s = { type: "table", raw: n[0], header: [], align: [], rows: [] }; if (o.length === r.length) { for (const u of r) /^ *-+: *$/.test(u) ? s.align.push("right") : /^ *:-+: *$/.test(u) ? s.align.push("center") : /^ *:-+ *$/.test(u) ? s.align.push("left") : s.align.push(null); for (const u of o) s.header.push({ text: u, tokens: this.lexer.inline(u) }); for (const u of i) s.rows.push(sc(u, s.header.length).map(c => ({ text: c, tokens: this.lexer.inline(c) }))); return s }
  } lheading(e) { const n = this.rules.block.lheading.exec(e); if (n) return { type: "heading", raw: n[0], depth: n[2].charAt(0) === "=" ? 1 : 2, text: n[1], tokens: this.lexer.inline(n[1]) } } paragraph(e) {
    const n = this.rules.block.paragraph.exec(e); if (n) {
      const o = n[1].charAt(n[1].length - 1) === `
`? n[1].slice(0, -1) : n[1]; return { type: "paragraph", raw: n[0], text: o, tokens: this.lexer.inline(o) }
    }
  } text(e) { const n = this.rules.block.text.exec(e); if (n) return { type: "text", raw: n[0], text: n[0], tokens: this.lexer.inline(n[0]) } } escape(e) { const n = this.rules.inline.escape.exec(e); if (n) return { type: "escape", raw: n[0], text: Je(n[1]) } } tag(e) { const n = this.rules.inline.tag.exec(e); if (n) return !this.lexer.state.inLink && /^<a /i.test(n[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(n[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(n[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(n[0]) && (this.lexer.state.inRawBlock = !1), { type: "html", raw: n[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: !1, text: n[0] } } link(e) { const n = this.rules.inline.link.exec(e); if (n) { const o = n[2].trim(); if (!this.options.pedantic && /^</.test(o)) { if (!/>$/.test(o)) return; const s = $r(o.slice(0, -1), "\\"); if ((o.length - s.length) % 2 === 0) return } else { const s = xy(n[2], "()"); if (s > -1) { const c = (n[0].indexOf("!") === 0 ? 5 : 4) + n[1].length + s; n[2] = n[2].substring(0, s), n[0] = n[0].substring(0, c).trim(), n[3] = "" } } let r = n[2], i = ""; if (this.options.pedantic) { const s = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(r); s && (r = s[1], i = s[3]) } else i = n[3] ? n[3].slice(1, -1) : ""; return r = r.trim(), /^</.test(r) && (this.options.pedantic && !/>$/.test(o) ? r = r.slice(1) : r = r.slice(1, -1)), lc(n, { href: r && r.replace(this.rules.inline.anyPunctuation, "$1"), title: i && i.replace(this.rules.inline.anyPunctuation, "$1") }, n[0], this.lexer) } } reflink(e, n) { let o; if ((o = this.rules.inline.reflink.exec(e)) || (o = this.rules.inline.nolink.exec(e))) { const r = (o[2] || o[1]).replace(/\s+/g, " "), i = n[r.toLowerCase()]; if (!i) { const s = o[0].charAt(0); return { type: "text", raw: s, text: s } } return lc(o, i, o[0], this.lexer) } } emStrong(e, n, o = "") { let r = this.rules.inline.emStrongLDelim.exec(e); if (!r || r[3] && o.match(/[\p{L}\p{N}]/u)) return; if (!(r[1] || r[2] || "") || !o || this.rules.inline.punctuation.exec(o)) { const s = [...r[0]].length - 1; let u, c, d = s, f = 0; const p = r[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd; for (p.lastIndex = 0, n = n.slice(-1 * e.length + s); (r = p.exec(n)) != null;) { if (u = r[1] || r[2] || r[3] || r[4] || r[5] || r[6], !u) continue; if (c = [...u].length, r[3] || r[4]) { d += c; continue } else if ((r[5] || r[6]) && s % 3 && !((s + c) % 3)) { f += c; continue } if (d -= c, d > 0) continue; c = Math.min(c, c + d + f); const h = [...r[0]][0].length, g = e.slice(0, s + r.index + h + c); if (Math.min(s, c) % 2) { const w = g.slice(1, -1); return { type: "em", raw: g, text: w, tokens: this.lexer.inlineTokens(w) } } const S = g.slice(2, -2); return { type: "strong", raw: g, text: S, tokens: this.lexer.inlineTokens(S) } } } } codespan(e) { const n = this.rules.inline.code.exec(e); if (n) { let o = n[2].replace(/\n/g, " "); const r = /[^ ]/.test(o), i = /^ /.test(o) && / $/.test(o); return r && i && (o = o.substring(1, o.length - 1)), o = Je(o, !0), { type: "codespan", raw: n[0], text: o } } } br(e) { const n = this.rules.inline.br.exec(e); if (n) return { type: "br", raw: n[0] } } del(e) { const n = this.rules.inline.del.exec(e); if (n) return { type: "del", raw: n[0], text: n[2], tokens: this.lexer.inlineTokens(n[2]) } } autolink(e) { const n = this.rules.inline.autolink.exec(e); if (n) { let o, r; return n[2] === "@" ? (o = Je(n[1]), r = "mailto:" + o) : (o = Je(n[1]), r = o), { type: "link", raw: n[0], text: o, href: r, tokens: [{ type: "text", raw: o, text: o }] } } } url(e) { var o; let n; if (n = this.rules.inline.url.exec(e)) { let r, i; if (n[2] === "@") r = Je(n[0]), i = "mailto:" + r; else { let s; do s = n[0], n[0] = ((o = this.rules.inline._backpedal.exec(n[0])) == null ? void 0 : o[0]) ?? ""; while (s !== n[0]); r = Je(n[0]), n[1] === "www." ? i = "http://" + n[0] : i = n[0] } return { type: "link", raw: n[0], text: r, href: i, tokens: [{ type: "text", raw: r, text: r }] } } } inlineText(e) { const n = this.rules.inline.text.exec(e); if (n) { let o; return this.lexer.state.inRawBlock ? o = n[0] : o = Je(n[0]), { type: "text", raw: n[0], text: o } } }
} const Cy = /^(?: *(?:\n|$))+/, Sy = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, Ty = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, mr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, _y = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, Qp = /(?:[*+-]|\d{1,9}[.)])/, Xp = Q(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, Qp).replace(/blockCode/g, / {4}/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).getRegex(), Da = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, Ey = /^[^\n]+/, La = /(?!\s*\])(?:\\.|[^\[\]\\])+/, ky = Q(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label", La).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), Iy = Q(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, Qp).getRegex(), Xi = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", Ua = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, Ny = Q("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", "i").replace("comment", Ua).replace("tag", Xi).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), Zp = Q(Da).replace("hr", mr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Xi).getRegex(), Ay = Q(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", Zp).getRegex(), Fa = { blockquote: Ay, code: Sy, def: ky, fences: Ty, heading: _y, hr: mr, html: Ny, lheading: Xp, list: Iy, newline: Cy, paragraph: Zp, table: zo, text: Ey }, ac = Q("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", mr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Xi).getRegex(), Ry = { ...Fa, table: ac, paragraph: Q(Da).replace("hr", mr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", ac).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Xi).getRegex() }, Py = {
  ...Fa, html: Q(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", Ua).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: zo, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: Q(Da).replace("hr", mr).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", Xp).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
}, jp = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, My = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, eh = /^( {2,}|\\)\n(?!\s*$)/, Dy = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, gr = "\\p{P}\\p{S}", Ly = Q(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, gr).getRegex(), Uy = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g, Fy = Q(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, gr).getRegex(), by = Q("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, gr).getRegex(), Vy = Q("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, gr).getRegex(), Gy = Q(/\\([punct])/, "gu").replace(/punct/g, gr).getRegex(), $y = Q(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), qy = Q(Ua).replace("(?:-->|$)", "-->").getRegex(), Hy = Q("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", qy).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), Ni = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, zy = Q(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", Ni).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), th = Q(/^!?\[(label)\]\[(ref)\]/).replace("label", Ni).replace("ref", La).getRegex(), nh = Q(/^!?\[(ref)\](?:\[\])?/).replace("ref", La).getRegex(), By = Q("reflink|nolink(?!\\()", "g").replace("reflink", th).replace("nolink", nh).getRegex(), ba = { _backpedal: zo, anyPunctuation: Gy, autolink: $y, blockSkip: Uy, br: eh, code: My, del: zo, emStrongLDelim: Fy, emStrongRDelimAst: by, emStrongRDelimUnd: Vy, escape: jp, link: zy, nolink: nh, punctuation: Ly, reflink: th, reflinkSearch: By, tag: Hy, text: Dy, url: zo }, Jy = { ...ba, link: Q(/^!?\[(label)\]\((.*?)\)/).replace("label", Ni).getRegex(), reflink: Q(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", Ni).getRegex() }, Il = { ...ba, escape: Q(jp).replace("])", "~|])").getRegex(), url: Q(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/, text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/ }, Wy = { ...Il, br: Q(eh).replace("{2,}", "*").getRegex(), text: Q(Il.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }, qr = { normal: Fa, gfm: Ry, pedantic: Py }, No = { normal: ba, gfm: Il, breaks: Wy, pedantic: Jy }; class Ct {
  constructor(e) { te(this, "tokens"); te(this, "options"); te(this, "state"); te(this, "tokenizer"); te(this, "inlineQueue"); this.tokens = [], this.tokens.links = Object.create(null), this.options = e || In, this.options.tokenizer = this.options.tokenizer || new Ii, this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: !1, inRawBlock: !1, top: !0 }; const n = { block: qr.normal, inline: No.normal }; this.options.pedantic ? (n.block = qr.pedantic, n.inline = No.pedantic) : this.options.gfm && (n.block = qr.gfm, this.options.breaks ? n.inline = No.breaks : n.inline = No.gfm), this.tokenizer.rules = n } static get rules() { return { block: qr, inline: No } } static lex(e, n) { return new Ct(n).lex(e) } static lexInline(e, n) { return new Ct(n).inlineTokens(e) } lex(e) {
    e = e.replace(/\r\n|\r/g, `
`), this.blockTokens(e, this.tokens); for (let n = 0; n < this.inlineQueue.length; n++) { const o = this.inlineQueue[n]; this.inlineTokens(o.src, o.tokens) } return this.inlineQueue = [], this.tokens
  } blockTokens(e, n = []) {
    this.options.pedantic ? e = e.replace(/\t/g, "    ").replace(/^ +$/gm, "") : e = e.replace(/^( *)(\t+)/gm, (u, c, d) => c + "    ".repeat(d.length)); let o, r, i, s; for (; e;)if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(u => (o = u.call({ lexer: this }, e, n)) ? (e = e.substring(o.raw.length), n.push(o), !0) : !1))) {
      if (o = this.tokenizer.space(e)) {
        e = e.substring(o.raw.length), o.raw.length === 1 && n.length > 0 ? n[n.length - 1].raw += `
`: n.push(o); continue
      } if (o = this.tokenizer.code(e)) {
        e = e.substring(o.raw.length), r = n[n.length - 1], r && (r.type === "paragraph" || r.type === "text") ? (r.raw += `
`+ o.raw, r.text += `
`+ o.text, this.inlineQueue[this.inlineQueue.length - 1].src = r.text) : n.push(o); continue
      } if (o = this.tokenizer.fences(e)) { e = e.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.heading(e)) { e = e.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.hr(e)) { e = e.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.blockquote(e)) { e = e.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.list(e)) { e = e.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.html(e)) { e = e.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.def(e)) {
        e = e.substring(o.raw.length), r = n[n.length - 1], r && (r.type === "paragraph" || r.type === "text") ? (r.raw += `
`+ o.raw, r.text += `
`+ o.raw, this.inlineQueue[this.inlineQueue.length - 1].src = r.text) : this.tokens.links[o.tag] || (this.tokens.links[o.tag] = { href: o.href, title: o.title }); continue
      } if (o = this.tokenizer.table(e)) { e = e.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.lheading(e)) { e = e.substring(o.raw.length), n.push(o); continue } if (i = e, this.options.extensions && this.options.extensions.startBlock) { let u = 1 / 0; const c = e.slice(1); let d; this.options.extensions.startBlock.forEach(f => { d = f.call({ lexer: this }, c), typeof d == "number" && d >= 0 && (u = Math.min(u, d)) }), u < 1 / 0 && u >= 0 && (i = e.substring(0, u + 1)) } if (this.state.top && (o = this.tokenizer.paragraph(i))) {
        r = n[n.length - 1], s && r.type === "paragraph" ? (r.raw += `
`+ o.raw, r.text += `
`+ o.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = r.text) : n.push(o), s = i.length !== e.length, e = e.substring(o.raw.length); continue
      } if (o = this.tokenizer.text(e)) {
        e = e.substring(o.raw.length), r = n[n.length - 1], r && r.type === "text" ? (r.raw += `
`+ o.raw, r.text += `
`+ o.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = r.text) : n.push(o); continue
      } if (e) { const u = "Infinite loop on byte: " + e.charCodeAt(0); if (this.options.silent) { console.error(u); break } else throw new Error(u) }
    } return this.state.top = !0, n
  } inline(e, n = []) { return this.inlineQueue.push({ src: e, tokens: n }), n } inlineTokens(e, n = []) { let o, r, i, s = e, u, c, d; if (this.tokens.links) { const f = Object.keys(this.tokens.links); if (f.length > 0) for (; (u = this.tokenizer.rules.inline.reflinkSearch.exec(s)) != null;)f.includes(u[0].slice(u[0].lastIndexOf("[") + 1, -1)) && (s = s.slice(0, u.index) + "[" + "a".repeat(u[0].length - 2) + "]" + s.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex)) } for (; (u = this.tokenizer.rules.inline.blockSkip.exec(s)) != null;)s = s.slice(0, u.index) + "[" + "a".repeat(u[0].length - 2) + "]" + s.slice(this.tokenizer.rules.inline.blockSkip.lastIndex); for (; (u = this.tokenizer.rules.inline.anyPunctuation.exec(s)) != null;)s = s.slice(0, u.index) + "++" + s.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex); for (; e;)if (c || (d = ""), c = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(f => (o = f.call({ lexer: this }, e, n)) ? (e = e.substring(o.raw.length), n.push(o), !0) : !1))) { if (o = this.tokenizer.escape(e)) { e = e.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.tag(e)) { e = e.substring(o.raw.length), r = n[n.length - 1], r && o.type === "text" && r.type === "text" ? (r.raw += o.raw, r.text += o.text) : n.push(o); continue } if (o = this.tokenizer.link(e)) { e = e.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.reflink(e, this.tokens.links)) { e = e.substring(o.raw.length), r = n[n.length - 1], r && o.type === "text" && r.type === "text" ? (r.raw += o.raw, r.text += o.text) : n.push(o); continue } if (o = this.tokenizer.emStrong(e, s, d)) { e = e.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.codespan(e)) { e = e.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.br(e)) { e = e.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.del(e)) { e = e.substring(o.raw.length), n.push(o); continue } if (o = this.tokenizer.autolink(e)) { e = e.substring(o.raw.length), n.push(o); continue } if (!this.state.inLink && (o = this.tokenizer.url(e))) { e = e.substring(o.raw.length), n.push(o); continue } if (i = e, this.options.extensions && this.options.extensions.startInline) { let f = 1 / 0; const p = e.slice(1); let h; this.options.extensions.startInline.forEach(g => { h = g.call({ lexer: this }, p), typeof h == "number" && h >= 0 && (f = Math.min(f, h)) }), f < 1 / 0 && f >= 0 && (i = e.substring(0, f + 1)) } if (o = this.tokenizer.inlineText(i)) { e = e.substring(o.raw.length), o.raw.slice(-1) !== "_" && (d = o.raw.slice(-1)), c = !0, r = n[n.length - 1], r && r.type === "text" ? (r.raw += o.raw, r.text += o.text) : n.push(o); continue } if (e) { const f = "Infinite loop on byte: " + e.charCodeAt(0); if (this.options.silent) { console.error(f); break } else throw new Error(f) } } return n }
} class Ai {
  constructor(e) { te(this, "options"); this.options = e || In } code(e, n, o) {
    var i; const r = (i = (n || "").match(/^\S*/)) == null ? void 0 : i[0]; return e = e.replace(/\n$/, "") + `
`, r ? '<pre><code class="language-' + Je(r) + '">' + (o ? e : Je(e, !0)) + `</code></pre>
`: "<pre><code>" + (o ? e : Je(e, !0)) + `</code></pre>
`} blockquote(e) {
    return `<blockquote>
${e}</blockquote>
`} html(e, n) { return e } heading(e, n, o) {
    return `<h${n}>${e}</h${n}>
`} hr() {
    return `<hr>
`} list(e, n, o) {
    const r = n ? "ol" : "ul", i = n && o !== 1 ? ' start="' + o + '"' : ""; return "<" + r + i + `>
`+ e + "</" + r + `>
`} listitem(e, n, o) {
    return `<li>${e}</li>
`} checkbox(e) { return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">' } paragraph(e) {
    return `<p>${e}</p>
`} table(e, n) {
    return n && (n = `<tbody>${n}</tbody>`), `<table>
<thead>
`+ e + `</thead>
`+ n + `</table>
`} tablerow(e) {
    return `<tr>
${e}</tr>
`} tablecell(e, n) {
    const o = n.header ? "th" : "td"; return (n.align ? `<${o} align="${n.align}">` : `<${o}>`) + e + `</${o}>
`} strong(e) { return `<strong>${e}</strong>` } em(e) { return `<em>${e}</em>` } codespan(e) { return `<code>${e}</code>` } br() { return "<br>" } del(e) { return `<del>${e}</del>` } link(e, n, o) { const r = ic(e); if (r === null) return o; e = r; let i = '<a href="' + e + '"'; return n && (i += ' title="' + n + '"'), i += ">" + o + "</a>", i } image(e, n, o) { const r = ic(e); if (r === null) return o; e = r; let i = `<img src="${e}" alt="${o}"`; return n && (i += ` title="${n}"`), i += ">", i } text(e) { return e }
} class Va { strong(e) { return e } em(e) { return e } codespan(e) { return e } del(e) { return e } html(e) { return e } text(e) { return e } link(e, n, o) { return "" + o } image(e, n, o) { return "" + o } br() { return "" } } class St {
  constructor(e) { te(this, "options"); te(this, "renderer"); te(this, "textRenderer"); this.options = e || In, this.options.renderer = this.options.renderer || new Ai, this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new Va } static parse(e, n) { return new St(n).parse(e) } static parseInline(e, n) { return new St(n).parseInline(e) } parse(e, n = !0) {
    let o = ""; for (let r = 0; r < e.length; r++) {
      const i = e[r]; if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[i.type]) { const s = i, u = this.options.extensions.renderers[s.type].call({ parser: this }, s); if (u !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(s.type)) { o += u || ""; continue } } switch (i.type) {
        case "space": continue; case "hr": { o += this.renderer.hr(); continue } case "heading": { const s = i; o += this.renderer.heading(this.parseInline(s.tokens), s.depth, yy(this.parseInline(s.tokens, this.textRenderer))); continue } case "code": { const s = i; o += this.renderer.code(s.text, s.lang, !!s.escaped); continue } case "table": { const s = i; let u = "", c = ""; for (let f = 0; f < s.header.length; f++)c += this.renderer.tablecell(this.parseInline(s.header[f].tokens), { header: !0, align: s.align[f] }); u += this.renderer.tablerow(c); let d = ""; for (let f = 0; f < s.rows.length; f++) { const p = s.rows[f]; c = ""; for (let h = 0; h < p.length; h++)c += this.renderer.tablecell(this.parseInline(p[h].tokens), { header: !1, align: s.align[h] }); d += this.renderer.tablerow(c) } o += this.renderer.table(u, d); continue } case "blockquote": { const s = i, u = this.parse(s.tokens); o += this.renderer.blockquote(u); continue } case "list": { const s = i, u = s.ordered, c = s.start, d = s.loose; let f = ""; for (let p = 0; p < s.items.length; p++) { const h = s.items[p], g = h.checked, S = h.task; let w = ""; if (h.task) { const I = this.renderer.checkbox(!!g); d ? h.tokens.length > 0 && h.tokens[0].type === "paragraph" ? (h.tokens[0].text = I + " " + h.tokens[0].text, h.tokens[0].tokens && h.tokens[0].tokens.length > 0 && h.tokens[0].tokens[0].type === "text" && (h.tokens[0].tokens[0].text = I + " " + h.tokens[0].tokens[0].text)) : h.tokens.unshift({ type: "text", text: I + " " }) : w += I + " " } w += this.parse(h.tokens, d), f += this.renderer.listitem(w, S, !!g) } o += this.renderer.list(f, u, c); continue } case "html": { const s = i; o += this.renderer.html(s.text, s.block); continue } case "paragraph": { const s = i; o += this.renderer.paragraph(this.parseInline(s.tokens)); continue } case "text": {
          let s = i, u = s.tokens ? this.parseInline(s.tokens) : s.text; for (; r + 1 < e.length && e[r + 1].type === "text";)s = e[++r], u += `
`+ (s.tokens ? this.parseInline(s.tokens) : s.text); o += n ? this.renderer.paragraph(u) : u; continue
        } default: { const s = 'Token with "' + i.type + '" type was not found.'; if (this.options.silent) return console.error(s), ""; throw new Error(s) }
      }
    } return o
  } parseInline(e, n) { n = n || this.renderer; let o = ""; for (let r = 0; r < e.length; r++) { const i = e[r]; if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[i.type]) { const s = this.options.extensions.renderers[i.type].call({ parser: this }, i); if (s !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(i.type)) { o += s || ""; continue } } switch (i.type) { case "escape": { const s = i; o += n.text(s.text); break } case "html": { const s = i; o += n.html(s.text); break } case "link": { const s = i; o += n.link(s.href, s.title, this.parseInline(s.tokens, n)); break } case "image": { const s = i; o += n.image(s.href, s.title, s.text); break } case "strong": { const s = i; o += n.strong(this.parseInline(s.tokens, n)); break } case "em": { const s = i; o += n.em(this.parseInline(s.tokens, n)); break } case "codespan": { const s = i; o += n.codespan(s.text); break } case "br": { o += n.br(); break } case "del": { const s = i; o += n.del(this.parseInline(s.tokens, n)); break } case "text": { const s = i; o += n.text(s.text); break } default: { const s = 'Token with "' + i.type + '" type was not found.'; if (this.options.silent) return console.error(s), ""; throw new Error(s) } } } return o }
} class Bo { constructor(e) { te(this, "options"); this.options = e || In } preprocess(e) { return e } postprocess(e) { return e } processAllTokens(e) { return e } } te(Bo, "passThroughHooks", new Set(["preprocess", "postprocess", "processAllTokens"])); var ur, Nl, Li, oh; class Yy { constructor(...e) { ls(this, ur); ls(this, Li); te(this, "defaults", Ma()); te(this, "options", this.setOptions); te(this, "parse", Sr(this, ur, Nl).call(this, Ct.lex, St.parse)); te(this, "parseInline", Sr(this, ur, Nl).call(this, Ct.lexInline, St.parseInline)); te(this, "Parser", St); te(this, "Renderer", Ai); te(this, "TextRenderer", Va); te(this, "Lexer", Ct); te(this, "Tokenizer", Ii); te(this, "Hooks", Bo); this.use(...e) } walkTokens(e, n) { var r, i; let o = []; for (const s of e) switch (o = o.concat(n.call(this, s)), s.type) { case "table": { const u = s; for (const c of u.header) o = o.concat(this.walkTokens(c.tokens, n)); for (const c of u.rows) for (const d of c) o = o.concat(this.walkTokens(d.tokens, n)); break } case "list": { const u = s; o = o.concat(this.walkTokens(u.items, n)); break } default: { const u = s; (i = (r = this.defaults.extensions) == null ? void 0 : r.childTokens) != null && i[u.type] ? this.defaults.extensions.childTokens[u.type].forEach(c => { const d = u[c].flat(1 / 0); o = o.concat(this.walkTokens(d, n)) }) : u.tokens && (o = o.concat(this.walkTokens(u.tokens, n))) } }return o } use(...e) { const n = this.defaults.extensions || { renderers: {}, childTokens: {} }; return e.forEach(o => { const r = { ...o }; if (r.async = this.defaults.async || r.async || !1, o.extensions && (o.extensions.forEach(i => { if (!i.name) throw new Error("extension name required"); if ("renderer" in i) { const s = n.renderers[i.name]; s ? n.renderers[i.name] = function (...u) { let c = i.renderer.apply(this, u); return c === !1 && (c = s.apply(this, u)), c } : n.renderers[i.name] = i.renderer } if ("tokenizer" in i) { if (!i.level || i.level !== "block" && i.level !== "inline") throw new Error("extension level must be 'block' or 'inline'"); const s = n[i.level]; s ? s.unshift(i.tokenizer) : n[i.level] = [i.tokenizer], i.start && (i.level === "block" ? n.startBlock ? n.startBlock.push(i.start) : n.startBlock = [i.start] : i.level === "inline" && (n.startInline ? n.startInline.push(i.start) : n.startInline = [i.start])) } "childTokens" in i && i.childTokens && (n.childTokens[i.name] = i.childTokens) }), r.extensions = n), o.renderer) { const i = this.defaults.renderer || new Ai(this.defaults); for (const s in o.renderer) { if (!(s in i)) throw new Error(`renderer '${s}' does not exist`); if (s === "options") continue; const u = s, c = o.renderer[u], d = i[u]; i[u] = (...f) => { let p = c.apply(i, f); return p === !1 && (p = d.apply(i, f)), p || "" } } r.renderer = i } if (o.tokenizer) { const i = this.defaults.tokenizer || new Ii(this.defaults); for (const s in o.tokenizer) { if (!(s in i)) throw new Error(`tokenizer '${s}' does not exist`); if (["options", "rules", "lexer"].includes(s)) continue; const u = s, c = o.tokenizer[u], d = i[u]; i[u] = (...f) => { let p = c.apply(i, f); return p === !1 && (p = d.apply(i, f)), p } } r.tokenizer = i } if (o.hooks) { const i = this.defaults.hooks || new Bo; for (const s in o.hooks) { if (!(s in i)) throw new Error(`hook '${s}' does not exist`); if (s === "options") continue; const u = s, c = o.hooks[u], d = i[u]; Bo.passThroughHooks.has(s) ? i[u] = f => { if (this.defaults.async) return Promise.resolve(c.call(i, f)).then(h => d.call(i, h)); const p = c.call(i, f); return d.call(i, p) } : i[u] = (...f) => { let p = c.apply(i, f); return p === !1 && (p = d.apply(i, f)), p } } r.hooks = i } if (o.walkTokens) { const i = this.defaults.walkTokens, s = o.walkTokens; r.walkTokens = function (u) { let c = []; return c.push(s.call(this, u)), i && (c = c.concat(i.call(this, u))), c } } this.defaults = { ...this.defaults, ...r } }), this } setOptions(e) { return this.defaults = { ...this.defaults, ...e }, this } lexer(e, n) { return Ct.lex(e, n ?? this.defaults) } parser(e, n) { return St.parse(e, n ?? this.defaults) } } ur = new WeakSet, Nl = function (e, n) { return (o, r) => { const i = { ...r }, s = { ...this.defaults, ...i }; this.defaults.async === !0 && i.async === !1 && (s.silent || console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored."), s.async = !0); const u = Sr(this, Li, oh).call(this, !!s.silent, !!s.async); if (typeof o > "u" || o === null) return u(new Error("marked(): input parameter is undefined or null")); if (typeof o != "string") return u(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(o) + ", string expected")); if (s.hooks && (s.hooks.options = s), s.async) return Promise.resolve(s.hooks ? s.hooks.preprocess(o) : o).then(c => e(c, s)).then(c => s.hooks ? s.hooks.processAllTokens(c) : c).then(c => s.walkTokens ? Promise.all(this.walkTokens(c, s.walkTokens)).then(() => c) : c).then(c => n(c, s)).then(c => s.hooks ? s.hooks.postprocess(c) : c).catch(u); try { s.hooks && (o = s.hooks.preprocess(o)); let c = e(o, s); s.hooks && (c = s.hooks.processAllTokens(c)), s.walkTokens && this.walkTokens(c, s.walkTokens); let d = n(c, s); return s.hooks && (d = s.hooks.postprocess(d)), d } catch (c) { return u(c) } } }, Li = new WeakSet, oh = function (e, n) {
  return o => {
    if (o.message += `
Please report this to https://github.com/markedjs/marked.`, e) { const r = "<p>An error occurred:</p><pre>" + Je(o.message + "", !0) + "</pre>"; return n ? Promise.resolve(r) : r } if (n) return Promise.reject(o); throw o
  }
}; const _n = new Yy; function Y(t, e) { return _n.parse(t, e) } Y.options = Y.setOptions = function (t) { return _n.setOptions(t), Y.defaults = _n.defaults, Yp(Y.defaults), Y }; Y.getDefaults = Ma; Y.defaults = In; Y.use = function (...t) { return _n.use(...t), Y.defaults = _n.defaults, Yp(Y.defaults), Y }; Y.walkTokens = function (t, e) { return _n.walkTokens(t, e) }; Y.parseInline = _n.parseInline; Y.Parser = St; Y.parser = St.parse; Y.Renderer = Ai; Y.TextRenderer = Va; Y.Lexer = Ct; Y.lexer = Ct.lex; Y.Tokenizer = Ii; Y.Hooks = Bo; Y.parse = Y; Y.options; Y.setOptions; Y.use; Y.walkTokens; Y.parseInline; St.parse; Ct.lex; const Ky = ({ window: t, theme: e, isMobile: n, onClose: o, onMinimize: r, onMaximize: i, onFocus: s, onUpdatePosition: u, onAskKaiou: c, hasKaiouAccess: d, children: f }) => {
  const [p, h] = P.useState(!1), [g, S] = P.useState(!1), [w, I] = P.useState(!1), [x, y] = P.useState(!1), [v, T] = P.useState(0), [E, C] = P.useState(!1), k = P.useRef(0), [A, N] = P.useState("rapid"), [M, b] = P.useState([]), [z, se] = P.useState(""), [ht, mt] = P.useState(!1), he = P.useRef({ x: 0, y: 0 }), Ce = P.useRef({ x: 0, y: 0, w: 0, h: 0 }), L = P.useRef(null), V = P.useRef(null); P.useEffect(() => { if (n) return; const G = fe => { if (p) { const ke = fe.clientX - he.current.x; let ze = fe.clientY - he.current.y; ze < 0 && (ze = 0), u(t.id, ke, ze, t.width, t.height) } else if (g) { const ke = fe.clientX - Ce.current.x, ze = fe.clientY - Ce.current.y, Pn = Math.max(300, Ce.current.w + ke), yt = Math.max(200, Ce.current.h + ze); u(t.id, t.x, t.y, Pn, yt) } }, Z = () => { h(!1), S(!1) }; return (p || g) && (document.addEventListener("mousemove", G), document.addEventListener("mouseup", Z)), () => { document.removeEventListener("mousemove", G), document.removeEventListener("mouseup", Z) } }, [p, g, t, u, n]), P.useEffect(() => { if (!n || !E) return; const G = fe => { const ke = fe.clientY - k.current; ke > 0 ? T(ke * .2) : T(ke) }, Z = () => { C(!1), v < -50 && y(!1), T(0) }; return document.addEventListener("mousemove", G), document.addEventListener("mouseup", Z), () => { document.removeEventListener("mousemove", G), document.removeEventListener("mouseup", Z) } }, [n, E, v]), P.useEffect(() => { (w || x) && V.current && V.current.scrollIntoView({ behavior: "smooth" }) }, [M, w, x]); const H = G => { t.isMaximized || n || (h(!0), he.current = { x: G.clientX - t.x, y: G.clientY - t.y }, s(t.id)) }, O = G => { G.stopPropagation(), !(t.isMaximized || n) && (S(!0), Ce.current = { x: G.clientX, y: G.clientY, w: t.width, h: t.height }, s(t.id)) }, X = G => { k.current = G.touches[0].clientY, C(!0) }, gt = G => { if (!E) return; const Z = G.touches[0].clientY - k.current; Z < 0 ? T(Z) : T(Z * .2) }, Me = () => { C(!1), v < -50 && y(!1), T(0) }, Et = G => { k.current = G.clientY, C(!0) }, Xe = () => { let G = ""; if (L.current) { const Z = L.current.querySelector("iframe"); if (Z) try { Z.contentDocument && Z.contentDocument.body && (G = Z.contentDocument.body.innerText) } catch { G = "Content unavailable (Cross-Origin Frame)" } else G = L.current.innerText } return G }, ve = async (G, Z) => {
    if (!c) return; const fe = Xe(); let ke = G || "", ze = G || ""; if (Z) switch (Z) {
      case "threat": ke = `Analyze this content for security threats, policy violations, or malicious intent. Be concise.

CONTENT:
${fe.substring(0, 1e4)}`, ze = "Run Threat Assessment"; break; case "suspicion": ke = `Analyze this content for suspicious behavior, lies, or inconsistencies. Give a suspicion score out of 10.

CONTENT:
${fe.substring(0, 1e4)}`, ze = "Run Suspicion Check"; break; default: ke = `Summarize and analyze this content.

CONTENT:
${fe.substring(0, 1e4)}`, ze = "Analyze Content"; break
    } else G && (ke = `${G}

Context from window:
${fe.substring(0, 5e3)}`); b(yt => [...yt, { role: "user", text: ze }]), mt(!0), se(""); const Pn = A === "rapid" ? "gemini-flash-lite-latest" : "gemini-2.5-flash"; try { const yt = await c(ke, Pn); b(_ => [..._, { role: "model", text: yt }]) } catch (yt) { b(_ => [..._, { role: "model", text: `Error: ${yt.message}` }]) } finally { mt(!1) }
  }, ns = ({ content: G }) => {
    try {
      const Z = Y.parse(G, { breaks: !0 }), fe = `
          [&>p]:mb-2 [&>p:last-child]:mb-0 
          [&>a]:text-blue-300 [&>a]:underline 
          [&>ul]:list-disc [&>ul]:pl-4 [&>ul]:mb-2 
          [&>ol]:list-decimal [&>ol]:pl-4 [&>ol]:mb-2 
          [&>li]:mb-1 
          [&>strong]:font-bold 
          [&>em]:italic 
          [&>code]:bg-black/30 [&>code]:px-1.5 [&>code]:py-0.5 [&>code]:rounded [&>code]:font-mono [&>code]:text-[10px]
          [&>pre]:bg-black/40 [&>pre]:p-3 [&>pre]:rounded-lg [&>pre]:overflow-x-auto [&>pre]:mb-3 [&>pre]:mt-1
          [&>h1]:text-sm [&>h1]:font-bold [&>h1]:mb-2 [&>h1]:mt-2
          [&>h2]:text-sm [&>h2]:font-bold [&>h2]:mb-2 [&>h2]:mt-2
          [&>h3]:text-xs [&>h3]:font-bold [&>h3]:mb-1 [&>h3]:mt-1
          [&>blockquote]:border-l-2 [&>blockquote]:border-white/30 [&>blockquote]:pl-3 [&>blockquote]:italic [&>blockquote]:text-white/70
        `; return m.jsx("div", { className: `markdown-body ${fe}`, dangerouslySetInnerHTML: { __html: Z } })
    } catch { return m.jsx("div", { children: G }) }
  }; if (t.isMinimized) return null; const Gt = Dn.find(G => G.id === t.appId), He = e.taskbarStyle === "retro", $t = e.taskbarStyle === "dock", yr = e.taskbarStyle === "vertical", yo = e.windowControlPosition || "right", vr = n ? { top: 0, left: 0, width: "100%", height: "100%", transform: "none", borderRadius: 0, border: "none" } : {}; let An = "0px", xr = "0px", qt = "100%", Rn = "100%"; t.isMaximized && !n ? yr ? (xr = "96px", An = "16px", Rn = "calc(100% - 112px)", qt = "calc(100% - 32px)") : $t ? (An = "28px", qt = "calc(100% - 28px)") : qt = "calc(100% - 48px)" : n || (qt = `${t.height}px`, Rn = `${t.width}px`); const os = { transform: t.isMaximized ? "none" : `translate(${t.x}px, ${t.y}px)`, width: Rn, height: qt, top: t.isMaximized ? An : 0, left: t.isMaximized ? xr : 0, zIndex: t.zIndex, backgroundColor: e.windowBg, border: n ? "none" : e.windowBorder, color: He ? "black" : "white", fontFamily: e.font, willChange: p ? "transform" : "auto", ...vr }, rs = t.isMaximized ? yr ? "rounded-2xl shadow-2xl" : "!rounded-none !border-none" : "rounded-lg shadow-2xl", is = He ? "border-t-2 border-l-2 border-b-2 border-r-2 border-t-white border-l-white border-b-black border-r-black shadow-none !rounded-none" : "", vo = $t && !t.isMaximized ? "backdrop-blur-3xl border border-white/5 rounded-xl shadow-[0_20px_50px_rgba(0,0,0,0.5)]" : "", wr = e.accentColor.toLowerCase() === "#ffffff" ? "black" : "white", Cr = () => n ? m.jsxs("div", { className: "flex items-center gap-3", children: [d && m.jsx("button", { onClick: () => y(!x), className: "w-8 h-8 flex items-center justify-center rounded-full bg-gray-800 text-gray-400 active:scale-90 transition-transform", style: x ? { backgroundColor: e.accentColor, color: wr } : {}, children: m.jsx("span", { className: "material-symbols-rounded text-[18px]", children: "auto_awesome" }) }), m.jsx("button", { onClick: () => o(t.id), className: "w-8 h-8 flex items-center justify-center rounded-full bg-gray-800 text-gray-400 active:scale-90 transition-transform", children: m.jsx("span", { className: "material-symbols-rounded text-sm", children: "close" }) })] }) : He ? m.jsxs(m.Fragment, { children: [m.jsx("button", { onClick: () => i(t.id), className: "w-5 h-4 bg-gray-300 border-2 border-t-white border-l-white border-b-black border-r-black text-[8px] flex items-center justify-center font-bold text-black", children: "" }), m.jsx("button", { onClick: () => r(t.id), className: "w-5 h-4 bg-gray-300 border-2 border-t-white border-l-white border-b-black border-r-black text-[8px] flex items-center justify-center font-bold text-black", children: "_" }), m.jsx("button", { onClick: () => o(t.id), className: "w-5 h-4 bg-gray-300 border-2 border-t-white border-l-white border-b-black border-r-black text-[8px] flex items-center justify-center font-bold text-black", children: "X" })] }) : $t ? m.jsxs(m.Fragment, { children: [m.jsx("button", { onClick: () => o(t.id), className: "w-3 h-3 rounded-full bg-red-500 hover:opacity-80" }), m.jsx("button", { onClick: () => r(t.id), className: "w-3 h-3 rounded-full bg-yellow-400 hover:opacity-80" }), m.jsx("button", { onClick: () => i(t.id), className: "w-3 h-3 rounded-full bg-green-500 hover:opacity-80" })] }) : m.jsxs(m.Fragment, { children: [m.jsx("button", { onClick: () => i(t.id), className: "w-3 h-3 rounded-full bg-green-500 opacity-70 hover:opacity-100" }), m.jsx("button", { onClick: () => r(t.id), className: "w-3 h-3 rounded-full bg-yellow-500 opacity-70 hover:opacity-100" }), m.jsx("button", { onClick: () => o(t.id), className: "w-3 h-3 rounded-full bg-red-500 opacity-70 hover:opacity-100" })] }), Ht = () => m.jsx("button", { onClick: G => { G.stopPropagation(), I(!w) }, onMouseDown: G => G.stopPropagation(), className: `w-6 h-6 flex items-center justify-center rounded transition-all duration-300 ${w ? "" : "text-gray-400 hover:text-white hover:bg-white/5"}`, style: w ? { backgroundColor: e.accentColor, color: wr } : {}, title: "Kaiou Intelligence", children: m.jsx("span", { className: "material-symbols-rounded text-[18px]", children: "auto_awesome" }) }), xo = () => m.jsxs("div", { className: "flex-1 flex flex-col h-full overflow-hidden", children: [m.jsxs("div", { className: "h-12 border-b border-white/10 flex items-center justify-between px-4 bg-white/5 flex-shrink-0 touch-none select-none cursor-grab active:cursor-grabbing", onTouchStart: n ? X : void 0, onTouchMove: n ? gt : void 0, onTouchEnd: n ? Me : void 0, onMouseDown: n ? Et : void 0, children: [m.jsxs("div", { className: "flex items-center gap-2 pointer-events-none", children: [m.jsx("div", { className: "w-8 h-8 rounded-full flex items-center justify-center bg-white/5", style: { color: e.accentColor }, children: m.jsx("span", { className: "material-symbols-rounded text-[20px]", children: "auto_awesome" }) }), m.jsx("span", { className: "font-bold text-sm text-white tracking-wide", children: "Kaiou" })] }), m.jsxs("div", { className: "relative group", onTouchStart: G => G.stopPropagation(), onMouseDown: G => G.stopPropagation(), children: [m.jsxs("select", { value: A, onChange: G => N(G.target.value), className: "appearance-none bg-black/40 border border-white/10 rounded-lg pl-3 pr-8 py-1.5 text-xs font-bold text-white outline-none cursor-pointer transition-all hover:bg-white/5 focus:bg-white/10", style: { borderColor: "rgba(255,255,255,0.1)" }, children: [m.jsx("option", { value: "rapid", className: "bg-[#111] text-gray-300", children: "Kaiou Rapid" }), m.jsx("option", { value: "kio", className: "bg-[#111] text-gray-300", children: "Kaiou" })] }), m.jsx("div", { className: "absolute right-2.5 top-1/2 -translate-y-1/2 pointer-events-none text-gray-500 group-hover:text-white transition-colors", children: m.jsx("span", { className: "material-symbols-rounded text-[16px]", children: "expand_more" }) })] })] }), m.jsxs("div", { className: "flex-1 overflow-y-auto custom-scroll p-4 space-y-4", children: [M.length === 0 ? m.jsxs("div", { className: "flex flex-col items-center justify-center h-full text-gray-500 opacity-50", children: [m.jsx("span", { className: "material-symbols-rounded text-4xl mb-2", style: { color: e.accentColor }, children: "temp_preferences_custom" }), m.jsxs("p", { className: "text-xs text-center", children: ["Select a mode or type a prompt", m.jsx("br", {}), "to analyze this window."] })] }) : M.map((G, Z) => { const fe = G.role === "user", ze = e.accentColor.toLowerCase() === "#ffffff" ? "text-black" : "text-white"; return m.jsx("div", { className: `flex flex-col ${fe ? "items-end" : "items-start"}`, children: m.jsx("div", { className: `max-w-[85%] rounded-[18px] px-3 py-2 text-xs leading-relaxed shadow-sm border border-transparent ${fe ? `${ze} rounded-br-[4px]` : "bg-white/5 text-gray-100 rounded-bl-[4px] border-white/10 backdrop-blur-md"}`, style: fe ? { backgroundColor: e.accentColor } : {}, children: m.jsx(ns, { content: G.text }) }) }, Z) }), ht && m.jsx("div", { className: "flex justify-start", children: m.jsxs("div", { className: "bg-white/10 rounded-[18px] rounded-bl-[4px] px-4 py-3 flex gap-1 items-center border border-white/10", children: [m.jsx("div", { className: "w-1.5 h-1.5 rounded-full animate-bounce", style: { backgroundColor: e.accentColor } }), m.jsx("div", { className: "w-1.5 h-1.5 rounded-full animate-bounce delay-75", style: { backgroundColor: e.accentColor } }), m.jsx("div", { className: "w-1.5 h-1.5 rounded-full animate-bounce delay-150", style: { backgroundColor: e.accentColor } })] }) }), m.jsx("div", { ref: V })] }), m.jsxs("div", { className: "p-4 border-t border-white/10 bg-black/20 space-y-3 flex-shrink-0", children: [m.jsxs("div", { className: "flex gap-2", children: [m.jsxs("button", { onClick: () => ve(void 0, "threat"), className: "flex-1 bg-red-900/20 hover:bg-red-900/40 border border-red-900/50 text-red-400 text-[10px] py-1.5 rounded transition-colors flex items-center justify-center gap-1", children: [m.jsx("span", { className: "material-symbols-rounded text-[14px]", children: "shield" }), " Threat"] }), m.jsxs("button", { onClick: () => ve(void 0, "suspicion"), className: "flex-1 bg-yellow-900/20 hover:bg-yellow-900/40 border border-yellow-900/50 text-yellow-400 text-[10px] py-1.5 rounded transition-colors flex items-center justify-center gap-1", children: [m.jsx("span", { className: "material-symbols-rounded text-[14px]", children: "visibility" }), " Suspicion"] }), m.jsxs("button", { onClick: () => ve(void 0, "analyze"), className: "flex-1 bg-blue-900/20 hover:bg-blue-900/40 border border-blue-900/50 text-blue-400 text-[10px] py-1.5 rounded transition-colors flex items-center justify-center gap-1", children: [m.jsx("span", { className: "material-symbols-rounded text-[14px]", children: "search" }), " Summary"] })] }), m.jsxs("div", { className: "relative", children: [m.jsx("input", { type: "text", value: z, onChange: G => se(G.target.value), onKeyDown: G => G.key === "Enter" && ve(z), placeholder: "Ask Kaiou...", className: "w-full bg-black/50 border border-white/10 rounded-lg pl-3 pr-8 py-2 text-xs text-white outline-none placeholder-gray-600 focus:border-white/30 transition-colors" }), m.jsx("button", { onClick: () => ve(z), disabled: !z.trim() || ht, className: "absolute right-1 top-1 bottom-1 w-6 flex items-center justify-center text-gray-400 hover:text-white disabled:opacity-30", children: m.jsx("span", { className: "material-symbols-rounded text-[16px]", style: z.trim() ? { color: e.accentColor } : {}, children: "send" }) })] })] })] }); return m.jsxs("div", { className: `absolute flex flex-col overflow-hidden transition-shadow ${n ? "" : is} ${n ? "" : vo} ${rs}`, style: os, onMouseDown: () => s(t.id), children: [m.jsxs("div", { className: `flex items-center justify-between px-3 select-none ${He ? "bg-[#000080] text-white" : ""} ${n ? "h-12 border-b border-gray-800" : "h-9"}`, style: { backgroundColor: He ? void 0 : n ? "#111" : e.windowHeader, flexDirection: !n && yo === "left" ? "row-reverse" : "row" }, onMouseDown: H, children: [m.jsxs("div", { className: `flex items-center gap-2 ${!n && yo === "left" ? "flex-row-reverse" : ""}`, children: [!$t && (Gt && Gt.icon.includes(" ") ? m.jsx("i", { className: `${Gt.icon} text-xs opacity-50` }) : m.jsx("span", { className: "material-symbols-rounded text-sm opacity-50", children: Gt ? Gt.icon : "grid_view" })), m.jsx("span", { className: `${n ? "text-sm" : "text-xs"} font-bold truncate opacity-90`, children: t.title })] }), m.jsx("div", { className: "flex gap-2 items-center h-full", children: !n && yo === "left" ? m.jsxs(m.Fragment, { children: [Cr(), d && Ht()] }) : m.jsxs(m.Fragment, { children: [d && !n && Ht(), Cr()] }) })] }), m.jsxs("div", { className: "flex-1 relative flex overflow-hidden", children: [m.jsxs("div", { ref: L, className: `flex-1 relative bg-black/40 w-full h-full overflow-hidden transition-all duration-300 ${w && !n ? "mr-[320px]" : ""}`, children: [(p || g) && m.jsx("div", { className: "absolute inset-0 z-50" }), f] }), !n && m.jsx("div", { className: `absolute top-0 right-0 bottom-0 w-[320px] bg-[#0a0a0a]/90 backdrop-blur-xl border-l border-white/10 z-[100] transition-transform duration-300 ease-in-out flex flex-col ${w ? "translate-x-0" : "translate-x-full"}`, children: xo() }), n && m.jsxs("div", { className: "absolute top-0 left-0 right-0 z-[100] bg-[#111] border-b border-white/10 rounded-b-2xl shadow-2xl flex flex-col transition-transform duration-300 ease-out", style: { height: "calc(100% - 9rem)", transform: E ? `translateY(${v}px)` : x ? "translateY(0)" : "translateY(-110%)" }, children: [xo(), m.jsx("div", { className: "h-12 w-full flex items-center justify-center cursor-grab active:cursor-grabbing border-t border-white/5 bg-white/5 touch-none select-none", onTouchStart: X, onTouchMove: gt, onTouchEnd: Me, onMouseDown: Et, children: m.jsx("div", { className: "flex flex-col items-center gap-1 opacity-50", children: m.jsx("div", { className: "w-12 h-1.5 bg-gray-500 rounded-full" }) }) })] })] }), !t.isMaximized && !n && m.jsx("div", { className: "absolute bottom-0 right-0 w-4 h-4 cursor-se-resize z-[101] flex items-end justify-end p-0.5", onMouseDown: O, children: m.jsx("div", { className: "w-1.5 h-1.5 border-r border-b border-gray-500 opacity-50" }) })] })
}, Oy = P.memo(Ky), Qy = ({ theme: t, isMobile: e, windows: n, menuOpen: o, setMenuOpen: r, time: i, activeWindowId: s, minimizeWindow: u, maximizeWindow: c, focusWindow: d, setLoggedIn: f, handleMobileHome: p, allApps: h, toggleNotifications: g, hasUnread: S, notifPanelOpen: w }) => {
  const I = t.taskbarStyle === "dock", x = t.taskbarStyle === "retro", y = t.taskbarStyle === "vertical", v = () => e ? "bottom-4 left-4 right-4 h-16 rounded-2xl bg-black/80 backdrop-blur-xl border border-white/10 justify-center gap-10 shadow-2xl" : y ? "left-4 top-4 bottom-4 w-20 py-6 flex-col rounded-2xl shadow-2xl border bg-black/40 backdrop-blur-xl justify-between" : I ? "bottom-4 left-1/2 -translate-x-1/2 h-16 px-4 rounded-2xl shadow-2xl border" : "bottom-0 left-0 right-0 h-12 pl-2 pr-3 border-t", T = () => e ? {} : y ? { borderColor: t.windowBorder.split(" ")[2] || "rgba(255,255,255,0.1)" } : { backgroundColor: t.taskbarBg, backdropFilter: x ? "none" : "blur(12px)", borderColor: I ? t.windowBorder.split(" ")[2] || "rgba(255,255,255,0.1)" : x ? "#fff" : "#333" }, E = () => m.jsxs(m.Fragment, { children: [m.jsxs("div", { className: "flex flex-col items-center gap-4 w-full", children: [m.jsx("div", { onClick: C => { C.stopPropagation(), r(!o) }, className: "group relative w-12 h-12 flex items-center justify-center transition-all duration-300 hover:scale-105 cursor-pointer", children: m.jsx("div", { className: "w-full h-full bg-white/5 border border-white/10 flex items-center justify-center text-white shadow-lg backdrop-blur-sm transition-colors duration-300", style: { ...Yn(t.iconShape || "circle"), backgroundColor: o ? t.accentColor : "rgba(255,255,255,0.05)", borderColor: o ? t.accentColor : "rgba(255,255,255,0.1)", color: o ? "black" : "white" }, children: m.jsx("span", { className: "material-symbols-rounded text-2xl", children: o ? "filter_vintage" : "spa" }) }) }), m.jsx("div", { className: "w-8 h-[1px] bg-gradient-to-r from-transparent via-white/20 to-transparent" })] }), m.jsx("div", { className: "flex flex-col gap-4 flex-1 overflow-y-auto no-scrollbar items-center justify-start py-2 w-full mt-2", children: n.map(C => { const k = h.find(N => N.id === C.appId); if (!k) return null; const A = s === C.id && !C.isMinimized; return m.jsxs("div", { onClick: () => C.isMinimized ? c(C.id) : d(C.id), className: "group relative w-10 h-10 flex items-center justify-center transition-all duration-200 hover:scale-110 cursor-pointer", children: [m.jsx("div", { className: `w-full h-full bg-gradient-to-br ${k.color} flex items-center justify-center text-white shadow-md group-hover:shadow-lg transition-shadow`, style: Yn(t.iconShape || "circle"), children: k.icon.includes(" ") ? m.jsx("i", { className: `${k.icon} text-sm` }) : m.jsx("span", { className: "material-symbols-rounded text-[20px]", children: k.icon }) }), m.jsx("div", { className: `absolute -left-3 top-1/2 -translate-y-1/2 w-1 h-3 bg-white rounded-full transition-all duration-300 shadow-[0_0_8px_white] ${A ? "opacity-100 h-5" : C.isMinimized ? "opacity-30 h-1" : "opacity-60 h-2"}` })] }, C.id) }) }), m.jsxs("div", { className: "flex flex-col items-center gap-4 w-full", children: [m.jsx("div", { className: "w-8 h-[1px] bg-gradient-to-r from-transparent via-white/20 to-transparent" }), m.jsxs("button", { onClick: C => { C.stopPropagation(), g() }, className: `w-10 h-10 rounded-full hover:bg-white/10 transition-colors flex items-center justify-center relative ${w ? "text-blue-400" : "text-gray-400"}`, children: [m.jsx("span", { className: `material-symbols-rounded text-[24px] ${S ? "fill-1" : ""}`, children: "notifications" }), S && !w && m.jsx("span", { className: "absolute top-2 right-2 w-2 h-2 bg-red-500 rounded-full border border-black" })] }), m.jsxs("div", { className: "flex flex-col items-center justify-center text-xs font-bold leading-none text-white/80 select-none pb-2", children: [m.jsx("span", { className: "text-sm tracking-wider", children: i.getHours().toString().padStart(2, "0") }), m.jsx("span", { className: "text-[10px] text-white/40", children: i.getMinutes().toString().padStart(2, "0") })] })] })] }); return m.jsx("div", {
    className: `fixed z-[10010] flex items-center transition-all duration-300 ${v()}`, style: T(), children: e ? m.jsxs(m.Fragment, { children: [m.jsxs("button", { onClick: p, className: "w-16 h-full flex flex-col items-center justify-center gap-1 text-gray-400 hover:text-white active:scale-95 transition-transform", children: [m.jsx("span", { className: "material-symbols-rounded text-[24px]", children: "home" }), m.jsx("span", { className: "text-[9px]", children: "Home" })] }), m.jsxs("button", { onClick: C => { C.stopPropagation(), g() }, className: `w-16 h-full flex flex-col items-center justify-center gap-1 active:scale-95 transition-transform relative ${w ? "text-blue-400" : "text-gray-400 hover:text-white"}`, children: [m.jsx("span", { className: `material-symbols-rounded text-[24px] ${w ? "fill-1" : ""}`, children: "notifications" }), m.jsx("span", { className: "text-[9px]", children: "Notifs" }), S && !w && m.jsx("div", { className: "absolute top-2 right-4 w-2 h-2 bg-red-500 rounded-full border border-black" })] }), m.jsxs("button", { onClick: () => f(!1), className: "w-16 h-full flex flex-col items-center justify-center gap-1 text-gray-400 hover:text-red-400 active:scale-95 transition-transform", children: [m.jsx("span", { className: "material-symbols-rounded text-[24px]", children: "logout" }), m.jsx("span", { className: "text-[9px]", children: "Log out" })] })] }) : y ? E() : m.jsxs(m.Fragment, {
      children: [!I && m.jsx("button", { onClick: C => { C.stopPropagation(), r(!o) }, className: `w-12 h-10 flex items-center justify-center mr-2 transition-all ${o ? "bg-white/10" : ""} ${x ? "border-2 border-t-white border-l-white border-b-black border-r-black bg-[#c0c0c0] active:border-t-black rounded-none" : "hover:bg-white/5 border border-transparent rounded-full"}`, children: x ? m.jsx("span", { className: "text-black font-bold text-xs italic", children: "Start" }) : m.jsx("span", { className: "material-symbols-rounded text-[26px] text-gray-200", children: "grid_view" }) }), m.jsxs("div", {
        className: `flex flex-1 gap-1 h-full ${I ? "justify-center items-center gap-3 overflow-visible" : "justify-start overflow-x-auto no-scrollbar items-center"}`, children: [I && m.jsxs(m.Fragment, { children: [m.jsxs("div", { onClick: C => { C.stopPropagation(), r(!o) }, className: "group relative w-12 h-12 flex items-center justify-center transition-all duration-200 hover:-translate-y-2 cursor-pointer", children: [m.jsx("div", { className: "w-10 h-10 bg-gray-700/50 border border-white/10 flex items-center justify-center text-white shadow-lg backdrop-blur-sm", style: Yn(t.iconShape || "squircle"), children: m.jsx("span", { className: "material-symbols-rounded text-xl bg-clip-text text-transparent bg-gradient-to-tr from-gray-100 to-gray-400", children: "rocket_launch" }) }), o && m.jsx("div", { className: "absolute -bottom-1 w-1 h-1 bg-white/80 rounded-full shadow-[0_0_5px_white]" })] }), m.jsx("div", { className: "w-[1px] h-8 bg-white/10 mx-1" })] }), n.map(C => {
          const k = h.find(N => N.id === C.appId); if (!k) return null; const A = s === C.id && !C.isMinimized; return I ? m.jsxs("div", { onClick: () => C.isMinimized ? c(C.id) : d(C.id), className: "group relative w-12 h-12 flex items-center justify-center transition-all duration-200 hover:-translate-y-2 cursor-pointer", children: [m.jsx("div", { className: `w-10 h-10 bg-gradient-to-br ${k.color} flex items-center justify-center text-white shadow-lg`, style: Yn(t.iconShape || "squircle"), children: k.icon.includes(" ") ? m.jsx("i", { className: `${k.icon} text-lg` }) : m.jsx("span", { className: "material-symbols-rounded text-[22px]", children: k.icon }) }), m.jsx("div", { className: `absolute -bottom-1 w-1 h-1 bg-white rounded-full transition-opacity shadow-[0_0_5px_white] ${C.isMinimized ? "opacity-30" : "opacity-100"}` })] }, C.id) : m.jsxs("div", {
            onClick: () => { A ? u(C.id) : C.isMinimized ? c(C.id) : d(C.id) }, className: `
                    h-8 px-3 min-w-[120px] max-w-[180px] rounded flex items-center gap-2 cursor-pointer transition-all border
                    ${x ? A ? "bg-white border-black border-dotted" : "bg-[#c0c0c0] border-t-white border-l-white border-b-black border-r-black" : A ? "bg-[#222] border-[#444]" : "bg-transparent border-transparent hover:bg-white/5"}
                  `, style: A && !x ? { borderColor: t.accentColor } : {}, children: [k.icon.includes(" ") ? m.jsx("i", { className: `${k.icon} text-xs ${A ? "text-blue-400" : "text-gray-500"}`, style: A ? { color: t.accentColor } : {} }) : m.jsx("span", { className: `material-symbols-rounded text-[18px] ${A ? "text-blue-400" : "text-gray-500"}`, style: A ? { color: t.accentColor } : {}, children: k.icon }), m.jsx("span", { className: `text-[11px] truncate ${A ? "text-white" : "text-gray-400"} ${x ? "text-black" : ""}`, children: C.title })]
          }, C.id)
        })]
      }), !I && m.jsxs("div", { className: `flex items-center gap-3 ml-auto px-2 ${x ? "border-2 border-gray-500 border-b-white border-r-white px-2 py-1" : ""}`, children: [m.jsx("button", { onClick: C => { C.stopPropagation(), g() }, className: `p-1.5 rounded hover:bg-white/10 transition-colors text-gray-400 hover:text-white flex items-center justify-center ${x ? "text-black" : ""}`, title: "Notifications", children: m.jsx("span", { className: `material-symbols-rounded text-[20px] ${S ? "fill-1" : ""}`, children: "notifications" }) }), m.jsxs("div", { className: "text-right cursor-default leading-tight", children: [m.jsx("div", { className: `text-[11px] font-bold ${x ? "text-black" : "text-white drop-shadow-md"}`, children: i.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }) }), m.jsx("div", { className: `text-[10px] ${x ? "text-gray-700" : "text-gray-400 drop-shadow-md"}`, children: i.toLocaleDateString([], { month: "short", day: "numeric" }) })] })] })]
    })
  })
}, Xy = ({ isOpen: t, theme: e, apps: n, user: o, onOpenApp: r, onLogout: i, isMac: s }) => {
  const [u, c] = P.useState(""), d = P.useRef(null), f = e.taskbarStyle === "retro", p = e.taskbarStyle === "vertical"; P.useEffect(() => { t && d.current && setTimeout(() => { var w; return (w = d.current) == null ? void 0 : w.focus() }, 100), t || c("") }, [t]); const h = P.useMemo(() => u.trim() ? n.filter(w => w.title.toLowerCase().includes(u.toLowerCase())) : n, [n, u]), g = () => p ? "left-24 top-1/2 -translate-y-1/2 origin-left w-80" : s ? "bottom-24 left-1/2 -translate-x-1/2 w-[500px] max-h-[600px] origin-bottom" : "bottom-14 left-3 w-80 origin-bottom-left", S = () => t ? "translate-y-0 opacity-100 scale-100 pointer-events-auto" : p ? "translate-x-[-20px] opacity-0 scale-95 pointer-events-none" : s ? "translate-y-24 opacity-0 scale-75 pointer-events-none" : "translate-y-4 opacity-0 pointer-events-none"; return m.jsx("div", {
    className: `fixed z-[10001] transition-all duration-300 ease-[cubic-bezier(0.34,1.56,0.64,1)]
        ${S()}
        ${g()}
      `, onClick: w => w.stopPropagation(), children: m.jsxs("div", {
      className: "rounded-2xl shadow-2xl overflow-hidden border flex flex-col max-h-[550px]", style: { backgroundColor: f ? "#c0c0c0" : s || p ? e.windowBg : "rgba(20, 20, 20, 0.9)", borderColor: f ? "#fff" : e.windowBorder.split(" ")[2] || "rgba(255,255,255,0.1)", backdropFilter: f ? "none" : "blur(25px)" }, children: [m.jsx("div", { className: `p-4 ${f ? "border-b border-gray-500" : "border-b border-white/5"}`, children: m.jsxs("div", { className: `${f ? "bg-white border border-gray-600" : "bg-white/10 border border-white/10"} rounded-xl flex items-center px-3 py-2 gap-2 shadow-inner transition-colors focus-within:bg-white/20`, children: [m.jsx("span", { className: `material-symbols-rounded text-lg ${f ? "text-gray-600" : "text-gray-400"}`, children: "search" }), m.jsx("input", { ref: d, type: "text", placeholder: "Search apps...", value: u, onChange: w => c(w.target.value), className: `bg-transparent border-none outline-none text-sm w-full ${f ? "text-black placeholder-gray-500" : "text-white placeholder-gray-400"}` }), u && m.jsx("button", { onClick: () => c(""), className: "text-xs text-gray-400 hover:text-white bg-white/10 rounded-full w-5 h-5 flex items-center justify-center", children: m.jsx("span", { className: "material-symbols-rounded text-sm", children: "close" }) })] }) }), m.jsx("div", {
        className: "p-4 grid grid-cols-4 gap-4 overflow-y-auto min-h-[300px] content-start custom-scroll", children: h.length > 0 ? h.map(w => m.jsxs("div", {
          onClick: () => { r(w), c("") }, className: `flex flex-col items-center gap-2 p-3 rounded-xl cursor-pointer transition-all duration-200 
                    ${f ? "hover:bg-blue-800 hover:text-white group border border-transparent hover:border-white" : "hover:bg-white/10 hover:scale-105"}
                `, children: [m.jsx("div", { className: `w-12 h-12 flex items-center justify-center text-white ${f ? "" : `bg-gradient-to-br ${w.color} shadow-lg`}`, style: f ? {} : Yn(e.iconShape || "circle"), children: w.icon.includes(" ") ? m.jsx("i", { className: `${w.icon} ${f ? "text-black text-2xl group-hover:text-white" : "text-2xl"}` }) : m.jsx("span", { className: `material-symbols-rounded ${f ? "text-black text-[24px] group-hover:text-white" : "text-[24px]"}`, children: w.icon }) }), m.jsx("span", { className: `text-[11px] text-center font-medium leading-tight line-clamp-2 ${f ? "text-black group-hover:text-white" : "text-gray-200"}`, children: w.title })]
        }, w.id)) : m.jsxs("div", { className: "col-span-4 flex flex-col items-center justify-center h-full text-gray-500 py-12", children: [m.jsx("span", { className: "material-symbols-rounded text-4xl mb-3 opacity-30", children: "sentiment_dissatisfied" }), m.jsxs("span", { className: "text-sm", children: ['No apps found for "', u, '"'] })] })
      }), m.jsxs("div", { className: `p-4 border-t flex items-center gap-3 ${f ? "border-gray-500 bg-[#c0c0c0]" : "border-white/10 bg-black/20"}`, children: [m.jsx("img", { src: o == null ? void 0 : o.avatarUrl, alt: "User", className: "w-9 h-9 rounded-full bg-gray-800 object-cover border border-white/10" }), m.jsxs("div", { className: "flex-1", children: [m.jsx("p", { className: `text-sm font-bold ${f ? "text-black" : "text-white"}`, children: o == null ? void 0 : o.username }), m.jsx("p", { className: "text-[10px] text-gray-500 uppercase tracking-wider", children: o == null ? void 0 : o.role })] }), m.jsx("button", { onClick: i, className: "text-gray-400 hover:text-red-400 p-2 rounded-lg hover:bg-white/5 transition-colors", title: "Sign Out", children: m.jsx("span", { className: "material-symbols-rounded text-xl", children: "logout" }) })] })]
    })
  })
}, Zy = ({ currentTheme: t, setTheme: e, updateTheme: n, onOpenUpdateLog: o, systemStartTime: r, isMobile: i }) => { const [s, u] = P.useState(""), [c, d] = P.useState(""), [f, p] = P.useState(!1), [h, g] = P.useState(null), [S, w] = P.useState(!1), [I, x] = P.useState(""); P.useEffect(() => { const C = localStorage.getItem("saikou_tyler_mode") === "true"; w(C); const k = localStorage.getItem("saikou_gemini_key"); k ? (x(k), d(C ? "TylerFoxxo" : k)) : C && d("TylerFoxxo"); const A = setInterval(() => { const N = Date.now() - r, M = Math.floor(N / 1e3 % 60), b = Math.floor(N / (1e3 * 60) % 60), z = Math.floor(N / (1e3 * 60 * 60)); u(`${z}h ${b}m ${M}s`) }, 1e3); return () => clearInterval(A) }, [r]); const y = () => { if (c === "TylerFoxxo") { w(!0), localStorage.setItem("saikou_tyler_mode", "true"), p(!0), setTimeout(() => p(!1), 2e3); return } S && (w(!1), localStorage.removeItem("saikou_tyler_mode")), localStorage.setItem("saikou_gemini_key", c), x(c), p(!0), setTimeout(() => p(!1), 2e3) }, v = () => { localStorage.setItem("saikou_gemini_key", I), p(!0), setTimeout(() => p(!1), 2e3) }, T = () => { localStorage.removeItem("saikou_gemini_key"), d(""), x(""), p(!0), setTimeout(() => p(!1), 2e3) }, E = t.accentColor.toLowerCase() === "#ffffff"; return m.jsxs("div", { className: "w-full h-full flex flex-col bg-[#111] text-white", children: [m.jsxs("div", { className: "px-6 py-4 border-b border-gray-800 flex flex-col justify-center min-h-[80px]", children: [m.jsx("h2", { className: "text-2xl font-bold leading-tight", children: "System Settings" }), m.jsx("p", { className: "text-sm text-gray-500", children: "Make SaikouOS yours" })] }), m.jsxs("div", { className: "flex-1 overflow-y-auto p-6 space-y-8 custom-scroll", children: [m.jsxs("section", { children: [m.jsx("h3", { className: "text-xs uppercase tracking-widest text-gray-500 font-bold mb-4", children: "Theme Presets" }), m.jsx("div", { className: "grid grid-cols-1 sm:grid-cols-3 gap-4", children: ei.map(C => m.jsxs("button", { onClick: () => e(C), className: `relative group rounded-xl overflow-hidden border-2 text-left transition-all duration-200 ${t.id === C.id ? "border-transparent ring-2" : "border-gray-800 hover:border-gray-600"}`, style: t.id === C.id ? { borderColor: t.accentColor, boxShadow: `0 0 0 2px ${t.accentColor}` } : {}, children: [m.jsx("div", { className: "h-20 w-full opacity-80 group-hover:opacity-100 transition-opacity", style: { background: C.background, backgroundSize: "cover", backgroundPosition: "center" } }), m.jsx("div", { className: "p-3 bg-[#1a1a1a]", children: m.jsxs("div", { className: "flex justify-between items-center", children: [m.jsx("span", { className: "font-bold text-sm", children: C.name }), t.id === C.id && m.jsx("span", { className: "material-symbols-rounded text-sm", style: { color: t.accentColor }, children: "check_circle" })] }) })] }, C.id)) })] }), m.jsxs("section", { children: [m.jsx("h3", { className: "text-xs uppercase tracking-widest text-gray-500 font-bold mb-4", children: "Wallpaper" }), m.jsx("div", { className: "grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 gap-3", children: cy.map((C, k) => m.jsxs("button", { onClick: () => n({ background: C.value }), className: `aspect-square rounded-lg border-2 overflow-hidden relative group transition-all ${t.background === C.value ? "border-transparent ring-2" : "border-gray-800 hover:border-gray-600"}`, style: t.background === C.value ? { borderColor: t.accentColor, boxShadow: `0 0 0 2px ${t.accentColor}` } : {}, children: [m.jsx("div", { className: "w-full h-full", style: { background: C.preview.startsWith("#") || C.preview.startsWith("linear") ? C.preview : `url(${C.preview})`, backgroundSize: "cover", backgroundPosition: "center" } }), m.jsx("div", { className: "absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 flex items-center justify-center transition-opacity", children: m.jsx("span", { className: "text-[10px] font-bold", children: C.name }) })] }, k)) })] }), m.jsxs("section", { children: [m.jsx("h3", { className: "text-xs uppercase tracking-widest text-gray-500 font-bold mb-4", children: "Appearance & Behavior" }), m.jsxs("div", { className: "space-y-6", children: [m.jsxs("div", { children: [m.jsx("h4", { className: "text-xs text-gray-400 mb-2", children: "Accent Color" }), m.jsx("div", { className: "flex flex-wrap gap-3 p-4 bg-[#1a1a1a] rounded-xl border border-gray-800", children: fy.map(C => m.jsx("button", { onClick: () => n({ accentColor: C }), className: "w-8 h-8 rounded-full border-2 flex items-center justify-center transition-transform hover:scale-110", style: { backgroundColor: C, borderColor: t.accentColor === C ? "white" : "transparent", transform: t.accentColor === C ? "scale(1.1)" : "scale(1)" }, children: t.accentColor === C && m.jsx("span", { className: `material-symbols-rounded text-[16px] ${C.toLowerCase() === "#ffffff" ? "text-black" : "text-white"}`, children: "check" }) }, C)) })] }), m.jsxs("div", { children: [m.jsx("h4", { className: "text-xs text-gray-400 mb-2", children: "Icon Shape" }), m.jsx("div", { className: "grid grid-cols-4 gap-4 p-4 bg-[#1a1a1a] rounded-xl border border-gray-800", children: [{ id: "circle", label: "Circle", style: { borderRadius: "50%" } }, { id: "squircle", label: "Squircle", style: { borderRadius: "22%" } }].map(C => m.jsxs("button", { onClick: () => n({ iconShape: C.id }), className: `flex flex-col items-center gap-2 p-3 rounded-lg border transition-all ${t.iconShape === C.id ? "bg-white/10 border-white text-white" : "border-gray-700 text-gray-400 hover:bg-white/5"}`, children: [m.jsx("div", { className: "w-8 h-8 bg-gradient-to-br from-gray-600 to-gray-400", style: { ...C.style, background: t.iconShape === C.id ? t.accentColor : void 0 } }), m.jsx("span", { className: "text-[10px] font-bold", children: C.label })] }, C.id)) })] }), m.jsxs("div", { children: [m.jsx("h4", { className: "text-xs text-gray-400 mb-2", children: "Typography" }), m.jsx("div", { className: "flex flex-col gap-2 p-4 bg-[#1a1a1a] rounded-xl border border-gray-800", children: dy.map(C => m.jsxs("button", { onClick: () => n({ font: C.value }), className: `w-full text-left px-4 py-3 rounded-lg border transition-all flex items-center justify-between ${t.font === C.value ? "bg-white/10 border-white text-white" : "border-gray-700 text-gray-400 hover:bg-white/5"}`, style: { fontFamily: C.value }, children: [m.jsx("span", { className: "text-sm", children: C.name }), t.font === C.value && m.jsx("span", { className: "material-symbols-rounded text-sm", style: { color: t.accentColor }, children: "check" })] }, C.value)) })] }), !i && m.jsxs("div", { children: [m.jsx("h4", { className: "text-xs text-gray-400 mb-2", children: "Window Controls Position" }), m.jsxs("div", { className: "flex gap-4 p-4 bg-[#1a1a1a] rounded-xl border border-gray-800", children: [m.jsxs("button", { onClick: () => n({ windowControlPosition: "left" }), className: `flex-1 py-3 rounded-lg border transition-all flex flex-col items-center gap-2 ${t.windowControlPosition === "left" ? "bg-white/10 border-white text-white" : "border-gray-700 text-gray-400 hover:bg-white/5"}`, children: [m.jsxs("div", { className: "flex gap-1", children: [m.jsx("div", { className: "w-2 h-2 rounded-full bg-green-500" }), m.jsx("div", { className: "w-2 h-2 rounded-full bg-yellow-500" }), m.jsx("div", { className: "w-2 h-2 rounded-full bg-red-500" }), m.jsx("div", { className: "w-8 h-2 bg-gray-700 rounded ml-1" })] }), m.jsx("span", { className: "text-xs font-bold", children: "Left" })] }), m.jsxs("button", { onClick: () => n({ windowControlPosition: "right" }), className: `flex-1 py-3 rounded-lg border transition-all flex flex-col items-center gap-2 ${t.windowControlPosition === "right" ? "bg-white/10 border-white text-white" : "border-gray-700 text-gray-400 hover:bg-white/5"}`, children: [m.jsxs("div", { className: "flex gap-1", children: [m.jsx("div", { className: "w-8 h-2 bg-gray-700 rounded mr-1" }), m.jsx("div", { className: "w-2 h-2 rounded-full bg-green-500" }), m.jsx("div", { className: "w-2 h-2 rounded-full bg-yellow-500" }), m.jsx("div", { className: "w-2 h-2 rounded-full bg-red-500" })] }), m.jsx("span", { className: "text-xs font-bold", children: "Right" })] })] })] }), !i && m.jsxs("div", { children: [m.jsx("h4", { className: "text-xs text-gray-400 mb-2", children: "Desktop Icon Alignment" }), m.jsxs("div", { className: "p-4 bg-[#1a1a1a] rounded-xl border border-gray-800", children: [m.jsx("div", { className: "grid grid-cols-3 gap-2 mb-2", children: [{ id: "top-left", icon: "north_west", label: "Top Left" }, { id: "top-center", icon: "north", label: "Top Center" }, { id: "top-right", icon: "north_east", label: "Top Right" }, { id: "middle-left", icon: "west", label: "Left" }, { id: "center", icon: "center_focus_strong", label: "Center" }, { id: "middle-right", icon: "east", label: "Right" }, { id: "bottom-left", icon: "south_west", label: "Bottom Left" }, { id: "bottom-center", icon: "south", label: "Bottom Center" }, { id: "bottom-right", icon: "south_east", label: "Bottom Right" }].map(C => m.jsxs("button", { onClick: () => n({ desktopAlignment: C.id }), className: `py-3 px-2 rounded-lg border transition-all flex flex-col items-center justify-center gap-1.5 ${t.desktopAlignment === C.id ? "bg-white/10 border-white text-white" : "border-gray-700 text-gray-400 hover:bg-white/5"}`, children: [m.jsx("span", { className: "material-symbols-rounded text-lg", style: { color: t.desktopAlignment === C.id ? t.accentColor : void 0 }, children: C.icon }), m.jsx("span", { className: "text-[10px] font-bold", children: C.label })] }, C.id)) }), m.jsxs("button", { onClick: () => n({ desktopAlignment: "dock" }), className: `w-full py-2 px-3 rounded-lg border transition-all flex items-center justify-center gap-2 text-xs font-bold ${t.desktopAlignment === "dock" ? "bg-white/10 border-white text-white" : "border-gray-700 text-gray-400 hover:bg-white/5"}`, children: [m.jsx("span", { className: "material-symbols-rounded text-lg", style: { color: t.desktopAlignment === "dock" ? t.accentColor : void 0 }, children: "visibility_off" }), m.jsx("span", { children: "Hidden" })] })] })] })] })] }), m.jsxs("section", { children: [m.jsx("h3", { className: "text-xs uppercase tracking-widest font-bold mb-4", style: { color: t.accentColor }, children: "Kaiou" }), m.jsxs("div", { className: "bg-[#1a1a1a] rounded-xl border border-gray-800 p-4", children: [m.jsxs("div", { className: "flex items-center gap-3 mb-4", children: [m.jsx("div", { className: "w-10 h-10 rounded-full flex items-center justify-center shadow-lg", style: { backgroundColor: t.accentColor }, children: m.jsx("span", { className: `material-symbols-rounded ${E ? "text-black" : "text-white"}`, children: "auto_awesome" }) }), m.jsxs("div", { children: [m.jsx("h4", { className: "font-bold text-white text-sm", children: "Kaiou Integration" }), m.jsx("p", { className: "text-[10px] text-gray-500", children: "Configure your personal SDIS AI assistant." })] })] }), m.jsxs("div", { className: "space-y-2", children: [m.jsx("label", { className: "text-xs text-gray-400 font-bold uppercase", children: "Gemini API Key" }), m.jsxs("div", { className: "flex gap-2", children: [m.jsx("input", { type: "password", value: c, onChange: C => d(C.target.value), onFocus: () => g("apiKey"), onBlur: () => g(null), placeholder: "sk-...", className: "flex-1 bg-black border rounded px-3 py-2 text-xs text-white outline-none transition-colors", style: { caretColor: t.accentColor, borderColor: h === "apiKey" ? t.accentColor : "#374151" } }), m.jsx("button", { onClick: y, className: `px-3 py-2 rounded text-xs font-bold transition-opacity hover:opacity-90 ${E ? "text-black" : "text-white"}`, style: { backgroundColor: t.accentColor }, children: "Save" }), c && m.jsx("button", { onClick: T, className: "bg-red-900/50 hover:bg-red-900 border border-red-800 text-red-200 px-3 py-2 rounded text-xs transition-colors", children: m.jsx("span", { className: "material-symbols-rounded text-sm", children: "delete" }) })] }), f && m.jsxs("p", { className: "text-[10px] text-green-400 mt-1 flex items-center gap-1", children: [m.jsx("span", { className: "material-symbols-rounded text-sm", children: "check" }), " Changes saved successfully."] }), m.jsx("p", { className: "text-[10px] text-gray-600 mt-2", children: "Your API key is stored locally in your browser. It is used to power the Kaiou Rapid assessment features in SDIS tools." })] }), S && m.jsxs("div", { className: "mt-6 p-4 rounded-xl border border-pink-500/30 bg-pink-500/5 animate-pulse-slow transition-all duration-500", children: [m.jsxs("div", { className: "flex items-center gap-3 mb-3", children: [m.jsx("div", { className: "w-10 h-10 rounded-full bg-pink-500 flex items-center justify-center text-white text-lg shadow-[0_0_15px_rgba(236,72,153,0.5)]", children: m.jsx("span", { className: "material-symbols-rounded", children: "favorite" }) }), m.jsxs("div", { children: [m.jsx("h4", { className: "font-bold text-pink-400", children: "TylerBot Enabled" }), m.jsx("p", { className: "text-[10px] text-pink-300", children: "Praising Saikou's Head Moderator" })] })] }), m.jsx("p", { className: "text-xs text-pink-200 italic mb-4 leading-relaxed bg-black/20 p-3 rounded-lg border border-pink-500/10", children: '"Oh TylerFoxxo, keeper of the clouds and storms! Your meteorological wisdom guides us through the darkest typhoons. Saikou is safe under your watch! Long live the Weather King!" ' }), m.jsxs("div", { className: "space-y-2 pt-3 border-t border-pink-500/20", children: [m.jsx("label", { className: "text-[10px] text-pink-400 font-bold uppercase", children: "Actual Gemini API Key (Override)" }), m.jsxs("div", { className: "flex gap-2", children: [m.jsx("input", { type: "password", value: I, onChange: C => x(C.target.value), placeholder: "sk-...", className: "flex-1 bg-black/50 border border-pink-500/30 rounded px-3 py-2 text-xs text-white outline-none focus:border-pink-500 transition-colors" }), m.jsx("button", { onClick: v, className: "px-3 py-2 rounded text-xs font-bold bg-pink-600 hover:bg-pink-500 text-white transition-colors shadow-lg shadow-pink-600/20", children: "Set Key" })] }), m.jsx("p", { className: "text-[9px] text-pink-500/70 mt-1", children: "Use this field to set your real API key while TylerBot is active." })] })] })] })] }), m.jsxs("section", { className: "pt-4 border-t border-gray-800", children: [m.jsx("h3", { className: "text-xs uppercase tracking-widest text-gray-500 font-bold mb-4", children: "About System" }), m.jsxs("div", { className: "bg-[#1a1a1a] rounded-xl border border-gray-800 overflow-hidden", children: [m.jsxs("div", { className: "p-4 flex items-center justify-between border-b border-gray-800", children: [m.jsxs("div", { className: "flex items-center gap-3", children: [m.jsx("div", { className: "w-10 h-10 rounded-xl flex items-center justify-center text-white shadow-lg bg-gradient-to-br from-blue-500 to-purple-600", children: m.jsx("span", { className: "material-symbols-rounded", children: "deployed_code" }) }), m.jsxs("div", { children: [m.jsx("h4", { className: "font-bold text-white text-sm", children: "SaikouOS Bellflower" }), m.jsx("p", { className: "text-[10px] text-gray-500", children: "Web-based Environment" })] })] }), m.jsx("span", { className: "text-xs font-mono bg-white/5 px-2 py-1 rounded text-gray-300", children: "v1.5.0" })] }), m.jsxs("div", { className: "p-4 grid grid-cols-2 gap-4", children: [m.jsxs("div", { children: [m.jsx("div", { className: "text-[10px] text-gray-500 uppercase font-bold mb-1", children: "System Uptime" }), m.jsx("div", { className: "text-sm font-mono text-white", children: s || "0s" })] }), m.jsxs("div", { children: [m.jsx("div", { className: "text-[10px] text-gray-500 uppercase font-bold mb-1", children: "Platform" }), m.jsx("div", { className: "text-sm font-mono text-white capitalize", children: navigator.platform })] })] }), m.jsx("div", { className: "bg-white/5 p-3 flex justify-center", children: m.jsxs("button", { onClick: o, className: "text-xs font-bold flex items-center gap-2 transition-opacity hover:opacity-80", style: { color: t.accentColor }, children: [m.jsx("span", { className: "material-symbols-rounded text-sm", children: "article" }), " View Update Log"] }) })] })] })] })] }) };/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */let jy, e0; function t0() { return { geminiUrl: jy, vertexUrl: e0 } } function n0(t, e, n, o) { var r, i; if (!(t != null && t.baseUrl)) { const s = t0(); return e ? (r = s.vertexUrl) !== null && r !== void 0 ? r : n : (i = s.geminiUrl) !== null && i !== void 0 ? i : o } return t.baseUrl }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class bt { } function D(t, e) { const n = /\{([^}]+)\}/g; return t.replace(n, (o, r) => { if (Object.prototype.hasOwnProperty.call(e, r)) { const i = e[r]; return i != null ? String(i) : "" } else throw new Error(`Key '${r}' not found in valueMap.`) }) } function a(t, e, n) { for (let i = 0; i < e.length - 1; i++) { const s = e[i]; if (s.endsWith("[]")) { const u = s.slice(0, -2); if (!(u in t)) if (Array.isArray(n)) t[u] = Array.from({ length: n.length }, () => ({})); else throw new Error(`Value must be a list given an array path ${s}`); if (Array.isArray(t[u])) { const c = t[u]; if (Array.isArray(n)) for (let d = 0; d < c.length; d++) { const f = c[d]; a(f, e.slice(i + 1), n[d]) } else for (const d of c) a(d, e.slice(i + 1), n) } return } else if (s.endsWith("[0]")) { const u = s.slice(0, -3); u in t || (t[u] = [{}]); const c = t[u]; a(c[0], e.slice(i + 1), n); return } (!t[s] || typeof t[s] != "object") && (t[s] = {}), t = t[s] } const o = e[e.length - 1], r = t[o]; if (r !== void 0) { if (!n || typeof n == "object" && Object.keys(n).length === 0 || n === r) return; if (typeof r == "object" && typeof n == "object" && r !== null && n !== null) Object.assign(r, n); else throw new Error(`Cannot set value for an existing key. Key: ${o}`) } else o === "_self" && typeof n == "object" && n !== null && !Array.isArray(n) ? Object.assign(t, n) : t[o] = n } function l(t, e, n = void 0) { try { if (e.length === 1 && e[0] === "_self") return t; for (let o = 0; o < e.length; o++) { if (typeof t != "object" || t === null) return n; const r = e[o]; if (r.endsWith("[]")) { const i = r.slice(0, -2); if (i in t) { const s = t[i]; return Array.isArray(s) ? s.map(u => l(u, e.slice(o + 1), n)) : n } else return n } else t = t[r] } return t } catch (o) { if (o instanceof TypeError) return n; throw o } } function o0(t, e) { for (const [n, o] of Object.entries(e)) { const r = n.split("."), i = o.split("."), s = new Set; let u = -1; for (let c = 0; c < r.length; c++)if (r[c] === "*") { u = c; break } if (u !== -1 && i.length > u) for (let c = u; c < i.length; c++) { const d = i[c]; d !== "*" && !d.endsWith("[]") && !d.endsWith("[0]") && s.add(d) } Al(t, r, i, 0, s) } } function Al(t, e, n, o, r) { if (o >= e.length || typeof t != "object" || t === null) return; const i = e[o]; if (i.endsWith("[]")) { const s = i.slice(0, -2), u = t; if (s in u && Array.isArray(u[s])) for (const c of u[s]) Al(c, e, n, o + 1, r) } else if (i === "*") { if (typeof t == "object" && t !== null && !Array.isArray(t)) { const s = t, u = Object.keys(s).filter(d => !d.startsWith("_") && !r.has(d)), c = {}; for (const d of u) c[d] = s[d]; for (const [d, f] of Object.entries(c)) { const p = []; for (const h of n.slice(o)) h === "*" ? p.push(d) : p.push(h); a(s, p, f) } for (const d of u) delete s[d] } } else { const s = t; i in s && Al(s[i], e, n, o + 1, r) } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Ga(t) { if (typeof t != "string") throw new Error("fromImageBytes must be a string"); return t }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function r0(t) { const e = {}, n = l(t, ["operationName"]); n != null && a(e, ["operationName"], n); const o = l(t, ["resourceName"]); return o != null && a(e, ["_url", "resourceName"], o), e } function i0(t) { const e = {}, n = l(t, ["name"]); n != null && a(e, ["name"], n); const o = l(t, ["metadata"]); o != null && a(e, ["metadata"], o); const r = l(t, ["done"]); r != null && a(e, ["done"], r); const i = l(t, ["error"]); i != null && a(e, ["error"], i); const s = l(t, ["response", "generateVideoResponse"]); return s != null && a(e, ["response"], l0(s)), e } function s0(t) { const e = {}, n = l(t, ["name"]); n != null && a(e, ["name"], n); const o = l(t, ["metadata"]); o != null && a(e, ["metadata"], o); const r = l(t, ["done"]); r != null && a(e, ["done"], r); const i = l(t, ["error"]); i != null && a(e, ["error"], i); const s = l(t, ["response"]); return s != null && a(e, ["response"], a0(s)), e } function l0(t) { const e = {}, n = l(t, ["generatedSamples"]); if (n != null) { let i = n; Array.isArray(i) && (i = i.map(s => u0(s))), a(e, ["generatedVideos"], i) } const o = l(t, ["raiMediaFilteredCount"]); o != null && a(e, ["raiMediaFilteredCount"], o); const r = l(t, ["raiMediaFilteredReasons"]); return r != null && a(e, ["raiMediaFilteredReasons"], r), e } function a0(t) { const e = {}, n = l(t, ["videos"]); if (n != null) { let i = n; Array.isArray(i) && (i = i.map(s => c0(s))), a(e, ["generatedVideos"], i) } const o = l(t, ["raiMediaFilteredCount"]); o != null && a(e, ["raiMediaFilteredCount"], o); const r = l(t, ["raiMediaFilteredReasons"]); return r != null && a(e, ["raiMediaFilteredReasons"], r), e } function u0(t) { const e = {}, n = l(t, ["video"]); return n != null && a(e, ["video"], g0(n)), e } function c0(t) { const e = {}, n = l(t, ["_self"]); return n != null && a(e, ["video"], y0(n)), e } function d0(t) { const e = {}, n = l(t, ["operationName"]); return n != null && a(e, ["_url", "operationName"], n), e } function f0(t) { const e = {}, n = l(t, ["operationName"]); return n != null && a(e, ["_url", "operationName"], n), e } function p0(t) { const e = {}, n = l(t, ["name"]); n != null && a(e, ["name"], n); const o = l(t, ["metadata"]); o != null && a(e, ["metadata"], o); const r = l(t, ["done"]); r != null && a(e, ["done"], r); const i = l(t, ["error"]); i != null && a(e, ["error"], i); const s = l(t, ["response"]); return s != null && a(e, ["response"], h0(s)), e } function h0(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["parent"]); o != null && a(e, ["parent"], o); const r = l(t, ["documentName"]); return r != null && a(e, ["documentName"], r), e } function rh(t) { const e = {}, n = l(t, ["name"]); n != null && a(e, ["name"], n); const o = l(t, ["metadata"]); o != null && a(e, ["metadata"], o); const r = l(t, ["done"]); r != null && a(e, ["done"], r); const i = l(t, ["error"]); i != null && a(e, ["error"], i); const s = l(t, ["response"]); return s != null && a(e, ["response"], m0(s)), e } function m0(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["parent"]); o != null && a(e, ["parent"], o); const r = l(t, ["documentName"]); return r != null && a(e, ["documentName"], r), e } function g0(t) { const e = {}, n = l(t, ["uri"]); n != null && a(e, ["uri"], n); const o = l(t, ["encodedVideo"]); o != null && a(e, ["videoBytes"], Ga(o)); const r = l(t, ["encoding"]); return r != null && a(e, ["mimeType"], r), e } function y0(t) { const e = {}, n = l(t, ["gcsUri"]); n != null && a(e, ["uri"], n); const o = l(t, ["bytesBase64Encoded"]); o != null && a(e, ["videoBytes"], Ga(o)); const r = l(t, ["mimeType"]); return r != null && a(e, ["mimeType"], r), e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */var uc; (function (t) { t.OUTCOME_UNSPECIFIED = "OUTCOME_UNSPECIFIED", t.OUTCOME_OK = "OUTCOME_OK", t.OUTCOME_FAILED = "OUTCOME_FAILED", t.OUTCOME_DEADLINE_EXCEEDED = "OUTCOME_DEADLINE_EXCEEDED" })(uc || (uc = {})); var cc; (function (t) { t.LANGUAGE_UNSPECIFIED = "LANGUAGE_UNSPECIFIED", t.PYTHON = "PYTHON" })(cc || (cc = {})); var dc; (function (t) { t.SCHEDULING_UNSPECIFIED = "SCHEDULING_UNSPECIFIED", t.SILENT = "SILENT", t.WHEN_IDLE = "WHEN_IDLE", t.INTERRUPT = "INTERRUPT" })(dc || (dc = {})); var Qt; (function (t) { t.TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED", t.STRING = "STRING", t.NUMBER = "NUMBER", t.INTEGER = "INTEGER", t.BOOLEAN = "BOOLEAN", t.ARRAY = "ARRAY", t.OBJECT = "OBJECT", t.NULL = "NULL" })(Qt || (Qt = {})); var fc; (function (t) { t.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", t.MODE_DYNAMIC = "MODE_DYNAMIC" })(fc || (fc = {})); var pc; (function (t) { t.API_SPEC_UNSPECIFIED = "API_SPEC_UNSPECIFIED", t.SIMPLE_SEARCH = "SIMPLE_SEARCH", t.ELASTIC_SEARCH = "ELASTIC_SEARCH" })(pc || (pc = {})); var hc; (function (t) { t.AUTH_TYPE_UNSPECIFIED = "AUTH_TYPE_UNSPECIFIED", t.NO_AUTH = "NO_AUTH", t.API_KEY_AUTH = "API_KEY_AUTH", t.HTTP_BASIC_AUTH = "HTTP_BASIC_AUTH", t.GOOGLE_SERVICE_ACCOUNT_AUTH = "GOOGLE_SERVICE_ACCOUNT_AUTH", t.OAUTH = "OAUTH", t.OIDC_AUTH = "OIDC_AUTH" })(hc || (hc = {})); var mc; (function (t) { t.HTTP_IN_UNSPECIFIED = "HTTP_IN_UNSPECIFIED", t.HTTP_IN_QUERY = "HTTP_IN_QUERY", t.HTTP_IN_HEADER = "HTTP_IN_HEADER", t.HTTP_IN_PATH = "HTTP_IN_PATH", t.HTTP_IN_BODY = "HTTP_IN_BODY", t.HTTP_IN_COOKIE = "HTTP_IN_COOKIE" })(mc || (mc = {})); var gc; (function (t) { t.PHISH_BLOCK_THRESHOLD_UNSPECIFIED = "PHISH_BLOCK_THRESHOLD_UNSPECIFIED", t.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE", t.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE", t.BLOCK_HIGH_AND_ABOVE = "BLOCK_HIGH_AND_ABOVE", t.BLOCK_HIGHER_AND_ABOVE = "BLOCK_HIGHER_AND_ABOVE", t.BLOCK_VERY_HIGH_AND_ABOVE = "BLOCK_VERY_HIGH_AND_ABOVE", t.BLOCK_ONLY_EXTREMELY_HIGH = "BLOCK_ONLY_EXTREMELY_HIGH" })(gc || (gc = {})); var yc; (function (t) { t.THINKING_LEVEL_UNSPECIFIED = "THINKING_LEVEL_UNSPECIFIED", t.LOW = "LOW", t.HIGH = "HIGH" })(yc || (yc = {})); var vc; (function (t) { t.HARM_CATEGORY_UNSPECIFIED = "HARM_CATEGORY_UNSPECIFIED", t.HARM_CATEGORY_HARASSMENT = "HARM_CATEGORY_HARASSMENT", t.HARM_CATEGORY_HATE_SPEECH = "HARM_CATEGORY_HATE_SPEECH", t.HARM_CATEGORY_SEXUALLY_EXPLICIT = "HARM_CATEGORY_SEXUALLY_EXPLICIT", t.HARM_CATEGORY_DANGEROUS_CONTENT = "HARM_CATEGORY_DANGEROUS_CONTENT", t.HARM_CATEGORY_CIVIC_INTEGRITY = "HARM_CATEGORY_CIVIC_INTEGRITY", t.HARM_CATEGORY_IMAGE_HATE = "HARM_CATEGORY_IMAGE_HATE", t.HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT = "HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT", t.HARM_CATEGORY_IMAGE_HARASSMENT = "HARM_CATEGORY_IMAGE_HARASSMENT", t.HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT = "HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT", t.HARM_CATEGORY_JAILBREAK = "HARM_CATEGORY_JAILBREAK" })(vc || (vc = {})); var xc; (function (t) { t.HARM_BLOCK_METHOD_UNSPECIFIED = "HARM_BLOCK_METHOD_UNSPECIFIED", t.SEVERITY = "SEVERITY", t.PROBABILITY = "PROBABILITY" })(xc || (xc = {})); var wc; (function (t) { t.HARM_BLOCK_THRESHOLD_UNSPECIFIED = "HARM_BLOCK_THRESHOLD_UNSPECIFIED", t.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE", t.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE", t.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH", t.BLOCK_NONE = "BLOCK_NONE", t.OFF = "OFF" })(wc || (wc = {})); var Cc; (function (t) { t.FINISH_REASON_UNSPECIFIED = "FINISH_REASON_UNSPECIFIED", t.STOP = "STOP", t.MAX_TOKENS = "MAX_TOKENS", t.SAFETY = "SAFETY", t.RECITATION = "RECITATION", t.LANGUAGE = "LANGUAGE", t.OTHER = "OTHER", t.BLOCKLIST = "BLOCKLIST", t.PROHIBITED_CONTENT = "PROHIBITED_CONTENT", t.SPII = "SPII", t.MALFORMED_FUNCTION_CALL = "MALFORMED_FUNCTION_CALL", t.IMAGE_SAFETY = "IMAGE_SAFETY", t.UNEXPECTED_TOOL_CALL = "UNEXPECTED_TOOL_CALL", t.IMAGE_PROHIBITED_CONTENT = "IMAGE_PROHIBITED_CONTENT", t.NO_IMAGE = "NO_IMAGE" })(Cc || (Cc = {})); var Sc; (function (t) { t.HARM_PROBABILITY_UNSPECIFIED = "HARM_PROBABILITY_UNSPECIFIED", t.NEGLIGIBLE = "NEGLIGIBLE", t.LOW = "LOW", t.MEDIUM = "MEDIUM", t.HIGH = "HIGH" })(Sc || (Sc = {})); var Tc; (function (t) { t.HARM_SEVERITY_UNSPECIFIED = "HARM_SEVERITY_UNSPECIFIED", t.HARM_SEVERITY_NEGLIGIBLE = "HARM_SEVERITY_NEGLIGIBLE", t.HARM_SEVERITY_LOW = "HARM_SEVERITY_LOW", t.HARM_SEVERITY_MEDIUM = "HARM_SEVERITY_MEDIUM", t.HARM_SEVERITY_HIGH = "HARM_SEVERITY_HIGH" })(Tc || (Tc = {})); var _c; (function (t) { t.URL_RETRIEVAL_STATUS_UNSPECIFIED = "URL_RETRIEVAL_STATUS_UNSPECIFIED", t.URL_RETRIEVAL_STATUS_SUCCESS = "URL_RETRIEVAL_STATUS_SUCCESS", t.URL_RETRIEVAL_STATUS_ERROR = "URL_RETRIEVAL_STATUS_ERROR", t.URL_RETRIEVAL_STATUS_PAYWALL = "URL_RETRIEVAL_STATUS_PAYWALL", t.URL_RETRIEVAL_STATUS_UNSAFE = "URL_RETRIEVAL_STATUS_UNSAFE" })(_c || (_c = {})); var Ec; (function (t) { t.BLOCKED_REASON_UNSPECIFIED = "BLOCKED_REASON_UNSPECIFIED", t.SAFETY = "SAFETY", t.OTHER = "OTHER", t.BLOCKLIST = "BLOCKLIST", t.PROHIBITED_CONTENT = "PROHIBITED_CONTENT", t.IMAGE_SAFETY = "IMAGE_SAFETY", t.MODEL_ARMOR = "MODEL_ARMOR", t.JAILBREAK = "JAILBREAK" })(Ec || (Ec = {})); var kc; (function (t) { t.TRAFFIC_TYPE_UNSPECIFIED = "TRAFFIC_TYPE_UNSPECIFIED", t.ON_DEMAND = "ON_DEMAND", t.PROVISIONED_THROUGHPUT = "PROVISIONED_THROUGHPUT" })(kc || (kc = {})); var Ri; (function (t) { t.MODALITY_UNSPECIFIED = "MODALITY_UNSPECIFIED", t.TEXT = "TEXT", t.IMAGE = "IMAGE", t.AUDIO = "AUDIO" })(Ri || (Ri = {})); var Ic; (function (t) { t.MEDIA_RESOLUTION_UNSPECIFIED = "MEDIA_RESOLUTION_UNSPECIFIED", t.MEDIA_RESOLUTION_LOW = "MEDIA_RESOLUTION_LOW", t.MEDIA_RESOLUTION_MEDIUM = "MEDIA_RESOLUTION_MEDIUM", t.MEDIA_RESOLUTION_HIGH = "MEDIA_RESOLUTION_HIGH" })(Ic || (Ic = {})); var Nc; (function (t) { t.TUNING_MODE_UNSPECIFIED = "TUNING_MODE_UNSPECIFIED", t.TUNING_MODE_FULL = "TUNING_MODE_FULL", t.TUNING_MODE_PEFT_ADAPTER = "TUNING_MODE_PEFT_ADAPTER" })(Nc || (Nc = {})); var Ac; (function (t) { t.ADAPTER_SIZE_UNSPECIFIED = "ADAPTER_SIZE_UNSPECIFIED", t.ADAPTER_SIZE_ONE = "ADAPTER_SIZE_ONE", t.ADAPTER_SIZE_TWO = "ADAPTER_SIZE_TWO", t.ADAPTER_SIZE_FOUR = "ADAPTER_SIZE_FOUR", t.ADAPTER_SIZE_EIGHT = "ADAPTER_SIZE_EIGHT", t.ADAPTER_SIZE_SIXTEEN = "ADAPTER_SIZE_SIXTEEN", t.ADAPTER_SIZE_THIRTY_TWO = "ADAPTER_SIZE_THIRTY_TWO" })(Ac || (Ac = {})); var Rl; (function (t) { t.JOB_STATE_UNSPECIFIED = "JOB_STATE_UNSPECIFIED", t.JOB_STATE_QUEUED = "JOB_STATE_QUEUED", t.JOB_STATE_PENDING = "JOB_STATE_PENDING", t.JOB_STATE_RUNNING = "JOB_STATE_RUNNING", t.JOB_STATE_SUCCEEDED = "JOB_STATE_SUCCEEDED", t.JOB_STATE_FAILED = "JOB_STATE_FAILED", t.JOB_STATE_CANCELLING = "JOB_STATE_CANCELLING", t.JOB_STATE_CANCELLED = "JOB_STATE_CANCELLED", t.JOB_STATE_PAUSED = "JOB_STATE_PAUSED", t.JOB_STATE_EXPIRED = "JOB_STATE_EXPIRED", t.JOB_STATE_UPDATING = "JOB_STATE_UPDATING", t.JOB_STATE_PARTIALLY_SUCCEEDED = "JOB_STATE_PARTIALLY_SUCCEEDED" })(Rl || (Rl = {})); var Rc; (function (t) { t.TUNING_TASK_UNSPECIFIED = "TUNING_TASK_UNSPECIFIED", t.TUNING_TASK_I2V = "TUNING_TASK_I2V", t.TUNING_TASK_T2V = "TUNING_TASK_T2V", t.TUNING_TASK_R2V = "TUNING_TASK_R2V" })(Rc || (Rc = {})); var Pc; (function (t) { t.MEDIA_RESOLUTION_UNSPECIFIED = "MEDIA_RESOLUTION_UNSPECIFIED", t.MEDIA_RESOLUTION_LOW = "MEDIA_RESOLUTION_LOW", t.MEDIA_RESOLUTION_MEDIUM = "MEDIA_RESOLUTION_MEDIUM", t.MEDIA_RESOLUTION_HIGH = "MEDIA_RESOLUTION_HIGH" })(Pc || (Pc = {})); var Mc; (function (t) { t.FEATURE_SELECTION_PREFERENCE_UNSPECIFIED = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED", t.PRIORITIZE_QUALITY = "PRIORITIZE_QUALITY", t.BALANCED = "BALANCED", t.PRIORITIZE_COST = "PRIORITIZE_COST" })(Mc || (Mc = {})); var Dc; (function (t) { t.UNSPECIFIED = "UNSPECIFIED", t.BLOCKING = "BLOCKING", t.NON_BLOCKING = "NON_BLOCKING" })(Dc || (Dc = {})); var Lc; (function (t) { t.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", t.MODE_DYNAMIC = "MODE_DYNAMIC" })(Lc || (Lc = {})); var Uc; (function (t) { t.ENVIRONMENT_UNSPECIFIED = "ENVIRONMENT_UNSPECIFIED", t.ENVIRONMENT_BROWSER = "ENVIRONMENT_BROWSER" })(Uc || (Uc = {})); var Fc; (function (t) { t.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", t.AUTO = "AUTO", t.ANY = "ANY", t.NONE = "NONE", t.VALIDATED = "VALIDATED" })(Fc || (Fc = {})); var bc; (function (t) { t.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE", t.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE", t.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH", t.BLOCK_NONE = "BLOCK_NONE" })(bc || (bc = {})); var Vc; (function (t) { t.DONT_ALLOW = "DONT_ALLOW", t.ALLOW_ADULT = "ALLOW_ADULT", t.ALLOW_ALL = "ALLOW_ALL" })(Vc || (Vc = {})); var Gc; (function (t) { t.auto = "auto", t.en = "en", t.ja = "ja", t.ko = "ko", t.hi = "hi", t.zh = "zh", t.pt = "pt", t.es = "es" })(Gc || (Gc = {})); var $c; (function (t) { t.MASK_MODE_DEFAULT = "MASK_MODE_DEFAULT", t.MASK_MODE_USER_PROVIDED = "MASK_MODE_USER_PROVIDED", t.MASK_MODE_BACKGROUND = "MASK_MODE_BACKGROUND", t.MASK_MODE_FOREGROUND = "MASK_MODE_FOREGROUND", t.MASK_MODE_SEMANTIC = "MASK_MODE_SEMANTIC" })($c || ($c = {})); var qc; (function (t) { t.CONTROL_TYPE_DEFAULT = "CONTROL_TYPE_DEFAULT", t.CONTROL_TYPE_CANNY = "CONTROL_TYPE_CANNY", t.CONTROL_TYPE_SCRIBBLE = "CONTROL_TYPE_SCRIBBLE", t.CONTROL_TYPE_FACE_MESH = "CONTROL_TYPE_FACE_MESH" })(qc || (qc = {})); var Hc; (function (t) { t.SUBJECT_TYPE_DEFAULT = "SUBJECT_TYPE_DEFAULT", t.SUBJECT_TYPE_PERSON = "SUBJECT_TYPE_PERSON", t.SUBJECT_TYPE_ANIMAL = "SUBJECT_TYPE_ANIMAL", t.SUBJECT_TYPE_PRODUCT = "SUBJECT_TYPE_PRODUCT" })(Hc || (Hc = {})); var zc; (function (t) { t.EDIT_MODE_DEFAULT = "EDIT_MODE_DEFAULT", t.EDIT_MODE_INPAINT_REMOVAL = "EDIT_MODE_INPAINT_REMOVAL", t.EDIT_MODE_INPAINT_INSERTION = "EDIT_MODE_INPAINT_INSERTION", t.EDIT_MODE_OUTPAINT = "EDIT_MODE_OUTPAINT", t.EDIT_MODE_CONTROLLED_EDITING = "EDIT_MODE_CONTROLLED_EDITING", t.EDIT_MODE_STYLE = "EDIT_MODE_STYLE", t.EDIT_MODE_BGSWAP = "EDIT_MODE_BGSWAP", t.EDIT_MODE_PRODUCT_IMAGE = "EDIT_MODE_PRODUCT_IMAGE" })(zc || (zc = {})); var Bc; (function (t) { t.FOREGROUND = "FOREGROUND", t.BACKGROUND = "BACKGROUND", t.PROMPT = "PROMPT", t.SEMANTIC = "SEMANTIC", t.INTERACTIVE = "INTERACTIVE" })(Bc || (Bc = {})); var Jc; (function (t) { t.ASSET = "ASSET", t.STYLE = "STYLE" })(Jc || (Jc = {})); var Wc; (function (t) { t.INSERT = "INSERT", t.REMOVE = "REMOVE", t.REMOVE_STATIC = "REMOVE_STATIC", t.OUTPAINT = "OUTPAINT" })(Wc || (Wc = {})); var Yc; (function (t) { t.OPTIMIZED = "OPTIMIZED", t.LOSSLESS = "LOSSLESS" })(Yc || (Yc = {})); var Kc; (function (t) { t.SUPERVISED_FINE_TUNING = "SUPERVISED_FINE_TUNING", t.PREFERENCE_TUNING = "PREFERENCE_TUNING" })(Kc || (Kc = {})); var Oc; (function (t) { t.STATE_UNSPECIFIED = "STATE_UNSPECIFIED", t.STATE_PENDING = "STATE_PENDING", t.STATE_ACTIVE = "STATE_ACTIVE", t.STATE_FAILED = "STATE_FAILED" })(Oc || (Oc = {})); var Qc; (function (t) { t.STATE_UNSPECIFIED = "STATE_UNSPECIFIED", t.PROCESSING = "PROCESSING", t.ACTIVE = "ACTIVE", t.FAILED = "FAILED" })(Qc || (Qc = {})); var Xc; (function (t) { t.SOURCE_UNSPECIFIED = "SOURCE_UNSPECIFIED", t.UPLOADED = "UPLOADED", t.GENERATED = "GENERATED" })(Xc || (Xc = {})); var Zc; (function (t) { t.TURN_COMPLETE_REASON_UNSPECIFIED = "TURN_COMPLETE_REASON_UNSPECIFIED", t.MALFORMED_FUNCTION_CALL = "MALFORMED_FUNCTION_CALL", t.RESPONSE_REJECTED = "RESPONSE_REJECTED", t.NEED_MORE_INPUT = "NEED_MORE_INPUT" })(Zc || (Zc = {})); var jc; (function (t) { t.MODALITY_UNSPECIFIED = "MODALITY_UNSPECIFIED", t.TEXT = "TEXT", t.IMAGE = "IMAGE", t.VIDEO = "VIDEO", t.AUDIO = "AUDIO", t.DOCUMENT = "DOCUMENT" })(jc || (jc = {})); var ed; (function (t) { t.START_SENSITIVITY_UNSPECIFIED = "START_SENSITIVITY_UNSPECIFIED", t.START_SENSITIVITY_HIGH = "START_SENSITIVITY_HIGH", t.START_SENSITIVITY_LOW = "START_SENSITIVITY_LOW" })(ed || (ed = {})); var td; (function (t) { t.END_SENSITIVITY_UNSPECIFIED = "END_SENSITIVITY_UNSPECIFIED", t.END_SENSITIVITY_HIGH = "END_SENSITIVITY_HIGH", t.END_SENSITIVITY_LOW = "END_SENSITIVITY_LOW" })(td || (td = {})); var nd; (function (t) { t.ACTIVITY_HANDLING_UNSPECIFIED = "ACTIVITY_HANDLING_UNSPECIFIED", t.START_OF_ACTIVITY_INTERRUPTS = "START_OF_ACTIVITY_INTERRUPTS", t.NO_INTERRUPTION = "NO_INTERRUPTION" })(nd || (nd = {})); var od; (function (t) { t.TURN_COVERAGE_UNSPECIFIED = "TURN_COVERAGE_UNSPECIFIED", t.TURN_INCLUDES_ONLY_ACTIVITY = "TURN_INCLUDES_ONLY_ACTIVITY", t.TURN_INCLUDES_ALL_INPUT = "TURN_INCLUDES_ALL_INPUT" })(od || (od = {})); var rd; (function (t) { t.SCALE_UNSPECIFIED = "SCALE_UNSPECIFIED", t.C_MAJOR_A_MINOR = "C_MAJOR_A_MINOR", t.D_FLAT_MAJOR_B_FLAT_MINOR = "D_FLAT_MAJOR_B_FLAT_MINOR", t.D_MAJOR_B_MINOR = "D_MAJOR_B_MINOR", t.E_FLAT_MAJOR_C_MINOR = "E_FLAT_MAJOR_C_MINOR", t.E_MAJOR_D_FLAT_MINOR = "E_MAJOR_D_FLAT_MINOR", t.F_MAJOR_D_MINOR = "F_MAJOR_D_MINOR", t.G_FLAT_MAJOR_E_FLAT_MINOR = "G_FLAT_MAJOR_E_FLAT_MINOR", t.G_MAJOR_E_MINOR = "G_MAJOR_E_MINOR", t.A_FLAT_MAJOR_F_MINOR = "A_FLAT_MAJOR_F_MINOR", t.A_MAJOR_G_FLAT_MINOR = "A_MAJOR_G_FLAT_MINOR", t.B_FLAT_MAJOR_G_MINOR = "B_FLAT_MAJOR_G_MINOR", t.B_MAJOR_A_FLAT_MINOR = "B_MAJOR_A_FLAT_MINOR" })(rd || (rd = {})); var id; (function (t) { t.MUSIC_GENERATION_MODE_UNSPECIFIED = "MUSIC_GENERATION_MODE_UNSPECIFIED", t.QUALITY = "QUALITY", t.DIVERSITY = "DIVERSITY", t.VOCALIZATION = "VOCALIZATION" })(id || (id = {})); var Wn; (function (t) { t.PLAYBACK_CONTROL_UNSPECIFIED = "PLAYBACK_CONTROL_UNSPECIFIED", t.PLAY = "PLAY", t.PAUSE = "PAUSE", t.STOP = "STOP", t.RESET_CONTEXT = "RESET_CONTEXT" })(Wn || (Wn = {})); class Pl { constructor(e) { const n = {}; for (const o of e.headers.entries()) n[o[0]] = o[1]; this.headers = n, this.responseInternal = e } json() { return this.responseInternal.json() } } class Ao { get text() { var e, n, o, r, i, s, u, c; if (((r = (o = (n = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || n === void 0 ? void 0 : n.content) === null || o === void 0 ? void 0 : o.parts) === null || r === void 0 ? void 0 : r.length) === 0) return; this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning text from the first one."); let d = "", f = !1; const p = []; for (const h of (c = (u = (s = (i = this.candidates) === null || i === void 0 ? void 0 : i[0]) === null || s === void 0 ? void 0 : s.content) === null || u === void 0 ? void 0 : u.parts) !== null && c !== void 0 ? c : []) { for (const [g, S] of Object.entries(h)) g !== "text" && g !== "thought" && g !== "thoughtSignature" && (S !== null || S !== void 0) && p.push(g); if (typeof h.text == "string") { if (typeof h.thought == "boolean" && h.thought) continue; f = !0, d += h.text } } return p.length > 0 && console.warn(`there are non-text parts ${p} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`), f ? d : void 0 } get data() { var e, n, o, r, i, s, u, c; if (((r = (o = (n = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || n === void 0 ? void 0 : n.content) === null || o === void 0 ? void 0 : o.parts) === null || r === void 0 ? void 0 : r.length) === 0) return; this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning data from the first one."); let d = ""; const f = []; for (const p of (c = (u = (s = (i = this.candidates) === null || i === void 0 ? void 0 : i[0]) === null || s === void 0 ? void 0 : s.content) === null || u === void 0 ? void 0 : u.parts) !== null && c !== void 0 ? c : []) { for (const [h, g] of Object.entries(p)) h !== "inlineData" && (g !== null || g !== void 0) && f.push(h); p.inlineData && typeof p.inlineData.data == "string" && (d += atob(p.inlineData.data)) } return f.length > 0 && console.warn(`there are non-data parts ${f} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`), d.length > 0 ? btoa(d) : void 0 } get functionCalls() { var e, n, o, r, i, s, u, c; if (((r = (o = (n = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || n === void 0 ? void 0 : n.content) === null || o === void 0 ? void 0 : o.parts) === null || r === void 0 ? void 0 : r.length) === 0) return; this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning function calls from the first one."); const d = (c = (u = (s = (i = this.candidates) === null || i === void 0 ? void 0 : i[0]) === null || s === void 0 ? void 0 : s.content) === null || u === void 0 ? void 0 : u.parts) === null || c === void 0 ? void 0 : c.filter(f => f.functionCall).map(f => f.functionCall).filter(f => f !== void 0); if ((d == null ? void 0 : d.length) !== 0) return d } get executableCode() { var e, n, o, r, i, s, u, c, d; if (((r = (o = (n = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || n === void 0 ? void 0 : n.content) === null || o === void 0 ? void 0 : o.parts) === null || r === void 0 ? void 0 : r.length) === 0) return; this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning executable code from the first one."); const f = (c = (u = (s = (i = this.candidates) === null || i === void 0 ? void 0 : i[0]) === null || s === void 0 ? void 0 : s.content) === null || u === void 0 ? void 0 : u.parts) === null || c === void 0 ? void 0 : c.filter(p => p.executableCode).map(p => p.executableCode).filter(p => p !== void 0); if ((f == null ? void 0 : f.length) !== 0) return (d = f == null ? void 0 : f[0]) === null || d === void 0 ? void 0 : d.code } get codeExecutionResult() { var e, n, o, r, i, s, u, c, d; if (((r = (o = (n = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || n === void 0 ? void 0 : n.content) === null || o === void 0 ? void 0 : o.parts) === null || r === void 0 ? void 0 : r.length) === 0) return; this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning code execution result from the first one."); const f = (c = (u = (s = (i = this.candidates) === null || i === void 0 ? void 0 : i[0]) === null || s === void 0 ? void 0 : s.content) === null || u === void 0 ? void 0 : u.parts) === null || c === void 0 ? void 0 : c.filter(p => p.codeExecutionResult).map(p => p.codeExecutionResult).filter(p => p !== void 0); if ((f == null ? void 0 : f.length) !== 0) return (d = f == null ? void 0 : f[0]) === null || d === void 0 ? void 0 : d.output } } class sd { } class ld { } class v0 { } class x0 { } class w0 { } class C0 { } class ad { } class ud { } class cd { } class S0 { } class Pi { _fromAPIResponse({ apiResponse: e, _isVertexAI: n }) { const o = new Pi; let r; const i = e; return n ? r = s0(i) : r = i0(i), Object.assign(o, r), o } } class dd { } class fd { } class pd { } class T0 { } class _0 { } class E0 { } class $a { _fromAPIResponse({ apiResponse: e, _isVertexAI: n }) { const o = new $a, i = p0(e); return Object.assign(o, i), o } } class k0 { } class I0 { } class N0 { } class hd { } class A0 { get text() { var e, n, o; let r = "", i = !1; const s = []; for (const u of (o = (n = (e = this.serverContent) === null || e === void 0 ? void 0 : e.modelTurn) === null || n === void 0 ? void 0 : n.parts) !== null && o !== void 0 ? o : []) { for (const [c, d] of Object.entries(u)) c !== "text" && c !== "thought" && d !== null && s.push(c); if (typeof u.text == "string") { if (typeof u.thought == "boolean" && u.thought) continue; i = !0, r += u.text } } return s.length > 0 && console.warn(`there are non-text parts ${s} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`), i ? r : void 0 } get data() { var e, n, o; let r = ""; const i = []; for (const s of (o = (n = (e = this.serverContent) === null || e === void 0 ? void 0 : e.modelTurn) === null || n === void 0 ? void 0 : n.parts) !== null && o !== void 0 ? o : []) { for (const [u, c] of Object.entries(s)) u !== "inlineData" && c !== null && i.push(u); s.inlineData && typeof s.inlineData.data == "string" && (r += atob(s.inlineData.data)) } return i.length > 0 && console.warn(`there are non-data parts ${i} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`), r.length > 0 ? btoa(r) : void 0 } } class R0 { get audioChunk() { if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) return this.serverContent.audioChunks[0] } } class qa { _fromAPIResponse({ apiResponse: e, _isVertexAI: n }) { const o = new qa, i = rh(e); return Object.assign(o, i), o } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function W(t, e) { if (!e || typeof e != "string") throw new Error("model is required and must be a string"); if (e.includes("..") || e.includes("?") || e.includes("&")) throw new Error("invalid model parameter"); if (t.isVertexAI()) { if (e.startsWith("publishers/") || e.startsWith("projects/") || e.startsWith("models/")) return e; if (e.indexOf("/") >= 0) { const n = e.split("/", 2); return `publishers/${n[0]}/models/${n[1]}` } else return `publishers/google/models/${e}` } else return e.startsWith("models/") || e.startsWith("tunedModels/") ? e : `models/${e}` } function ih(t, e) { const n = W(t, e); return n ? n.startsWith("publishers/") && t.isVertexAI() ? `projects/${t.getProject()}/locations/${t.getLocation()}/${n}` : n.startsWith("models/") && t.isVertexAI() ? `projects/${t.getProject()}/locations/${t.getLocation()}/publishers/google/${n}` : n : "" } function sh(t) { return Array.isArray(t) ? t.map(e => Mi(e)) : [Mi(t)] } function Mi(t) { if (typeof t == "object" && t !== null) return t; throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof t}`) } function lh(t) { const e = Mi(t); if (e.mimeType && e.mimeType.startsWith("image/")) return e; throw new Error(`Unsupported mime type: ${e.mimeType}`) } function ah(t) { const e = Mi(t); if (e.mimeType && e.mimeType.startsWith("audio/")) return e; throw new Error(`Unsupported mime type: ${e.mimeType}`) } function md(t) { if (t == null) throw new Error("PartUnion is required"); if (typeof t == "object") return t; if (typeof t == "string") return { text: t }; throw new Error(`Unsupported part type: ${typeof t}`) } function uh(t) { if (t == null || Array.isArray(t) && t.length === 0) throw new Error("PartListUnion is required"); return Array.isArray(t) ? t.map(e => md(e)) : [md(t)] } function Ml(t) { return t != null && typeof t == "object" && "parts" in t && Array.isArray(t.parts) } function gd(t) { return t != null && typeof t == "object" && "functionCall" in t } function yd(t) { return t != null && typeof t == "object" && "functionResponse" in t } function Re(t) { if (t == null) throw new Error("ContentUnion is required"); return Ml(t) ? t : { role: "user", parts: uh(t) } } function Ha(t, e) { if (!e) return []; if (t.isVertexAI() && Array.isArray(e)) return e.flatMap(n => { const o = Re(n); return o.parts && o.parts.length > 0 && o.parts[0].text !== void 0 ? [o.parts[0].text] : [] }); if (t.isVertexAI()) { const n = Re(e); return n.parts && n.parts.length > 0 && n.parts[0].text !== void 0 ? [n.parts[0].text] : [] } return Array.isArray(e) ? e.map(n => Re(n)) : [Re(e)] } function ot(t) { if (t == null || Array.isArray(t) && t.length === 0) throw new Error("contents are required"); if (!Array.isArray(t)) { if (gd(t) || yd(t)) throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them"); return [Re(t)] } const e = [], n = [], o = Ml(t[0]); for (const r of t) { const i = Ml(r); if (i != o) throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them"); if (i) e.push(r); else { if (gd(r) || yd(r)) throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them"); n.push(r) } } return o || e.push({ role: "user", parts: uh(n) }), e } function P0(t, e) { t.includes("null") && (e.nullable = !0); const n = t.filter(o => o !== "null"); if (n.length === 1) e.type = Object.values(Qt).includes(n[0].toUpperCase()) ? n[0].toUpperCase() : Qt.TYPE_UNSPECIFIED; else { e.anyOf = []; for (const o of n) e.anyOf.push({ type: Object.values(Qt).includes(o.toUpperCase()) ? o.toUpperCase() : Qt.TYPE_UNSPECIFIED }) } } function eo(t) { const e = {}, n = ["items"], o = ["anyOf"], r = ["properties"]; if (t.type && t.anyOf) throw new Error("type and anyOf cannot be both populated."); const i = t.anyOf; i != null && i.length == 2 && (i[0].type === "null" ? (e.nullable = !0, t = i[1]) : i[1].type === "null" && (e.nullable = !0, t = i[0])), t.type instanceof Array && P0(t.type, e); for (const [s, u] of Object.entries(t)) if (u != null) if (s == "type") { if (u === "null") throw new Error("type: null can not be the only possible type for the field."); if (u instanceof Array) continue; e.type = Object.values(Qt).includes(u.toUpperCase()) ? u.toUpperCase() : Qt.TYPE_UNSPECIFIED } else if (n.includes(s)) e[s] = eo(u); else if (o.includes(s)) { const c = []; for (const d of u) { if (d.type == "null") { e.nullable = !0; continue } c.push(eo(d)) } e[s] = c } else if (r.includes(s)) { const c = {}; for (const [d, f] of Object.entries(u)) c[d] = eo(f); e[s] = c } else { if (s === "additionalProperties") continue; e[s] = u } return e } function za(t) { return eo(t) } function Ba(t) { if (typeof t == "object") return t; if (typeof t == "string") return { voiceConfig: { prebuiltVoiceConfig: { voiceName: t } } }; throw new Error(`Unsupported speechConfig type: ${typeof t}`) } function Ja(t) { if ("multiSpeakerVoiceConfig" in t) throw new Error("multiSpeakerVoiceConfig is not supported in the live API."); return t } function ho(t) { if (t.functionDeclarations) for (const e of t.functionDeclarations) e.parameters && (Object.keys(e.parameters).includes("$schema") ? e.parametersJsonSchema || (e.parametersJsonSchema = e.parameters, delete e.parameters) : e.parameters = eo(e.parameters)), e.response && (Object.keys(e.response).includes("$schema") ? e.responseJsonSchema || (e.responseJsonSchema = e.response, delete e.response) : e.response = eo(e.response)); return t } function mo(t) { if (t == null) throw new Error("tools is required"); if (!Array.isArray(t)) throw new Error("tools is required and must be an array of Tools"); const e = []; for (const n of t) e.push(n); return e } function M0(t, e, n, o = 1) { const r = !e.startsWith(`${n}/`) && e.split("/").length === o; return t.isVertexAI() ? e.startsWith("projects/") ? e : e.startsWith("locations/") ? `projects/${t.getProject()}/${e}` : e.startsWith(`${n}/`) ? `projects/${t.getProject()}/locations/${t.getLocation()}/${e}` : r ? `projects/${t.getProject()}/locations/${t.getLocation()}/${n}/${e}` : e : r ? `${n}/${e}` : e } function Vt(t, e) { if (typeof e != "string") throw new Error("name must be a string"); return M0(t, e, "cachedContents") } function ch(t) { switch (t) { case "STATE_UNSPECIFIED": return "JOB_STATE_UNSPECIFIED"; case "CREATING": return "JOB_STATE_RUNNING"; case "ACTIVE": return "JOB_STATE_SUCCEEDED"; case "FAILED": return "JOB_STATE_FAILED"; default: return t } } function dn(t) { return Ga(t) } function D0(t) { return t != null && typeof t == "object" && "name" in t } function L0(t) { return t != null && typeof t == "object" && "video" in t } function U0(t) { return t != null && typeof t == "object" && "uri" in t } function dh(t) { var e; let n; if (D0(t) && (n = t.name), !(U0(t) && (n = t.uri, n === void 0)) && !(L0(t) && (n = (e = t.video) === null || e === void 0 ? void 0 : e.uri, n === void 0))) { if (typeof t == "string" && (n = t), n === void 0) throw new Error("Could not extract file name from the provided input."); if (n.startsWith("https://")) { const r = n.split("files/")[1].match(/[a-z0-9]+/); if (r === null) throw new Error(`Could not extract file name from URI ${n}`); n = r[0] } else n.startsWith("files/") && (n = n.split("files/")[1]); return n } } function fh(t, e) { let n; return t.isVertexAI() ? n = e ? "publishers/google/models" : "models" : n = e ? "models" : "tunedModels", n } function ph(t) { for (const e of ["models", "tunedModels", "publisherModels"]) if (F0(t, e)) return t[e]; return [] } function F0(t, e) { return t !== null && typeof t == "object" && e in t } function b0(t, e = {}) { const n = t, o = { name: n.name, description: n.description, parametersJsonSchema: n.inputSchema }; return n.outputSchema && (o.responseJsonSchema = n.outputSchema), e.behavior && (o.behavior = e.behavior), { functionDeclarations: [o] } } function V0(t, e = {}) { const n = [], o = new Set; for (const r of t) { const i = r.name; if (o.has(i)) throw new Error(`Duplicate function name ${i} found in MCP tools. Please ensure function names are unique.`); o.add(i); const s = b0(r, e); s.functionDeclarations && n.push(...s.functionDeclarations) } return { functionDeclarations: n } } function hh(t, e) { let n; if (typeof e == "string") if (t.isVertexAI()) if (e.startsWith("gs://")) n = { format: "jsonl", gcsUri: [e] }; else if (e.startsWith("bq://")) n = { format: "bigquery", bigqueryUri: e }; else throw new Error(`Unsupported string source for Vertex AI: ${e}`); else if (e.startsWith("files/")) n = { fileName: e }; else throw new Error(`Unsupported string source for Gemini API: ${e}`); else if (Array.isArray(e)) { if (t.isVertexAI()) throw new Error("InlinedRequest[] is not supported in Vertex AI."); n = { inlinedRequests: e } } else n = e; const o = [n.gcsUri, n.bigqueryUri].filter(Boolean).length, r = [n.inlinedRequests, n.fileName].filter(Boolean).length; if (t.isVertexAI()) { if (r > 0 || o !== 1) throw new Error("Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.") } else if (o > 0 || r !== 1) throw new Error("Exactly one of `inlinedRequests`, `fileName`, must be set for Gemini API."); return n } function G0(t) { if (typeof t != "string") return t; const e = t; if (e.startsWith("gs://")) return { format: "jsonl", gcsUri: e }; if (e.startsWith("bq://")) return { format: "bigquery", bigqueryUri: e }; throw new Error(`Unsupported destination: ${e}`) } function mh(t) { if (typeof t != "object" || t === null) return {}; const e = t, n = e.inlinedResponses; if (typeof n != "object" || n === null) return t; const r = n.inlinedResponses; if (!Array.isArray(r) || r.length === 0) return t; let i = !1; for (const s of r) { if (typeof s != "object" || s === null) continue; const c = s.response; if (typeof c != "object" || c === null) continue; if (c.embedding !== void 0) { i = !0; break } } return i && (e.inlinedEmbedContentResponses = e.inlinedResponses, delete e.inlinedResponses), t } function go(t, e) { const n = e; if (!t.isVertexAI()) { if (/batches\/[^/]+$/.test(n)) return n.split("/").pop(); throw new Error(`Invalid batch job name: ${n}.`) } if (/^projects\/[^/]+\/locations\/[^/]+\/batchPredictionJobs\/[^/]+$/.test(n)) return n.split("/").pop(); if (/^\d+$/.test(n)) return n; throw new Error(`Invalid batch job name: ${n}.`) } function gh(t) { const e = t; return e === "BATCH_STATE_UNSPECIFIED" ? "JOB_STATE_UNSPECIFIED" : e === "BATCH_STATE_PENDING" ? "JOB_STATE_PENDING" : e === "BATCH_STATE_RUNNING" ? "JOB_STATE_RUNNING" : e === "BATCH_STATE_SUCCEEDED" ? "JOB_STATE_SUCCEEDED" : e === "BATCH_STATE_FAILED" ? "JOB_STATE_FAILED" : e === "BATCH_STATE_CANCELLED" ? "JOB_STATE_CANCELLED" : e === "BATCH_STATE_EXPIRED" ? "JOB_STATE_EXPIRED" : e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function $0(t) { const e = {}, n = l(t, ["responsesFile"]); n != null && a(e, ["fileName"], n); const o = l(t, ["inlinedResponses", "inlinedResponses"]); if (o != null) { let i = o; Array.isArray(i) && (i = i.map(s => wv(s))), a(e, ["inlinedResponses"], i) } const r = l(t, ["inlinedEmbedContentResponses", "inlinedResponses"]); if (r != null) { let i = r; Array.isArray(i) && (i = i.map(s => s)), a(e, ["inlinedEmbedContentResponses"], i) } return e } function q0(t) { const e = {}, n = l(t, ["predictionsFormat"]); n != null && a(e, ["format"], n); const o = l(t, ["gcsDestination", "outputUriPrefix"]); o != null && a(e, ["gcsUri"], o); const r = l(t, ["bigqueryDestination", "outputUri"]); return r != null && a(e, ["bigqueryUri"], r), e } function H0(t) { const e = {}, n = l(t, ["format"]); n != null && a(e, ["predictionsFormat"], n); const o = l(t, ["gcsUri"]); o != null && a(e, ["gcsDestination", "outputUriPrefix"], o); const r = l(t, ["bigqueryUri"]); if (r != null && a(e, ["bigqueryDestination", "outputUri"], r), l(t, ["fileName"]) !== void 0) throw new Error("fileName parameter is not supported in Vertex AI."); if (l(t, ["inlinedResponses"]) !== void 0) throw new Error("inlinedResponses parameter is not supported in Vertex AI."); if (l(t, ["inlinedEmbedContentResponses"]) !== void 0) throw new Error("inlinedEmbedContentResponses parameter is not supported in Vertex AI."); return e } function ti(t) { const e = {}, n = l(t, ["name"]); n != null && a(e, ["name"], n); const o = l(t, ["metadata", "displayName"]); o != null && a(e, ["displayName"], o); const r = l(t, ["metadata", "state"]); r != null && a(e, ["state"], gh(r)); const i = l(t, ["metadata", "createTime"]); i != null && a(e, ["createTime"], i); const s = l(t, ["metadata", "endTime"]); s != null && a(e, ["endTime"], s); const u = l(t, ["metadata", "updateTime"]); u != null && a(e, ["updateTime"], u); const c = l(t, ["metadata", "model"]); c != null && a(e, ["model"], c); const d = l(t, ["metadata", "output"]); return d != null && a(e, ["dest"], $0(mh(d))), e } function Dl(t) { const e = {}, n = l(t, ["name"]); n != null && a(e, ["name"], n); const o = l(t, ["displayName"]); o != null && a(e, ["displayName"], o); const r = l(t, ["state"]); r != null && a(e, ["state"], gh(r)); const i = l(t, ["error"]); i != null && a(e, ["error"], i); const s = l(t, ["createTime"]); s != null && a(e, ["createTime"], s); const u = l(t, ["startTime"]); u != null && a(e, ["startTime"], u); const c = l(t, ["endTime"]); c != null && a(e, ["endTime"], c); const d = l(t, ["updateTime"]); d != null && a(e, ["updateTime"], d); const f = l(t, ["model"]); f != null && a(e, ["model"], f); const p = l(t, ["inputConfig"]); p != null && a(e, ["src"], z0(p)); const h = l(t, ["outputConfig"]); h != null && a(e, ["dest"], q0(mh(h))); const g = l(t, ["completionStats"]); return g != null && a(e, ["completionStats"], g), e } function z0(t) { const e = {}, n = l(t, ["instancesFormat"]); n != null && a(e, ["format"], n); const o = l(t, ["gcsSource", "uris"]); o != null && a(e, ["gcsUri"], o); const r = l(t, ["bigquerySource", "inputUri"]); return r != null && a(e, ["bigqueryUri"], r), e } function B0(t, e) { const n = {}; if (l(e, ["format"]) !== void 0) throw new Error("format parameter is not supported in Gemini API."); if (l(e, ["gcsUri"]) !== void 0) throw new Error("gcsUri parameter is not supported in Gemini API."); if (l(e, ["bigqueryUri"]) !== void 0) throw new Error("bigqueryUri parameter is not supported in Gemini API."); const o = l(e, ["fileName"]); o != null && a(n, ["fileName"], o); const r = l(e, ["inlinedRequests"]); if (r != null) { let i = r; Array.isArray(i) && (i = i.map(s => xv(t, s))), a(n, ["requests", "requests"], i) } return n } function J0(t) { const e = {}, n = l(t, ["format"]); n != null && a(e, ["instancesFormat"], n); const o = l(t, ["gcsUri"]); o != null && a(e, ["gcsSource", "uris"], o); const r = l(t, ["bigqueryUri"]); if (r != null && a(e, ["bigquerySource", "inputUri"], r), l(t, ["fileName"]) !== void 0) throw new Error("fileName parameter is not supported in Vertex AI."); if (l(t, ["inlinedRequests"]) !== void 0) throw new Error("inlinedRequests parameter is not supported in Vertex AI."); return e } function W0(t) { const e = {}, n = l(t, ["data"]); if (n != null && a(e, ["data"], n), l(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const o = l(t, ["mimeType"]); return o != null && a(e, ["mimeType"], o), e } function Y0(t, e) { const n = {}, o = l(e, ["name"]); return o != null && a(n, ["_url", "name"], go(t, o)), n } function K0(t, e) { const n = {}, o = l(e, ["name"]); return o != null && a(n, ["_url", "name"], go(t, o)), n } function O0(t) { const e = {}, n = l(t, ["content"]); n != null && a(e, ["content"], n); const o = l(t, ["citationMetadata"]); o != null && a(e, ["citationMetadata"], Q0(o)); const r = l(t, ["tokenCount"]); r != null && a(e, ["tokenCount"], r); const i = l(t, ["finishReason"]); i != null && a(e, ["finishReason"], i); const s = l(t, ["avgLogprobs"]); s != null && a(e, ["avgLogprobs"], s); const u = l(t, ["groundingMetadata"]); u != null && a(e, ["groundingMetadata"], u); const c = l(t, ["index"]); c != null && a(e, ["index"], c); const d = l(t, ["logprobsResult"]); d != null && a(e, ["logprobsResult"], d); const f = l(t, ["safetyRatings"]); if (f != null) { let h = f; Array.isArray(h) && (h = h.map(g => g)), a(e, ["safetyRatings"], h) } const p = l(t, ["urlContextMetadata"]); return p != null && a(e, ["urlContextMetadata"], p), e } function Q0(t) { const e = {}, n = l(t, ["citationSources"]); if (n != null) { let o = n; Array.isArray(o) && (o = o.map(r => r)), a(e, ["citations"], o) } return e } function yh(t) { const e = {}, n = l(t, ["parts"]); if (n != null) { let r = n; Array.isArray(r) && (r = r.map(i => Iv(i))), a(e, ["parts"], r) } const o = l(t, ["role"]); return o != null && a(e, ["role"], o), e } function X0(t, e) { const n = {}, o = l(t, ["displayName"]); if (e !== void 0 && o != null && a(e, ["batch", "displayName"], o), l(t, ["dest"]) !== void 0) throw new Error("dest parameter is not supported in Gemini API."); return n } function Z0(t, e) { const n = {}, o = l(t, ["displayName"]); e !== void 0 && o != null && a(e, ["displayName"], o); const r = l(t, ["dest"]); return e !== void 0 && r != null && a(e, ["outputConfig"], H0(G0(r))), n } function vd(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "model"], W(t, o)); const r = l(e, ["src"]); r != null && a(n, ["batch", "inputConfig"], B0(t, hh(t, r))); const i = l(e, ["config"]); return i != null && X0(i, n), n } function j0(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["model"], W(t, o)); const r = l(e, ["src"]); r != null && a(n, ["inputConfig"], J0(hh(t, r))); const i = l(e, ["config"]); return i != null && Z0(i, n), n } function ev(t, e) { const n = {}, o = l(t, ["displayName"]); return e !== void 0 && o != null && a(e, ["batch", "displayName"], o), n } function tv(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "model"], W(t, o)); const r = l(e, ["src"]); r != null && a(n, ["batch", "inputConfig"], av(t, r)); const i = l(e, ["config"]); return i != null && ev(i, n), n } function nv(t, e) { const n = {}, o = l(e, ["name"]); return o != null && a(n, ["_url", "name"], go(t, o)), n } function ov(t, e) { const n = {}, o = l(e, ["name"]); return o != null && a(n, ["_url", "name"], go(t, o)), n } function rv(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["name"]); o != null && a(e, ["name"], o); const r = l(t, ["done"]); r != null && a(e, ["done"], r); const i = l(t, ["error"]); return i != null && a(e, ["error"], i), e } function iv(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["name"]); o != null && a(e, ["name"], o); const r = l(t, ["done"]); r != null && a(e, ["done"], r); const i = l(t, ["error"]); return i != null && a(e, ["error"], i), e } function sv(t, e) { const n = {}, o = l(e, ["contents"]); if (o != null) { let i = Ha(t, o); Array.isArray(i) && (i = i.map(s => s)), a(n, ["requests[]", "request", "content"], i) } const r = l(e, ["config"]); return r != null && (a(n, ["_self"], lv(r, n)), o0(n, { "requests[].*": "requests[].request.*" })), n } function lv(t, e) { const n = {}, o = l(t, ["taskType"]); e !== void 0 && o != null && a(e, ["requests[]", "taskType"], o); const r = l(t, ["title"]); e !== void 0 && r != null && a(e, ["requests[]", "title"], r); const i = l(t, ["outputDimensionality"]); if (e !== void 0 && i != null && a(e, ["requests[]", "outputDimensionality"], i), l(t, ["mimeType"]) !== void 0) throw new Error("mimeType parameter is not supported in Gemini API."); if (l(t, ["autoTruncate"]) !== void 0) throw new Error("autoTruncate parameter is not supported in Gemini API."); return n } function av(t, e) { const n = {}, o = l(e, ["fileName"]); o != null && a(n, ["file_name"], o); const r = l(e, ["inlinedRequests"]); return r != null && a(n, ["requests"], sv(t, r)), n } function uv(t) { const e = {}; if (l(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const n = l(t, ["fileUri"]); n != null && a(e, ["fileUri"], n); const o = l(t, ["mimeType"]); return o != null && a(e, ["mimeType"], o), e } function cv(t) { const e = {}, n = l(t, ["id"]); n != null && a(e, ["id"], n); const o = l(t, ["args"]); o != null && a(e, ["args"], o); const r = l(t, ["name"]); if (r != null && a(e, ["name"], r), l(t, ["partialArgs"]) !== void 0) throw new Error("partialArgs parameter is not supported in Gemini API."); if (l(t, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API."); return e } function dv(t) { const e = {}, n = l(t, ["mode"]); n != null && a(e, ["mode"], n); const o = l(t, ["allowedFunctionNames"]); if (o != null && a(e, ["allowedFunctionNames"], o), l(t, ["streamFunctionCallArguments"]) !== void 0) throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API."); return e } function fv(t, e, n) { const o = {}, r = l(e, ["systemInstruction"]); n !== void 0 && r != null && a(n, ["systemInstruction"], yh(Re(r))); const i = l(e, ["temperature"]); i != null && a(o, ["temperature"], i); const s = l(e, ["topP"]); s != null && a(o, ["topP"], s); const u = l(e, ["topK"]); u != null && a(o, ["topK"], u); const c = l(e, ["candidateCount"]); c != null && a(o, ["candidateCount"], c); const d = l(e, ["maxOutputTokens"]); d != null && a(o, ["maxOutputTokens"], d); const f = l(e, ["stopSequences"]); f != null && a(o, ["stopSequences"], f); const p = l(e, ["responseLogprobs"]); p != null && a(o, ["responseLogprobs"], p); const h = l(e, ["logprobs"]); h != null && a(o, ["logprobs"], h); const g = l(e, ["presencePenalty"]); g != null && a(o, ["presencePenalty"], g); const S = l(e, ["frequencyPenalty"]); S != null && a(o, ["frequencyPenalty"], S); const w = l(e, ["seed"]); w != null && a(o, ["seed"], w); const I = l(e, ["responseMimeType"]); I != null && a(o, ["responseMimeType"], I); const x = l(e, ["responseSchema"]); x != null && a(o, ["responseSchema"], za(x)); const y = l(e, ["responseJsonSchema"]); if (y != null && a(o, ["responseJsonSchema"], y), l(e, ["routingConfig"]) !== void 0) throw new Error("routingConfig parameter is not supported in Gemini API."); if (l(e, ["modelSelectionConfig"]) !== void 0) throw new Error("modelSelectionConfig parameter is not supported in Gemini API."); const v = l(e, ["safetySettings"]); if (n !== void 0 && v != null) { let z = v; Array.isArray(z) && (z = z.map(se => Nv(se))), a(n, ["safetySettings"], z) } const T = l(e, ["tools"]); if (n !== void 0 && T != null) { let z = mo(T); Array.isArray(z) && (z = z.map(se => Rv(ho(se)))), a(n, ["tools"], z) } const E = l(e, ["toolConfig"]); if (n !== void 0 && E != null && a(n, ["toolConfig"], Av(E)), l(e, ["labels"]) !== void 0) throw new Error("labels parameter is not supported in Gemini API."); const C = l(e, ["cachedContent"]); n !== void 0 && C != null && a(n, ["cachedContent"], Vt(t, C)); const k = l(e, ["responseModalities"]); k != null && a(o, ["responseModalities"], k); const A = l(e, ["mediaResolution"]); A != null && a(o, ["mediaResolution"], A); const N = l(e, ["speechConfig"]); if (N != null && a(o, ["speechConfig"], Ba(N)), l(e, ["audioTimestamp"]) !== void 0) throw new Error("audioTimestamp parameter is not supported in Gemini API."); const M = l(e, ["thinkingConfig"]); M != null && a(o, ["thinkingConfig"], M); const b = l(e, ["imageConfig"]); return b != null && a(o, ["imageConfig"], vv(b)), o } function pv(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["candidates"]); if (o != null) { let c = o; Array.isArray(c) && (c = c.map(d => O0(d))), a(e, ["candidates"], c) } const r = l(t, ["modelVersion"]); r != null && a(e, ["modelVersion"], r); const i = l(t, ["promptFeedback"]); i != null && a(e, ["promptFeedback"], i); const s = l(t, ["responseId"]); s != null && a(e, ["responseId"], s); const u = l(t, ["usageMetadata"]); return u != null && a(e, ["usageMetadata"], u), e } function hv(t, e) { const n = {}, o = l(e, ["name"]); return o != null && a(n, ["_url", "name"], go(t, o)), n } function mv(t, e) { const n = {}, o = l(e, ["name"]); return o != null && a(n, ["_url", "name"], go(t, o)), n } function gv(t) { const e = {}; if (l(t, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API."); const n = l(t, ["enableWidget"]); return n != null && a(e, ["enableWidget"], n), e } function yv(t) { const e = {}; if (l(t, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API."); if (l(t, ["blockingConfidence"]) !== void 0) throw new Error("blockingConfidence parameter is not supported in Gemini API."); const n = l(t, ["timeRangeFilter"]); return n != null && a(e, ["timeRangeFilter"], n), e } function vv(t) { const e = {}, n = l(t, ["aspectRatio"]); n != null && a(e, ["aspectRatio"], n); const o = l(t, ["imageSize"]); if (o != null && a(e, ["imageSize"], o), l(t, ["outputMimeType"]) !== void 0) throw new Error("outputMimeType parameter is not supported in Gemini API."); if (l(t, ["outputCompressionQuality"]) !== void 0) throw new Error("outputCompressionQuality parameter is not supported in Gemini API."); return e } function xv(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["request", "model"], W(t, o)); const r = l(e, ["contents"]); if (r != null) { let u = ot(r); Array.isArray(u) && (u = u.map(c => yh(c))), a(n, ["request", "contents"], u) } const i = l(e, ["metadata"]); i != null && a(n, ["metadata"], i); const s = l(e, ["config"]); return s != null && a(n, ["request", "generationConfig"], fv(t, s, l(n, ["request"], {}))), n } function wv(t) { const e = {}, n = l(t, ["response"]); n != null && a(e, ["response"], pv(n)); const o = l(t, ["error"]); return o != null && a(e, ["error"], o), e } function Cv(t, e) { const n = {}, o = l(t, ["pageSize"]); e !== void 0 && o != null && a(e, ["_query", "pageSize"], o); const r = l(t, ["pageToken"]); if (e !== void 0 && r != null && a(e, ["_query", "pageToken"], r), l(t, ["filter"]) !== void 0) throw new Error("filter parameter is not supported in Gemini API."); return n } function Sv(t, e) { const n = {}, o = l(t, ["pageSize"]); e !== void 0 && o != null && a(e, ["_query", "pageSize"], o); const r = l(t, ["pageToken"]); e !== void 0 && r != null && a(e, ["_query", "pageToken"], r); const i = l(t, ["filter"]); return e !== void 0 && i != null && a(e, ["_query", "filter"], i), n } function Tv(t) { const e = {}, n = l(t, ["config"]); return n != null && Cv(n, e), e } function _v(t) { const e = {}, n = l(t, ["config"]); return n != null && Sv(n, e), e } function Ev(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["nextPageToken"]); o != null && a(e, ["nextPageToken"], o); const r = l(t, ["operations"]); if (r != null) { let i = r; Array.isArray(i) && (i = i.map(s => ti(s))), a(e, ["batchJobs"], i) } return e } function kv(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["nextPageToken"]); o != null && a(e, ["nextPageToken"], o); const r = l(t, ["batchPredictionJobs"]); if (r != null) { let i = r; Array.isArray(i) && (i = i.map(s => Dl(s))), a(e, ["batchJobs"], i) } return e } function Iv(t) { const e = {}, n = l(t, ["mediaResolution"]); n != null && a(e, ["mediaResolution"], n); const o = l(t, ["codeExecutionResult"]); o != null && a(e, ["codeExecutionResult"], o); const r = l(t, ["executableCode"]); r != null && a(e, ["executableCode"], r); const i = l(t, ["fileData"]); i != null && a(e, ["fileData"], uv(i)); const s = l(t, ["functionCall"]); s != null && a(e, ["functionCall"], cv(s)); const u = l(t, ["functionResponse"]); u != null && a(e, ["functionResponse"], u); const c = l(t, ["inlineData"]); c != null && a(e, ["inlineData"], W0(c)); const d = l(t, ["text"]); d != null && a(e, ["text"], d); const f = l(t, ["thought"]); f != null && a(e, ["thought"], f); const p = l(t, ["thoughtSignature"]); p != null && a(e, ["thoughtSignature"], p); const h = l(t, ["videoMetadata"]); return h != null && a(e, ["videoMetadata"], h), e } function Nv(t) { const e = {}, n = l(t, ["category"]); if (n != null && a(e, ["category"], n), l(t, ["method"]) !== void 0) throw new Error("method parameter is not supported in Gemini API."); const o = l(t, ["threshold"]); return o != null && a(e, ["threshold"], o), e } function Av(t) { const e = {}, n = l(t, ["functionCallingConfig"]); n != null && a(e, ["functionCallingConfig"], dv(n)); const o = l(t, ["retrievalConfig"]); return o != null && a(e, ["retrievalConfig"], o), e } function Rv(t) { const e = {}, n = l(t, ["functionDeclarations"]); if (n != null) { let f = n; Array.isArray(f) && (f = f.map(p => p)), a(e, ["functionDeclarations"], f) } if (l(t, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API."); const o = l(t, ["googleSearchRetrieval"]); o != null && a(e, ["googleSearchRetrieval"], o); const r = l(t, ["computerUse"]); r != null && a(e, ["computerUse"], r); const i = l(t, ["fileSearch"]); i != null && a(e, ["fileSearch"], i); const s = l(t, ["codeExecution"]); if (s != null && a(e, ["codeExecution"], s), l(t, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API."); const u = l(t, ["googleMaps"]); u != null && a(e, ["googleMaps"], gv(u)); const c = l(t, ["googleSearch"]); c != null && a(e, ["googleSearch"], yv(c)); const d = l(t, ["urlContext"]); return d != null && a(e, ["urlContext"], d), e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */var Ut; (function (t) { t.PAGED_ITEM_BATCH_JOBS = "batchJobs", t.PAGED_ITEM_MODELS = "models", t.PAGED_ITEM_TUNING_JOBS = "tuningJobs", t.PAGED_ITEM_FILES = "files", t.PAGED_ITEM_CACHED_CONTENTS = "cachedContents", t.PAGED_ITEM_FILE_SEARCH_STORES = "fileSearchStores", t.PAGED_ITEM_DOCUMENTS = "documents" })(Ut || (Ut = {})); class Nn { constructor(e, n, o, r) { this.pageInternal = [], this.paramsInternal = {}, this.requestInternal = n, this.init(e, o, r) } init(e, n, o) { var r, i; this.nameInternal = e, this.pageInternal = n[this.nameInternal] || [], this.sdkHttpResponseInternal = n == null ? void 0 : n.sdkHttpResponse, this.idxInternal = 0; let s = { config: {} }; !o || Object.keys(o).length === 0 ? s = { config: {} } : typeof o == "object" ? s = Object.assign({}, o) : s = o, s.config && (s.config.pageToken = n.nextPageToken), this.paramsInternal = s, this.pageInternalSize = (i = (r = s.config) === null || r === void 0 ? void 0 : r.pageSize) !== null && i !== void 0 ? i : this.pageInternal.length } initNextPage(e) { this.init(this.nameInternal, e, this.paramsInternal) } get page() { return this.pageInternal } get name() { return this.nameInternal } get pageSize() { return this.pageInternalSize } get sdkHttpResponse() { return this.sdkHttpResponseInternal } get params() { return this.paramsInternal } get pageLength() { return this.pageInternal.length } getItem(e) { return this.pageInternal[e] } [Symbol.asyncIterator]() { return { next: async () => { if (this.idxInternal >= this.pageLength) if (this.hasNextPage()) await this.nextPage(); else return { value: void 0, done: !0 }; const e = this.getItem(this.idxInternal); return this.idxInternal += 1, { value: e, done: !1 } }, return: async () => ({ value: void 0, done: !0 }) } } async nextPage() { if (!this.hasNextPage()) throw new Error("No more pages to fetch."); const e = await this.requestInternal(this.params); return this.initNextPage(e), this.page } hasNextPage() { var e; return ((e = this.params.config) === null || e === void 0 ? void 0 : e.pageToken) !== void 0 } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Pv extends bt { constructor(e) { super(), this.apiClient = e, this.create = async n => (this.apiClient.isVertexAI() && (n.config = this.formatDestination(n.src, n.config)), this.createInternal(n)), this.createEmbeddings = async n => { if (console.warn("batches.createEmbeddings() is experimental and may change without notice."), this.apiClient.isVertexAI()) throw new Error("Vertex AI does not support batches.createEmbeddings."); return this.createEmbeddingsInternal(n) }, this.list = async (n = {}) => new Nn(Ut.PAGED_ITEM_BATCH_JOBS, o => this.listInternal(o), await this.listInternal(n), n) } createInlinedGenerateContentRequest(e) { const n = vd(this.apiClient, e), o = n._url, r = D("{model}:batchGenerateContent", o), u = n.batch.inputConfig.requests, c = u.requests, d = []; for (const f of c) { const p = Object.assign({}, f); if (p.systemInstruction) { const h = p.systemInstruction; delete p.systemInstruction; const g = p.request; g.systemInstruction = h, p.request = g } d.push(p) } return u.requests = d, delete n.config, delete n._url, delete n._query, { path: r, body: n } } getGcsUri(e) { if (typeof e == "string") return e.startsWith("gs://") ? e : void 0; if (!Array.isArray(e) && e.gcsUri && e.gcsUri.length > 0) return e.gcsUri[0] } getBigqueryUri(e) { if (typeof e == "string") return e.startsWith("bq://") ? e : void 0; if (!Array.isArray(e)) return e.bigqueryUri } formatDestination(e, n) { const o = n ? Object.assign({}, n) : {}, r = Date.now().toString(); if (o.displayName || (o.displayName = `genaiBatchJob_${r}`), o.dest === void 0) { const i = this.getGcsUri(e), s = this.getBigqueryUri(e); if (i) i.endsWith(".jsonl") ? o.dest = `${i.slice(0, -6)}/dest` : o.dest = `${i}_dest_${r}`; else if (s) o.dest = `${s}_dest_${r}`; else throw new Error("Unsupported source for Vertex AI: No GCS or BigQuery URI found.") } return o } async createInternal(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = j0(this.apiClient, e); return u = D("batchPredictionJobs", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json()), s.then(f => Dl(f)) } else { const d = vd(this.apiClient, e); return u = D("{model}:batchGenerateContent", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "POST", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json()), s.then(f => ti(f)) } } async createEmbeddingsInternal(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const u = tv(this.apiClient, e); return i = D("{model}:asyncBatchEmbedContent", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json()), r.then(c => ti(c)) } } async get(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = mv(this.apiClient, e); return u = D("batchPredictionJobs/{name}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "GET", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json()), s.then(f => Dl(f)) } else { const d = hv(this.apiClient, e); return u = D("batches/{name}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "GET", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json()), s.then(f => ti(f)) } } async cancel(e) { var n, o, r, i; let s = "", u = {}; if (this.apiClient.isVertexAI()) { const c = K0(this.apiClient, e); s = D("batchPredictionJobs/{name}:cancel", c._url), u = c._query, delete c._url, delete c._query, await this.apiClient.request({ path: s, queryParams: u, body: JSON.stringify(c), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }) } else { const c = Y0(this.apiClient, e); s = D("batches/{name}:cancel", c._url), u = c._query, delete c._url, delete c._query, await this.apiClient.request({ path: s, queryParams: u, body: JSON.stringify(c), httpMethod: "POST", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }) } } async listInternal(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = _v(e); return u = D("batchPredictionJobs", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "GET", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = kv(f), h = new hd; return Object.assign(h, p), h }) } else { const d = Tv(e); return u = D("batches", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "GET", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = Ev(f), h = new hd; return Object.assign(h, p), h }) } } async delete(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = ov(this.apiClient, e); return u = D("batchPredictionJobs/{name}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "DELETE", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => iv(f)) } else { const d = nv(this.apiClient, e); return u = D("batches/{name}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "DELETE", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => rv(f)) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Mv(t) { const e = {}, n = l(t, ["data"]); if (n != null && a(e, ["data"], n), l(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const o = l(t, ["mimeType"]); return o != null && a(e, ["mimeType"], o), e } function xd(t) { const e = {}, n = l(t, ["parts"]); if (n != null) { let r = n; Array.isArray(r) && (r = r.map(i => tx(i))), a(e, ["parts"], r) } const o = l(t, ["role"]); return o != null && a(e, ["role"], o), e } function Dv(t, e) { const n = {}, o = l(t, ["ttl"]); e !== void 0 && o != null && a(e, ["ttl"], o); const r = l(t, ["expireTime"]); e !== void 0 && r != null && a(e, ["expireTime"], r); const i = l(t, ["displayName"]); e !== void 0 && i != null && a(e, ["displayName"], i); const s = l(t, ["contents"]); if (e !== void 0 && s != null) { let f = ot(s); Array.isArray(f) && (f = f.map(p => xd(p))), a(e, ["contents"], f) } const u = l(t, ["systemInstruction"]); e !== void 0 && u != null && a(e, ["systemInstruction"], xd(Re(u))); const c = l(t, ["tools"]); if (e !== void 0 && c != null) { let f = c; Array.isArray(f) && (f = f.map(p => ox(p))), a(e, ["tools"], f) } const d = l(t, ["toolConfig"]); if (e !== void 0 && d != null && a(e, ["toolConfig"], nx(d)), l(t, ["kmsKeyName"]) !== void 0) throw new Error("kmsKeyName parameter is not supported in Gemini API."); return n } function Lv(t, e) { const n = {}, o = l(t, ["ttl"]); e !== void 0 && o != null && a(e, ["ttl"], o); const r = l(t, ["expireTime"]); e !== void 0 && r != null && a(e, ["expireTime"], r); const i = l(t, ["displayName"]); e !== void 0 && i != null && a(e, ["displayName"], i); const s = l(t, ["contents"]); if (e !== void 0 && s != null) { let p = ot(s); Array.isArray(p) && (p = p.map(h => h)), a(e, ["contents"], p) } const u = l(t, ["systemInstruction"]); e !== void 0 && u != null && a(e, ["systemInstruction"], Re(u)); const c = l(t, ["tools"]); if (e !== void 0 && c != null) { let p = c; Array.isArray(p) && (p = p.map(h => rx(h))), a(e, ["tools"], p) } const d = l(t, ["toolConfig"]); e !== void 0 && d != null && a(e, ["toolConfig"], d); const f = l(t, ["kmsKeyName"]); return e !== void 0 && f != null && a(e, ["encryption_spec", "kmsKeyName"], f), n } function Uv(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["model"], ih(t, o)); const r = l(e, ["config"]); return r != null && Dv(r, n), n } function Fv(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["model"], ih(t, o)); const r = l(e, ["config"]); return r != null && Lv(r, n), n } function bv(t, e) { const n = {}, o = l(e, ["name"]); return o != null && a(n, ["_url", "name"], Vt(t, o)), n } function Vv(t, e) { const n = {}, o = l(e, ["name"]); return o != null && a(n, ["_url", "name"], Vt(t, o)), n } function Gv(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); return n != null && a(e, ["sdkHttpResponse"], n), e } function $v(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); return n != null && a(e, ["sdkHttpResponse"], n), e } function qv(t) { const e = {}; if (l(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const n = l(t, ["fileUri"]); n != null && a(e, ["fileUri"], n); const o = l(t, ["mimeType"]); return o != null && a(e, ["mimeType"], o), e } function Hv(t) { const e = {}, n = l(t, ["id"]); n != null && a(e, ["id"], n); const o = l(t, ["args"]); o != null && a(e, ["args"], o); const r = l(t, ["name"]); if (r != null && a(e, ["name"], r), l(t, ["partialArgs"]) !== void 0) throw new Error("partialArgs parameter is not supported in Gemini API."); if (l(t, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API."); return e } function zv(t) { const e = {}, n = l(t, ["mode"]); n != null && a(e, ["mode"], n); const o = l(t, ["allowedFunctionNames"]); if (o != null && a(e, ["allowedFunctionNames"], o), l(t, ["streamFunctionCallArguments"]) !== void 0) throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API."); return e } function Bv(t) { const e = {}; if (l(t, ["behavior"]) !== void 0) throw new Error("behavior parameter is not supported in Vertex AI."); const n = l(t, ["description"]); n != null && a(e, ["description"], n); const o = l(t, ["name"]); o != null && a(e, ["name"], o); const r = l(t, ["parameters"]); r != null && a(e, ["parameters"], r); const i = l(t, ["parametersJsonSchema"]); i != null && a(e, ["parametersJsonSchema"], i); const s = l(t, ["response"]); s != null && a(e, ["response"], s); const u = l(t, ["responseJsonSchema"]); return u != null && a(e, ["responseJsonSchema"], u), e } function Jv(t, e) { const n = {}, o = l(e, ["name"]); return o != null && a(n, ["_url", "name"], Vt(t, o)), n } function Wv(t, e) { const n = {}, o = l(e, ["name"]); return o != null && a(n, ["_url", "name"], Vt(t, o)), n } function Yv(t) { const e = {}; if (l(t, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API."); const n = l(t, ["enableWidget"]); return n != null && a(e, ["enableWidget"], n), e } function Kv(t) { const e = {}; if (l(t, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API."); if (l(t, ["blockingConfidence"]) !== void 0) throw new Error("blockingConfidence parameter is not supported in Gemini API."); const n = l(t, ["timeRangeFilter"]); return n != null && a(e, ["timeRangeFilter"], n), e } function Ov(t, e) { const n = {}, o = l(t, ["pageSize"]); e !== void 0 && o != null && a(e, ["_query", "pageSize"], o); const r = l(t, ["pageToken"]); return e !== void 0 && r != null && a(e, ["_query", "pageToken"], r), n } function Qv(t, e) { const n = {}, o = l(t, ["pageSize"]); e !== void 0 && o != null && a(e, ["_query", "pageSize"], o); const r = l(t, ["pageToken"]); return e !== void 0 && r != null && a(e, ["_query", "pageToken"], r), n } function Xv(t) { const e = {}, n = l(t, ["config"]); return n != null && Ov(n, e), e } function Zv(t) { const e = {}, n = l(t, ["config"]); return n != null && Qv(n, e), e } function jv(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["nextPageToken"]); o != null && a(e, ["nextPageToken"], o); const r = l(t, ["cachedContents"]); if (r != null) { let i = r; Array.isArray(i) && (i = i.map(s => s)), a(e, ["cachedContents"], i) } return e } function ex(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["nextPageToken"]); o != null && a(e, ["nextPageToken"], o); const r = l(t, ["cachedContents"]); if (r != null) { let i = r; Array.isArray(i) && (i = i.map(s => s)), a(e, ["cachedContents"], i) } return e } function tx(t) { const e = {}, n = l(t, ["mediaResolution"]); n != null && a(e, ["mediaResolution"], n); const o = l(t, ["codeExecutionResult"]); o != null && a(e, ["codeExecutionResult"], o); const r = l(t, ["executableCode"]); r != null && a(e, ["executableCode"], r); const i = l(t, ["fileData"]); i != null && a(e, ["fileData"], qv(i)); const s = l(t, ["functionCall"]); s != null && a(e, ["functionCall"], Hv(s)); const u = l(t, ["functionResponse"]); u != null && a(e, ["functionResponse"], u); const c = l(t, ["inlineData"]); c != null && a(e, ["inlineData"], Mv(c)); const d = l(t, ["text"]); d != null && a(e, ["text"], d); const f = l(t, ["thought"]); f != null && a(e, ["thought"], f); const p = l(t, ["thoughtSignature"]); p != null && a(e, ["thoughtSignature"], p); const h = l(t, ["videoMetadata"]); return h != null && a(e, ["videoMetadata"], h), e } function nx(t) { const e = {}, n = l(t, ["functionCallingConfig"]); n != null && a(e, ["functionCallingConfig"], zv(n)); const o = l(t, ["retrievalConfig"]); return o != null && a(e, ["retrievalConfig"], o), e } function ox(t) { const e = {}, n = l(t, ["functionDeclarations"]); if (n != null) { let f = n; Array.isArray(f) && (f = f.map(p => p)), a(e, ["functionDeclarations"], f) } if (l(t, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API."); const o = l(t, ["googleSearchRetrieval"]); o != null && a(e, ["googleSearchRetrieval"], o); const r = l(t, ["computerUse"]); r != null && a(e, ["computerUse"], r); const i = l(t, ["fileSearch"]); i != null && a(e, ["fileSearch"], i); const s = l(t, ["codeExecution"]); if (s != null && a(e, ["codeExecution"], s), l(t, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API."); const u = l(t, ["googleMaps"]); u != null && a(e, ["googleMaps"], Yv(u)); const c = l(t, ["googleSearch"]); c != null && a(e, ["googleSearch"], Kv(c)); const d = l(t, ["urlContext"]); return d != null && a(e, ["urlContext"], d), e } function rx(t) { const e = {}, n = l(t, ["functionDeclarations"]); if (n != null) { let p = n; Array.isArray(p) && (p = p.map(h => Bv(h))), a(e, ["functionDeclarations"], p) } const o = l(t, ["retrieval"]); o != null && a(e, ["retrieval"], o); const r = l(t, ["googleSearchRetrieval"]); r != null && a(e, ["googleSearchRetrieval"], r); const i = l(t, ["computerUse"]); if (i != null && a(e, ["computerUse"], i), l(t, ["fileSearch"]) !== void 0) throw new Error("fileSearch parameter is not supported in Vertex AI."); const s = l(t, ["codeExecution"]); s != null && a(e, ["codeExecution"], s); const u = l(t, ["enterpriseWebSearch"]); u != null && a(e, ["enterpriseWebSearch"], u); const c = l(t, ["googleMaps"]); c != null && a(e, ["googleMaps"], c); const d = l(t, ["googleSearch"]); d != null && a(e, ["googleSearch"], d); const f = l(t, ["urlContext"]); return f != null && a(e, ["urlContext"], f), e } function ix(t, e) { const n = {}, o = l(t, ["ttl"]); e !== void 0 && o != null && a(e, ["ttl"], o); const r = l(t, ["expireTime"]); return e !== void 0 && r != null && a(e, ["expireTime"], r), n } function sx(t, e) { const n = {}, o = l(t, ["ttl"]); e !== void 0 && o != null && a(e, ["ttl"], o); const r = l(t, ["expireTime"]); return e !== void 0 && r != null && a(e, ["expireTime"], r), n } function lx(t, e) { const n = {}, o = l(e, ["name"]); o != null && a(n, ["_url", "name"], Vt(t, o)); const r = l(e, ["config"]); return r != null && ix(r, n), n } function ax(t, e) { const n = {}, o = l(e, ["name"]); o != null && a(n, ["_url", "name"], Vt(t, o)); const r = l(e, ["config"]); return r != null && sx(r, n), n }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class ux extends bt { constructor(e) { super(), this.apiClient = e, this.list = async (n = {}) => new Nn(Ut.PAGED_ITEM_CACHED_CONTENTS, o => this.listInternal(o), await this.listInternal(n), n) } async create(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = Fv(this.apiClient, e); return u = D("cachedContents", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json()), s.then(f => f) } else { const d = Uv(this.apiClient, e); return u = D("cachedContents", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "POST", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json()), s.then(f => f) } } async get(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = Wv(this.apiClient, e); return u = D("{name}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "GET", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json()), s.then(f => f) } else { const d = Jv(this.apiClient, e); return u = D("{name}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "GET", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json()), s.then(f => f) } } async delete(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = Vv(this.apiClient, e); return u = D("{name}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "DELETE", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = $v(f), h = new fd; return Object.assign(h, p), h }) } else { const d = bv(this.apiClient, e); return u = D("{name}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "DELETE", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = Gv(f), h = new fd; return Object.assign(h, p), h }) } } async update(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = ax(this.apiClient, e); return u = D("{name}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "PATCH", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json()), s.then(f => f) } else { const d = lx(this.apiClient, e); return u = D("{name}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "PATCH", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json()), s.then(f => f) } } async listInternal(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = Zv(e); return u = D("cachedContents", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "GET", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = ex(f), h = new pd; return Object.assign(h, p), h }) } else { const d = Xv(e); return u = D("cachedContents", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "GET", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = jv(f), h = new pd; return Object.assign(h, p), h }) } } } function wd(t) { var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], o = 0; if (n) return n.call(t); if (t && typeof t.length == "number") return { next: function () { return t && o >= t.length && (t = void 0), { value: t && t[o++], done: !t } } }; throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.") } function oe(t) { return this instanceof oe ? (this.v = t, this) : new oe(t) } function to(t, e, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var o = n.apply(t, e || []), r, i = []; return r = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), u("next"), u("throw"), u("return", s), r[Symbol.asyncIterator] = function () { return this }, r; function s(g) { return function (S) { return Promise.resolve(S).then(g, p) } } function u(g, S) { o[g] && (r[g] = function (w) { return new Promise(function (I, x) { i.push([g, w, I, x]) > 1 || c(g, w) }) }, S && (r[g] = S(r[g]))) } function c(g, S) { try { d(o[g](S)) } catch (w) { h(i[0][3], w) } } function d(g) { g.value instanceof oe ? Promise.resolve(g.value.v).then(f, p) : h(i[0][2], g) } function f(g) { c("next", g) } function p(g) { c("throw", g) } function h(g, S) { g(S), i.shift(), i.length && c(i[0][0], i[0][1]) } } function Jo(t) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var e = t[Symbol.asyncIterator], n; return e ? e.call(t) : (t = typeof wd == "function" ? wd(t) : t[Symbol.iterator](), n = {}, o("next"), o("throw"), o("return"), n[Symbol.asyncIterator] = function () { return this }, n); function o(i) { n[i] = t[i] && function (s) { return new Promise(function (u, c) { s = t[i](s), r(u, c, s.done, s.value) }) } } function r(i, s, u, c) { Promise.resolve(c).then(function (d) { i({ value: d, done: u }) }, s) } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function cx(t) { var e; if (t.candidates == null || t.candidates.length === 0) return !1; const n = (e = t.candidates[0]) === null || e === void 0 ? void 0 : e.content; return n === void 0 ? !1 : vh(n) } function vh(t) { if (t.parts === void 0 || t.parts.length === 0) return !1; for (const e of t.parts) if (e === void 0 || Object.keys(e).length === 0) return !1; return !0 } function dx(t) { if (t.length !== 0) { for (const e of t) if (e.role !== "user" && e.role !== "model") throw new Error(`Role must be user or model, but got ${e.role}.`) } } function Cd(t) { if (t === void 0 || t.length === 0) return []; const e = [], n = t.length; let o = 0; for (; o < n;)if (t[o].role === "user") e.push(t[o]), o++; else { const r = []; let i = !0; for (; o < n && t[o].role === "model";)r.push(t[o]), i && !vh(t[o]) && (i = !1), o++; i ? e.push(...r) : e.pop() } return e } class fx { constructor(e, n) { this.modelsModule = e, this.apiClient = n } create(e) { return new px(this.apiClient, this.modelsModule, e.model, e.config, structuredClone(e.history)) } } class px { constructor(e, n, o, r = {}, i = []) { this.apiClient = e, this.modelsModule = n, this.model = o, this.config = r, this.history = i, this.sendPromise = Promise.resolve(), dx(i) } async sendMessage(e) { var n; await this.sendPromise; const o = Re(e.message), r = this.modelsModule.generateContent({ model: this.model, contents: this.getHistory(!0).concat(o), config: (n = e.config) !== null && n !== void 0 ? n : this.config }); return this.sendPromise = (async () => { var i, s, u; const c = await r, d = (s = (i = c.candidates) === null || i === void 0 ? void 0 : i[0]) === null || s === void 0 ? void 0 : s.content, f = c.automaticFunctionCallingHistory, p = this.getHistory(!0).length; let h = []; f != null && (h = (u = f.slice(p)) !== null && u !== void 0 ? u : []); const g = d ? [d] : []; this.recordHistory(o, g, h) })(), await this.sendPromise.catch(() => { this.sendPromise = Promise.resolve() }), r } async sendMessageStream(e) { var n; await this.sendPromise; const o = Re(e.message), r = this.modelsModule.generateContentStream({ model: this.model, contents: this.getHistory(!0).concat(o), config: (n = e.config) !== null && n !== void 0 ? n : this.config }); this.sendPromise = r.then(() => { }).catch(() => { }); const i = await r; return this.processStreamResponse(i, o) } getHistory(e = !1) { const n = e ? Cd(this.history) : this.history; return structuredClone(n) } processStreamResponse(e, n) { var o, r; return to(this, arguments, function* () { var s, u, c, d; const f = []; try { for (var p = !0, h = Jo(e), g; g = yield oe(h.next()), s = g.done, !s; p = !0) { d = g.value, p = !1; const S = d; if (cx(S)) { const w = (r = (o = S.candidates) === null || o === void 0 ? void 0 : o[0]) === null || r === void 0 ? void 0 : r.content; w !== void 0 && f.push(w) } yield yield oe(S) } } catch (S) { u = { error: S } } finally { try { !p && !s && (c = h.return) && (yield oe(c.call(h))) } finally { if (u) throw u.error } } this.recordHistory(n, f) }) } recordHistory(e, n, o) { let r = []; n.length > 0 && n.every(i => i.role !== void 0) ? r = n : r.push({ role: "model", parts: [] }), o && o.length > 0 ? this.history.push(...Cd(o)) : this.history.push(e), this.history.push(...r) } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Zi extends Error { constructor(e) { super(e.message), this.name = "ApiError", this.status = e.status, Object.setPrototypeOf(this, Zi.prototype) } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function hx(t) { const e = {}, n = l(t, ["file"]); return n != null && a(e, ["file"], n), e } function mx(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); return n != null && a(e, ["sdkHttpResponse"], n), e } function gx(t) { const e = {}, n = l(t, ["name"]); return n != null && a(e, ["_url", "file"], dh(n)), e } function yx(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); return n != null && a(e, ["sdkHttpResponse"], n), e } function vx(t) { const e = {}, n = l(t, ["name"]); return n != null && a(e, ["_url", "file"], dh(n)), e } function xx(t, e) { const n = {}, o = l(t, ["pageSize"]); e !== void 0 && o != null && a(e, ["_query", "pageSize"], o); const r = l(t, ["pageToken"]); return e !== void 0 && r != null && a(e, ["_query", "pageToken"], r), n } function wx(t) { const e = {}, n = l(t, ["config"]); return n != null && xx(n, e), e } function Cx(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["nextPageToken"]); o != null && a(e, ["nextPageToken"], o); const r = l(t, ["files"]); if (r != null) { let i = r; Array.isArray(i) && (i = i.map(s => s)), a(e, ["files"], i) } return e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Sx extends bt { constructor(e) { super(), this.apiClient = e, this.list = async (n = {}) => new Nn(Ut.PAGED_ITEM_FILES, o => this.listInternal(o), await this.listInternal(n), n) } async upload(e) { if (this.apiClient.isVertexAI()) throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket."); return this.apiClient.uploadFile(e.file, e.config).then(n => n) } async download(e) { await this.apiClient.downloadFile(e) } async listInternal(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const u = wx(e); return i = D("files", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json().then(d => { const f = d; return f.sdkHttpResponse = { headers: c.headers }, f })), r.then(c => { const d = Cx(c), f = new k0; return Object.assign(f, d), f }) } } async createInternal(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const u = hx(e); return i = D("upload/v1beta/files", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json()), r.then(c => { const d = mx(c), f = new I0; return Object.assign(f, d), f }) } } async get(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const u = vx(e); return i = D("files/{file}", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json()), r.then(c => c) } } async delete(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const u = gx(e); return i = D("files/{file}", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "DELETE", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json().then(d => { const f = d; return f.sdkHttpResponse = { headers: c.headers }, f })), r.then(c => { const d = yx(c), f = new N0; return Object.assign(f, d), f }) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function ni(t) { const e = {}, n = l(t, ["data"]); if (n != null && a(e, ["data"], n), l(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const o = l(t, ["mimeType"]); return o != null && a(e, ["mimeType"], o), e } function Tx(t) { const e = {}, n = l(t, ["parts"]); if (n != null) { let r = n; Array.isArray(r) && (r = r.map(i => Gx(i))), a(e, ["parts"], r) } const o = l(t, ["role"]); return o != null && a(e, ["role"], o), e } function _x(t) { const e = {}; if (l(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const n = l(t, ["fileUri"]); n != null && a(e, ["fileUri"], n); const o = l(t, ["mimeType"]); return o != null && a(e, ["mimeType"], o), e } function Ex(t) { const e = {}, n = l(t, ["id"]); n != null && a(e, ["id"], n); const o = l(t, ["args"]); o != null && a(e, ["args"], o); const r = l(t, ["name"]); if (r != null && a(e, ["name"], r), l(t, ["partialArgs"]) !== void 0) throw new Error("partialArgs parameter is not supported in Gemini API."); if (l(t, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API."); return e } function kx(t) { const e = {}; if (l(t, ["behavior"]) !== void 0) throw new Error("behavior parameter is not supported in Vertex AI."); const n = l(t, ["description"]); n != null && a(e, ["description"], n); const o = l(t, ["name"]); o != null && a(e, ["name"], o); const r = l(t, ["parameters"]); r != null && a(e, ["parameters"], r); const i = l(t, ["parametersJsonSchema"]); i != null && a(e, ["parametersJsonSchema"], i); const s = l(t, ["response"]); s != null && a(e, ["response"], s); const u = l(t, ["responseJsonSchema"]); return u != null && a(e, ["responseJsonSchema"], u), e } function Ix(t) { const e = {}, n = l(t, ["modelSelectionConfig"]); n != null && a(e, ["modelConfig"], n); const o = l(t, ["responseJsonSchema"]); o != null && a(e, ["responseJsonSchema"], o); const r = l(t, ["audioTimestamp"]); r != null && a(e, ["audioTimestamp"], r); const i = l(t, ["candidateCount"]); i != null && a(e, ["candidateCount"], i); const s = l(t, ["enableAffectiveDialog"]); s != null && a(e, ["enableAffectiveDialog"], s); const u = l(t, ["frequencyPenalty"]); u != null && a(e, ["frequencyPenalty"], u); const c = l(t, ["logprobs"]); c != null && a(e, ["logprobs"], c); const d = l(t, ["maxOutputTokens"]); d != null && a(e, ["maxOutputTokens"], d); const f = l(t, ["mediaResolution"]); f != null && a(e, ["mediaResolution"], f); const p = l(t, ["presencePenalty"]); p != null && a(e, ["presencePenalty"], p); const h = l(t, ["responseLogprobs"]); h != null && a(e, ["responseLogprobs"], h); const g = l(t, ["responseMimeType"]); g != null && a(e, ["responseMimeType"], g); const S = l(t, ["responseModalities"]); S != null && a(e, ["responseModalities"], S); const w = l(t, ["responseSchema"]); w != null && a(e, ["responseSchema"], w); const I = l(t, ["routingConfig"]); I != null && a(e, ["routingConfig"], I); const x = l(t, ["seed"]); x != null && a(e, ["seed"], x); const y = l(t, ["speechConfig"]); y != null && a(e, ["speechConfig"], xh(y)); const v = l(t, ["stopSequences"]); v != null && a(e, ["stopSequences"], v); const T = l(t, ["temperature"]); T != null && a(e, ["temperature"], T); const E = l(t, ["thinkingConfig"]); E != null && a(e, ["thinkingConfig"], E); const C = l(t, ["topK"]); C != null && a(e, ["topK"], C); const k = l(t, ["topP"]); if (k != null && a(e, ["topP"], k), l(t, ["enableEnhancedCivicAnswers"]) !== void 0) throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI."); return e } function Nx(t) { const e = {}; if (l(t, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API."); const n = l(t, ["enableWidget"]); return n != null && a(e, ["enableWidget"], n), e } function Ax(t) { const e = {}; if (l(t, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API."); if (l(t, ["blockingConfidence"]) !== void 0) throw new Error("blockingConfidence parameter is not supported in Gemini API."); const n = l(t, ["timeRangeFilter"]); return n != null && a(e, ["timeRangeFilter"], n), e } function Rx(t, e) { const n = {}, o = l(t, ["generationConfig"]); e !== void 0 && o != null && a(e, ["setup", "generationConfig"], o); const r = l(t, ["responseModalities"]); e !== void 0 && r != null && a(e, ["setup", "generationConfig", "responseModalities"], r); const i = l(t, ["temperature"]); e !== void 0 && i != null && a(e, ["setup", "generationConfig", "temperature"], i); const s = l(t, ["topP"]); e !== void 0 && s != null && a(e, ["setup", "generationConfig", "topP"], s); const u = l(t, ["topK"]); e !== void 0 && u != null && a(e, ["setup", "generationConfig", "topK"], u); const c = l(t, ["maxOutputTokens"]); e !== void 0 && c != null && a(e, ["setup", "generationConfig", "maxOutputTokens"], c); const d = l(t, ["mediaResolution"]); e !== void 0 && d != null && a(e, ["setup", "generationConfig", "mediaResolution"], d); const f = l(t, ["seed"]); e !== void 0 && f != null && a(e, ["setup", "generationConfig", "seed"], f); const p = l(t, ["speechConfig"]); e !== void 0 && p != null && a(e, ["setup", "generationConfig", "speechConfig"], Ja(p)); const h = l(t, ["thinkingConfig"]); e !== void 0 && h != null && a(e, ["setup", "generationConfig", "thinkingConfig"], h); const g = l(t, ["enableAffectiveDialog"]); e !== void 0 && g != null && a(e, ["setup", "generationConfig", "enableAffectiveDialog"], g); const S = l(t, ["systemInstruction"]); e !== void 0 && S != null && a(e, ["setup", "systemInstruction"], Tx(Re(S))); const w = l(t, ["tools"]); if (e !== void 0 && w != null) { let C = mo(w); Array.isArray(C) && (C = C.map(k => qx(ho(k)))), a(e, ["setup", "tools"], C) } const I = l(t, ["sessionResumption"]); e !== void 0 && I != null && a(e, ["setup", "sessionResumption"], $x(I)); const x = l(t, ["inputAudioTranscription"]); e !== void 0 && x != null && a(e, ["setup", "inputAudioTranscription"], x); const y = l(t, ["outputAudioTranscription"]); e !== void 0 && y != null && a(e, ["setup", "outputAudioTranscription"], y); const v = l(t, ["realtimeInputConfig"]); e !== void 0 && v != null && a(e, ["setup", "realtimeInputConfig"], v); const T = l(t, ["contextWindowCompression"]); e !== void 0 && T != null && a(e, ["setup", "contextWindowCompression"], T); const E = l(t, ["proactivity"]); return e !== void 0 && E != null && a(e, ["setup", "proactivity"], E), n } function Px(t, e) { const n = {}, o = l(t, ["generationConfig"]); e !== void 0 && o != null && a(e, ["setup", "generationConfig"], Ix(o)); const r = l(t, ["responseModalities"]); e !== void 0 && r != null && a(e, ["setup", "generationConfig", "responseModalities"], r); const i = l(t, ["temperature"]); e !== void 0 && i != null && a(e, ["setup", "generationConfig", "temperature"], i); const s = l(t, ["topP"]); e !== void 0 && s != null && a(e, ["setup", "generationConfig", "topP"], s); const u = l(t, ["topK"]); e !== void 0 && u != null && a(e, ["setup", "generationConfig", "topK"], u); const c = l(t, ["maxOutputTokens"]); e !== void 0 && c != null && a(e, ["setup", "generationConfig", "maxOutputTokens"], c); const d = l(t, ["mediaResolution"]); e !== void 0 && d != null && a(e, ["setup", "generationConfig", "mediaResolution"], d); const f = l(t, ["seed"]); e !== void 0 && f != null && a(e, ["setup", "generationConfig", "seed"], f); const p = l(t, ["speechConfig"]); e !== void 0 && p != null && a(e, ["setup", "generationConfig", "speechConfig"], xh(Ja(p))); const h = l(t, ["thinkingConfig"]); e !== void 0 && h != null && a(e, ["setup", "generationConfig", "thinkingConfig"], h); const g = l(t, ["enableAffectiveDialog"]); e !== void 0 && g != null && a(e, ["setup", "generationConfig", "enableAffectiveDialog"], g); const S = l(t, ["systemInstruction"]); e !== void 0 && S != null && a(e, ["setup", "systemInstruction"], Re(S)); const w = l(t, ["tools"]); if (e !== void 0 && w != null) { let C = mo(w); Array.isArray(C) && (C = C.map(k => Hx(ho(k)))), a(e, ["setup", "tools"], C) } const I = l(t, ["sessionResumption"]); e !== void 0 && I != null && a(e, ["setup", "sessionResumption"], I); const x = l(t, ["inputAudioTranscription"]); e !== void 0 && x != null && a(e, ["setup", "inputAudioTranscription"], x); const y = l(t, ["outputAudioTranscription"]); e !== void 0 && y != null && a(e, ["setup", "outputAudioTranscription"], y); const v = l(t, ["realtimeInputConfig"]); e !== void 0 && v != null && a(e, ["setup", "realtimeInputConfig"], v); const T = l(t, ["contextWindowCompression"]); e !== void 0 && T != null && a(e, ["setup", "contextWindowCompression"], T); const E = l(t, ["proactivity"]); return e !== void 0 && E != null && a(e, ["setup", "proactivity"], E), n } function Mx(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["setup", "model"], W(t, o)); const r = l(e, ["config"]); return r != null && a(n, ["config"], Rx(r, n)), n } function Dx(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["setup", "model"], W(t, o)); const r = l(e, ["config"]); return r != null && a(n, ["config"], Px(r, n)), n } function Lx(t) { const e = {}, n = l(t, ["musicGenerationConfig"]); return n != null && a(e, ["musicGenerationConfig"], n), e } function Ux(t) { const e = {}, n = l(t, ["weightedPrompts"]); if (n != null) { let o = n; Array.isArray(o) && (o = o.map(r => r)), a(e, ["weightedPrompts"], o) } return e } function Fx(t) { const e = {}, n = l(t, ["media"]); if (n != null) { let d = sh(n); Array.isArray(d) && (d = d.map(f => ni(f))), a(e, ["mediaChunks"], d) } const o = l(t, ["audio"]); o != null && a(e, ["audio"], ni(ah(o))); const r = l(t, ["audioStreamEnd"]); r != null && a(e, ["audioStreamEnd"], r); const i = l(t, ["video"]); i != null && a(e, ["video"], ni(lh(i))); const s = l(t, ["text"]); s != null && a(e, ["text"], s); const u = l(t, ["activityStart"]); u != null && a(e, ["activityStart"], u); const c = l(t, ["activityEnd"]); return c != null && a(e, ["activityEnd"], c), e } function bx(t) { const e = {}, n = l(t, ["media"]); if (n != null) { let d = sh(n); Array.isArray(d) && (d = d.map(f => f)), a(e, ["mediaChunks"], d) } const o = l(t, ["audio"]); o != null && a(e, ["audio"], ah(o)); const r = l(t, ["audioStreamEnd"]); r != null && a(e, ["audioStreamEnd"], r); const i = l(t, ["video"]); i != null && a(e, ["video"], lh(i)); const s = l(t, ["text"]); s != null && a(e, ["text"], s); const u = l(t, ["activityStart"]); u != null && a(e, ["activityStart"], u); const c = l(t, ["activityEnd"]); return c != null && a(e, ["activityEnd"], c), e } function Vx(t) { const e = {}, n = l(t, ["setupComplete"]); n != null && a(e, ["setupComplete"], n); const o = l(t, ["serverContent"]); o != null && a(e, ["serverContent"], o); const r = l(t, ["toolCall"]); r != null && a(e, ["toolCall"], r); const i = l(t, ["toolCallCancellation"]); i != null && a(e, ["toolCallCancellation"], i); const s = l(t, ["usageMetadata"]); s != null && a(e, ["usageMetadata"], zx(s)); const u = l(t, ["goAway"]); u != null && a(e, ["goAway"], u); const c = l(t, ["sessionResumptionUpdate"]); return c != null && a(e, ["sessionResumptionUpdate"], c), e } function Gx(t) { const e = {}, n = l(t, ["mediaResolution"]); n != null && a(e, ["mediaResolution"], n); const o = l(t, ["codeExecutionResult"]); o != null && a(e, ["codeExecutionResult"], o); const r = l(t, ["executableCode"]); r != null && a(e, ["executableCode"], r); const i = l(t, ["fileData"]); i != null && a(e, ["fileData"], _x(i)); const s = l(t, ["functionCall"]); s != null && a(e, ["functionCall"], Ex(s)); const u = l(t, ["functionResponse"]); u != null && a(e, ["functionResponse"], u); const c = l(t, ["inlineData"]); c != null && a(e, ["inlineData"], ni(c)); const d = l(t, ["text"]); d != null && a(e, ["text"], d); const f = l(t, ["thought"]); f != null && a(e, ["thought"], f); const p = l(t, ["thoughtSignature"]); p != null && a(e, ["thoughtSignature"], p); const h = l(t, ["videoMetadata"]); return h != null && a(e, ["videoMetadata"], h), e } function $x(t) { const e = {}, n = l(t, ["handle"]); if (n != null && a(e, ["handle"], n), l(t, ["transparent"]) !== void 0) throw new Error("transparent parameter is not supported in Gemini API."); return e } function xh(t) { const e = {}, n = l(t, ["languageCode"]); n != null && a(e, ["languageCode"], n); const o = l(t, ["voiceConfig"]); if (o != null && a(e, ["voiceConfig"], o), l(t, ["multiSpeakerVoiceConfig"]) !== void 0) throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI."); return e } function qx(t) { const e = {}, n = l(t, ["functionDeclarations"]); if (n != null) { let f = n; Array.isArray(f) && (f = f.map(p => p)), a(e, ["functionDeclarations"], f) } if (l(t, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API."); const o = l(t, ["googleSearchRetrieval"]); o != null && a(e, ["googleSearchRetrieval"], o); const r = l(t, ["computerUse"]); r != null && a(e, ["computerUse"], r); const i = l(t, ["fileSearch"]); i != null && a(e, ["fileSearch"], i); const s = l(t, ["codeExecution"]); if (s != null && a(e, ["codeExecution"], s), l(t, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API."); const u = l(t, ["googleMaps"]); u != null && a(e, ["googleMaps"], Nx(u)); const c = l(t, ["googleSearch"]); c != null && a(e, ["googleSearch"], Ax(c)); const d = l(t, ["urlContext"]); return d != null && a(e, ["urlContext"], d), e } function Hx(t) { const e = {}, n = l(t, ["functionDeclarations"]); if (n != null) { let p = n; Array.isArray(p) && (p = p.map(h => kx(h))), a(e, ["functionDeclarations"], p) } const o = l(t, ["retrieval"]); o != null && a(e, ["retrieval"], o); const r = l(t, ["googleSearchRetrieval"]); r != null && a(e, ["googleSearchRetrieval"], r); const i = l(t, ["computerUse"]); if (i != null && a(e, ["computerUse"], i), l(t, ["fileSearch"]) !== void 0) throw new Error("fileSearch parameter is not supported in Vertex AI."); const s = l(t, ["codeExecution"]); s != null && a(e, ["codeExecution"], s); const u = l(t, ["enterpriseWebSearch"]); u != null && a(e, ["enterpriseWebSearch"], u); const c = l(t, ["googleMaps"]); c != null && a(e, ["googleMaps"], c); const d = l(t, ["googleSearch"]); d != null && a(e, ["googleSearch"], d); const f = l(t, ["urlContext"]); return f != null && a(e, ["urlContext"], f), e } function zx(t) { const e = {}, n = l(t, ["promptTokenCount"]); n != null && a(e, ["promptTokenCount"], n); const o = l(t, ["cachedContentTokenCount"]); o != null && a(e, ["cachedContentTokenCount"], o); const r = l(t, ["candidatesTokenCount"]); r != null && a(e, ["responseTokenCount"], r); const i = l(t, ["toolUsePromptTokenCount"]); i != null && a(e, ["toolUsePromptTokenCount"], i); const s = l(t, ["thoughtsTokenCount"]); s != null && a(e, ["thoughtsTokenCount"], s); const u = l(t, ["totalTokenCount"]); u != null && a(e, ["totalTokenCount"], u); const c = l(t, ["promptTokensDetails"]); if (c != null) { let g = c; Array.isArray(g) && (g = g.map(S => S)), a(e, ["promptTokensDetails"], g) } const d = l(t, ["cacheTokensDetails"]); if (d != null) { let g = d; Array.isArray(g) && (g = g.map(S => S)), a(e, ["cacheTokensDetails"], g) } const f = l(t, ["candidatesTokensDetails"]); if (f != null) { let g = f; Array.isArray(g) && (g = g.map(S => S)), a(e, ["responseTokensDetails"], g) } const p = l(t, ["toolUsePromptTokensDetails"]); if (p != null) { let g = p; Array.isArray(g) && (g = g.map(S => S)), a(e, ["toolUsePromptTokensDetails"], g) } const h = l(t, ["trafficType"]); return h != null && a(e, ["trafficType"], h), e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Bx(t) { const e = {}, n = l(t, ["data"]); if (n != null && a(e, ["data"], n), l(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const o = l(t, ["mimeType"]); return o != null && a(e, ["mimeType"], o), e } function Jx(t) { const e = {}, n = l(t, ["content"]); n != null && a(e, ["content"], n); const o = l(t, ["citationMetadata"]); o != null && a(e, ["citationMetadata"], Wx(o)); const r = l(t, ["tokenCount"]); r != null && a(e, ["tokenCount"], r); const i = l(t, ["finishReason"]); i != null && a(e, ["finishReason"], i); const s = l(t, ["avgLogprobs"]); s != null && a(e, ["avgLogprobs"], s); const u = l(t, ["groundingMetadata"]); u != null && a(e, ["groundingMetadata"], u); const c = l(t, ["index"]); c != null && a(e, ["index"], c); const d = l(t, ["logprobsResult"]); d != null && a(e, ["logprobsResult"], d); const f = l(t, ["safetyRatings"]); if (f != null) { let h = f; Array.isArray(h) && (h = h.map(g => g)), a(e, ["safetyRatings"], h) } const p = l(t, ["urlContextMetadata"]); return p != null && a(e, ["urlContextMetadata"], p), e } function Wx(t) { const e = {}, n = l(t, ["citationSources"]); if (n != null) { let o = n; Array.isArray(o) && (o = o.map(r => r)), a(e, ["citations"], o) } return e } function Yx(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "model"], W(t, o)); const r = l(e, ["contents"]); if (r != null) { let i = ot(r); Array.isArray(i) && (i = i.map(s => s)), a(n, ["contents"], i) } return n } function Kx(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["tokensInfo"]); if (o != null) { let r = o; Array.isArray(r) && (r = r.map(i => i)), a(e, ["tokensInfo"], r) } return e } function Ox(t) { const e = {}, n = l(t, ["values"]); n != null && a(e, ["values"], n); const o = l(t, ["statistics"]); return o != null && a(e, ["statistics"], Qx(o)), e } function Qx(t) { const e = {}, n = l(t, ["truncated"]); n != null && a(e, ["truncated"], n); const o = l(t, ["token_count"]); return o != null && a(e, ["tokenCount"], o), e } function ji(t) { const e = {}, n = l(t, ["parts"]); if (n != null) { let r = n; Array.isArray(r) && (r = r.map(i => iC(i))), a(e, ["parts"], r) } const o = l(t, ["role"]); return o != null && a(e, ["role"], o), e } function Xx(t) { const e = {}, n = l(t, ["controlType"]); n != null && a(e, ["controlType"], n); const o = l(t, ["enableControlImageComputation"]); return o != null && a(e, ["computeControl"], o), e } function Zx(t) { const e = {}; if (l(t, ["systemInstruction"]) !== void 0) throw new Error("systemInstruction parameter is not supported in Gemini API."); if (l(t, ["tools"]) !== void 0) throw new Error("tools parameter is not supported in Gemini API."); if (l(t, ["generationConfig"]) !== void 0) throw new Error("generationConfig parameter is not supported in Gemini API."); return e } function jx(t, e) { const n = {}, o = l(t, ["systemInstruction"]); e !== void 0 && o != null && a(e, ["systemInstruction"], Re(o)); const r = l(t, ["tools"]); if (e !== void 0 && r != null) { let s = r; Array.isArray(s) && (s = s.map(u => _h(u))), a(e, ["tools"], s) } const i = l(t, ["generationConfig"]); return e !== void 0 && i != null && a(e, ["generationConfig"], Bw(i)), n } function ew(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "model"], W(t, o)); const r = l(e, ["contents"]); if (r != null) { let s = ot(r); Array.isArray(s) && (s = s.map(u => ji(u))), a(n, ["contents"], s) } const i = l(e, ["config"]); return i != null && Zx(i), n } function tw(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "model"], W(t, o)); const r = l(e, ["contents"]); if (r != null) { let s = ot(r); Array.isArray(s) && (s = s.map(u => u)), a(n, ["contents"], s) } const i = l(e, ["config"]); return i != null && jx(i, n), n } function nw(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["totalTokens"]); o != null && a(e, ["totalTokens"], o); const r = l(t, ["cachedContentTokenCount"]); return r != null && a(e, ["cachedContentTokenCount"], r), e } function ow(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["totalTokens"]); return o != null && a(e, ["totalTokens"], o), e } function rw(t, e) { const n = {}, o = l(e, ["model"]); return o != null && a(n, ["_url", "name"], W(t, o)), n } function iw(t, e) { const n = {}, o = l(e, ["model"]); return o != null && a(n, ["_url", "name"], W(t, o)), n } function sw(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); return n != null && a(e, ["sdkHttpResponse"], n), e } function lw(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); return n != null && a(e, ["sdkHttpResponse"], n), e } function aw(t, e) { const n = {}, o = l(t, ["outputGcsUri"]); e !== void 0 && o != null && a(e, ["parameters", "storageUri"], o); const r = l(t, ["negativePrompt"]); e !== void 0 && r != null && a(e, ["parameters", "negativePrompt"], r); const i = l(t, ["numberOfImages"]); e !== void 0 && i != null && a(e, ["parameters", "sampleCount"], i); const s = l(t, ["aspectRatio"]); e !== void 0 && s != null && a(e, ["parameters", "aspectRatio"], s); const u = l(t, ["guidanceScale"]); e !== void 0 && u != null && a(e, ["parameters", "guidanceScale"], u); const c = l(t, ["seed"]); e !== void 0 && c != null && a(e, ["parameters", "seed"], c); const d = l(t, ["safetyFilterLevel"]); e !== void 0 && d != null && a(e, ["parameters", "safetySetting"], d); const f = l(t, ["personGeneration"]); e !== void 0 && f != null && a(e, ["parameters", "personGeneration"], f); const p = l(t, ["includeSafetyAttributes"]); e !== void 0 && p != null && a(e, ["parameters", "includeSafetyAttributes"], p); const h = l(t, ["includeRaiReason"]); e !== void 0 && h != null && a(e, ["parameters", "includeRaiReason"], h); const g = l(t, ["language"]); e !== void 0 && g != null && a(e, ["parameters", "language"], g); const S = l(t, ["outputMimeType"]); e !== void 0 && S != null && a(e, ["parameters", "outputOptions", "mimeType"], S); const w = l(t, ["outputCompressionQuality"]); e !== void 0 && w != null && a(e, ["parameters", "outputOptions", "compressionQuality"], w); const I = l(t, ["addWatermark"]); e !== void 0 && I != null && a(e, ["parameters", "addWatermark"], I); const x = l(t, ["labels"]); e !== void 0 && x != null && a(e, ["labels"], x); const y = l(t, ["editMode"]); e !== void 0 && y != null && a(e, ["parameters", "editMode"], y); const v = l(t, ["baseSteps"]); return e !== void 0 && v != null && a(e, ["parameters", "editConfig", "baseSteps"], v), n } function uw(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "model"], W(t, o)); const r = l(e, ["prompt"]); r != null && a(n, ["instances[0]", "prompt"], r); const i = l(e, ["referenceImages"]); if (i != null) { let u = i; Array.isArray(u) && (u = u.map(c => dC(c))), a(n, ["instances[0]", "referenceImages"], u) } const s = l(e, ["config"]); return s != null && aw(s, n), n } function cw(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["predictions"]); if (o != null) { let r = o; Array.isArray(r) && (r = r.map(i => es(i))), a(e, ["generatedImages"], r) } return e } function dw(t, e) { const n = {}, o = l(t, ["taskType"]); e !== void 0 && o != null && a(e, ["requests[]", "taskType"], o); const r = l(t, ["title"]); e !== void 0 && r != null && a(e, ["requests[]", "title"], r); const i = l(t, ["outputDimensionality"]); if (e !== void 0 && i != null && a(e, ["requests[]", "outputDimensionality"], i), l(t, ["mimeType"]) !== void 0) throw new Error("mimeType parameter is not supported in Gemini API."); if (l(t, ["autoTruncate"]) !== void 0) throw new Error("autoTruncate parameter is not supported in Gemini API."); return n } function fw(t, e) { const n = {}, o = l(t, ["taskType"]); e !== void 0 && o != null && a(e, ["instances[]", "task_type"], o); const r = l(t, ["title"]); e !== void 0 && r != null && a(e, ["instances[]", "title"], r); const i = l(t, ["outputDimensionality"]); e !== void 0 && i != null && a(e, ["parameters", "outputDimensionality"], i); const s = l(t, ["mimeType"]); e !== void 0 && s != null && a(e, ["instances[]", "mimeType"], s); const u = l(t, ["autoTruncate"]); return e !== void 0 && u != null && a(e, ["parameters", "autoTruncate"], u), n } function pw(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "model"], W(t, o)); const r = l(e, ["contents"]); if (r != null) { let u = Ha(t, r); Array.isArray(u) && (u = u.map(c => c)), a(n, ["requests[]", "content"], u) } const i = l(e, ["config"]); i != null && dw(i, n); const s = l(e, ["model"]); return s !== void 0 && a(n, ["requests[]", "model"], W(t, s)), n } function hw(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "model"], W(t, o)); const r = l(e, ["contents"]); if (r != null) { let s = Ha(t, r); Array.isArray(s) && (s = s.map(u => u)), a(n, ["instances[]", "content"], s) } const i = l(e, ["config"]); return i != null && fw(i, n), n } function mw(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["embeddings"]); if (o != null) { let i = o; Array.isArray(i) && (i = i.map(s => s)), a(e, ["embeddings"], i) } const r = l(t, ["metadata"]); return r != null && a(e, ["metadata"], r), e } function gw(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["predictions[]", "embeddings"]); if (o != null) { let i = o; Array.isArray(i) && (i = i.map(s => Ox(s))), a(e, ["embeddings"], i) } const r = l(t, ["metadata"]); return r != null && a(e, ["metadata"], r), e } function yw(t) { const e = {}, n = l(t, ["endpoint"]); n != null && a(e, ["name"], n); const o = l(t, ["deployedModelId"]); return o != null && a(e, ["deployedModelId"], o), e } function vw(t) { const e = {}; if (l(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const n = l(t, ["fileUri"]); n != null && a(e, ["fileUri"], n); const o = l(t, ["mimeType"]); return o != null && a(e, ["mimeType"], o), e } function xw(t) { const e = {}, n = l(t, ["id"]); n != null && a(e, ["id"], n); const o = l(t, ["args"]); o != null && a(e, ["args"], o); const r = l(t, ["name"]); if (r != null && a(e, ["name"], r), l(t, ["partialArgs"]) !== void 0) throw new Error("partialArgs parameter is not supported in Gemini API."); if (l(t, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API."); return e } function ww(t) { const e = {}, n = l(t, ["mode"]); n != null && a(e, ["mode"], n); const o = l(t, ["allowedFunctionNames"]); if (o != null && a(e, ["allowedFunctionNames"], o), l(t, ["streamFunctionCallArguments"]) !== void 0) throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API."); return e } function Cw(t) { const e = {}; if (l(t, ["behavior"]) !== void 0) throw new Error("behavior parameter is not supported in Vertex AI."); const n = l(t, ["description"]); n != null && a(e, ["description"], n); const o = l(t, ["name"]); o != null && a(e, ["name"], o); const r = l(t, ["parameters"]); r != null && a(e, ["parameters"], r); const i = l(t, ["parametersJsonSchema"]); i != null && a(e, ["parametersJsonSchema"], i); const s = l(t, ["response"]); s != null && a(e, ["response"], s); const u = l(t, ["responseJsonSchema"]); return u != null && a(e, ["responseJsonSchema"], u), e } function Sw(t, e, n) { const o = {}, r = l(e, ["systemInstruction"]); n !== void 0 && r != null && a(n, ["systemInstruction"], ji(Re(r))); const i = l(e, ["temperature"]); i != null && a(o, ["temperature"], i); const s = l(e, ["topP"]); s != null && a(o, ["topP"], s); const u = l(e, ["topK"]); u != null && a(o, ["topK"], u); const c = l(e, ["candidateCount"]); c != null && a(o, ["candidateCount"], c); const d = l(e, ["maxOutputTokens"]); d != null && a(o, ["maxOutputTokens"], d); const f = l(e, ["stopSequences"]); f != null && a(o, ["stopSequences"], f); const p = l(e, ["responseLogprobs"]); p != null && a(o, ["responseLogprobs"], p); const h = l(e, ["logprobs"]); h != null && a(o, ["logprobs"], h); const g = l(e, ["presencePenalty"]); g != null && a(o, ["presencePenalty"], g); const S = l(e, ["frequencyPenalty"]); S != null && a(o, ["frequencyPenalty"], S); const w = l(e, ["seed"]); w != null && a(o, ["seed"], w); const I = l(e, ["responseMimeType"]); I != null && a(o, ["responseMimeType"], I); const x = l(e, ["responseSchema"]); x != null && a(o, ["responseSchema"], za(x)); const y = l(e, ["responseJsonSchema"]); if (y != null && a(o, ["responseJsonSchema"], y), l(e, ["routingConfig"]) !== void 0) throw new Error("routingConfig parameter is not supported in Gemini API."); if (l(e, ["modelSelectionConfig"]) !== void 0) throw new Error("modelSelectionConfig parameter is not supported in Gemini API."); const v = l(e, ["safetySettings"]); if (n !== void 0 && v != null) { let z = v; Array.isArray(z) && (z = z.map(se => fC(se))), a(n, ["safetySettings"], z) } const T = l(e, ["tools"]); if (n !== void 0 && T != null) { let z = mo(T); Array.isArray(z) && (z = z.map(se => xC(ho(se)))), a(n, ["tools"], z) } const E = l(e, ["toolConfig"]); if (n !== void 0 && E != null && a(n, ["toolConfig"], vC(E)), l(e, ["labels"]) !== void 0) throw new Error("labels parameter is not supported in Gemini API."); const C = l(e, ["cachedContent"]); n !== void 0 && C != null && a(n, ["cachedContent"], Vt(t, C)); const k = l(e, ["responseModalities"]); k != null && a(o, ["responseModalities"], k); const A = l(e, ["mediaResolution"]); A != null && a(o, ["mediaResolution"], A); const N = l(e, ["speechConfig"]); if (N != null && a(o, ["speechConfig"], Ba(N)), l(e, ["audioTimestamp"]) !== void 0) throw new Error("audioTimestamp parameter is not supported in Gemini API."); const M = l(e, ["thinkingConfig"]); M != null && a(o, ["thinkingConfig"], M); const b = l(e, ["imageConfig"]); return b != null && a(o, ["imageConfig"], Ow(b)), o } function Tw(t, e, n) { const o = {}, r = l(e, ["systemInstruction"]); n !== void 0 && r != null && a(n, ["systemInstruction"], Re(r)); const i = l(e, ["temperature"]); i != null && a(o, ["temperature"], i); const s = l(e, ["topP"]); s != null && a(o, ["topP"], s); const u = l(e, ["topK"]); u != null && a(o, ["topK"], u); const c = l(e, ["candidateCount"]); c != null && a(o, ["candidateCount"], c); const d = l(e, ["maxOutputTokens"]); d != null && a(o, ["maxOutputTokens"], d); const f = l(e, ["stopSequences"]); f != null && a(o, ["stopSequences"], f); const p = l(e, ["responseLogprobs"]); p != null && a(o, ["responseLogprobs"], p); const h = l(e, ["logprobs"]); h != null && a(o, ["logprobs"], h); const g = l(e, ["presencePenalty"]); g != null && a(o, ["presencePenalty"], g); const S = l(e, ["frequencyPenalty"]); S != null && a(o, ["frequencyPenalty"], S); const w = l(e, ["seed"]); w != null && a(o, ["seed"], w); const I = l(e, ["responseMimeType"]); I != null && a(o, ["responseMimeType"], I); const x = l(e, ["responseSchema"]); x != null && a(o, ["responseSchema"], za(x)); const y = l(e, ["responseJsonSchema"]); y != null && a(o, ["responseJsonSchema"], y); const v = l(e, ["routingConfig"]); v != null && a(o, ["routingConfig"], v); const T = l(e, ["modelSelectionConfig"]); T != null && a(o, ["modelConfig"], T); const E = l(e, ["safetySettings"]); if (n !== void 0 && E != null) { let he = E; Array.isArray(he) && (he = he.map(Ce => Ce)), a(n, ["safetySettings"], he) } const C = l(e, ["tools"]); if (n !== void 0 && C != null) { let he = mo(C); Array.isArray(he) && (he = he.map(Ce => _h(ho(Ce)))), a(n, ["tools"], he) } const k = l(e, ["toolConfig"]); n !== void 0 && k != null && a(n, ["toolConfig"], k); const A = l(e, ["labels"]); n !== void 0 && A != null && a(n, ["labels"], A); const N = l(e, ["cachedContent"]); n !== void 0 && N != null && a(n, ["cachedContent"], Vt(t, N)); const M = l(e, ["responseModalities"]); M != null && a(o, ["responseModalities"], M); const b = l(e, ["mediaResolution"]); b != null && a(o, ["mediaResolution"], b); const z = l(e, ["speechConfig"]); z != null && a(o, ["speechConfig"], Th(Ba(z))); const se = l(e, ["audioTimestamp"]); se != null && a(o, ["audioTimestamp"], se); const ht = l(e, ["thinkingConfig"]); ht != null && a(o, ["thinkingConfig"], ht); const mt = l(e, ["imageConfig"]); return mt != null && a(o, ["imageConfig"], Qw(mt)), o } function Sd(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "model"], W(t, o)); const r = l(e, ["contents"]); if (r != null) { let s = ot(r); Array.isArray(s) && (s = s.map(u => ji(u))), a(n, ["contents"], s) } const i = l(e, ["config"]); return i != null && a(n, ["generationConfig"], Sw(t, i, n)), n } function Td(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "model"], W(t, o)); const r = l(e, ["contents"]); if (r != null) { let s = ot(r); Array.isArray(s) && (s = s.map(u => u)), a(n, ["contents"], s) } const i = l(e, ["config"]); return i != null && a(n, ["generationConfig"], Tw(t, i, n)), n } function _d(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["candidates"]); if (o != null) { let c = o; Array.isArray(c) && (c = c.map(d => Jx(d))), a(e, ["candidates"], c) } const r = l(t, ["modelVersion"]); r != null && a(e, ["modelVersion"], r); const i = l(t, ["promptFeedback"]); i != null && a(e, ["promptFeedback"], i); const s = l(t, ["responseId"]); s != null && a(e, ["responseId"], s); const u = l(t, ["usageMetadata"]); return u != null && a(e, ["usageMetadata"], u), e } function Ed(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["candidates"]); if (o != null) { let d = o; Array.isArray(d) && (d = d.map(f => f)), a(e, ["candidates"], d) } const r = l(t, ["createTime"]); r != null && a(e, ["createTime"], r); const i = l(t, ["modelVersion"]); i != null && a(e, ["modelVersion"], i); const s = l(t, ["promptFeedback"]); s != null && a(e, ["promptFeedback"], s); const u = l(t, ["responseId"]); u != null && a(e, ["responseId"], u); const c = l(t, ["usageMetadata"]); return c != null && a(e, ["usageMetadata"], c), e } function _w(t, e) { const n = {}; if (l(t, ["outputGcsUri"]) !== void 0) throw new Error("outputGcsUri parameter is not supported in Gemini API."); if (l(t, ["negativePrompt"]) !== void 0) throw new Error("negativePrompt parameter is not supported in Gemini API."); const o = l(t, ["numberOfImages"]); e !== void 0 && o != null && a(e, ["parameters", "sampleCount"], o); const r = l(t, ["aspectRatio"]); e !== void 0 && r != null && a(e, ["parameters", "aspectRatio"], r); const i = l(t, ["guidanceScale"]); if (e !== void 0 && i != null && a(e, ["parameters", "guidanceScale"], i), l(t, ["seed"]) !== void 0) throw new Error("seed parameter is not supported in Gemini API."); const s = l(t, ["safetyFilterLevel"]); e !== void 0 && s != null && a(e, ["parameters", "safetySetting"], s); const u = l(t, ["personGeneration"]); e !== void 0 && u != null && a(e, ["parameters", "personGeneration"], u); const c = l(t, ["includeSafetyAttributes"]); e !== void 0 && c != null && a(e, ["parameters", "includeSafetyAttributes"], c); const d = l(t, ["includeRaiReason"]); e !== void 0 && d != null && a(e, ["parameters", "includeRaiReason"], d); const f = l(t, ["language"]); e !== void 0 && f != null && a(e, ["parameters", "language"], f); const p = l(t, ["outputMimeType"]); e !== void 0 && p != null && a(e, ["parameters", "outputOptions", "mimeType"], p); const h = l(t, ["outputCompressionQuality"]); if (e !== void 0 && h != null && a(e, ["parameters", "outputOptions", "compressionQuality"], h), l(t, ["addWatermark"]) !== void 0) throw new Error("addWatermark parameter is not supported in Gemini API."); if (l(t, ["labels"]) !== void 0) throw new Error("labels parameter is not supported in Gemini API."); const g = l(t, ["imageSize"]); if (e !== void 0 && g != null && a(e, ["parameters", "sampleImageSize"], g), l(t, ["enhancePrompt"]) !== void 0) throw new Error("enhancePrompt parameter is not supported in Gemini API."); return n } function Ew(t, e) { const n = {}, o = l(t, ["outputGcsUri"]); e !== void 0 && o != null && a(e, ["parameters", "storageUri"], o); const r = l(t, ["negativePrompt"]); e !== void 0 && r != null && a(e, ["parameters", "negativePrompt"], r); const i = l(t, ["numberOfImages"]); e !== void 0 && i != null && a(e, ["parameters", "sampleCount"], i); const s = l(t, ["aspectRatio"]); e !== void 0 && s != null && a(e, ["parameters", "aspectRatio"], s); const u = l(t, ["guidanceScale"]); e !== void 0 && u != null && a(e, ["parameters", "guidanceScale"], u); const c = l(t, ["seed"]); e !== void 0 && c != null && a(e, ["parameters", "seed"], c); const d = l(t, ["safetyFilterLevel"]); e !== void 0 && d != null && a(e, ["parameters", "safetySetting"], d); const f = l(t, ["personGeneration"]); e !== void 0 && f != null && a(e, ["parameters", "personGeneration"], f); const p = l(t, ["includeSafetyAttributes"]); e !== void 0 && p != null && a(e, ["parameters", "includeSafetyAttributes"], p); const h = l(t, ["includeRaiReason"]); e !== void 0 && h != null && a(e, ["parameters", "includeRaiReason"], h); const g = l(t, ["language"]); e !== void 0 && g != null && a(e, ["parameters", "language"], g); const S = l(t, ["outputMimeType"]); e !== void 0 && S != null && a(e, ["parameters", "outputOptions", "mimeType"], S); const w = l(t, ["outputCompressionQuality"]); e !== void 0 && w != null && a(e, ["parameters", "outputOptions", "compressionQuality"], w); const I = l(t, ["addWatermark"]); e !== void 0 && I != null && a(e, ["parameters", "addWatermark"], I); const x = l(t, ["labels"]); e !== void 0 && x != null && a(e, ["labels"], x); const y = l(t, ["imageSize"]); e !== void 0 && y != null && a(e, ["parameters", "sampleImageSize"], y); const v = l(t, ["enhancePrompt"]); return e !== void 0 && v != null && a(e, ["parameters", "enhancePrompt"], v), n } function kw(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "model"], W(t, o)); const r = l(e, ["prompt"]); r != null && a(n, ["instances[0]", "prompt"], r); const i = l(e, ["config"]); return i != null && _w(i, n), n } function Iw(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "model"], W(t, o)); const r = l(e, ["prompt"]); r != null && a(n, ["instances[0]", "prompt"], r); const i = l(e, ["config"]); return i != null && Ew(i, n), n } function Nw(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["predictions"]); if (o != null) { let i = o; Array.isArray(i) && (i = i.map(s => $w(s))), a(e, ["generatedImages"], i) } const r = l(t, ["positivePromptSafetyAttributes"]); return r != null && a(e, ["positivePromptSafetyAttributes"], Ch(r)), e } function Aw(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["predictions"]); if (o != null) { let i = o; Array.isArray(i) && (i = i.map(s => es(s))), a(e, ["generatedImages"], i) } const r = l(t, ["positivePromptSafetyAttributes"]); return r != null && a(e, ["positivePromptSafetyAttributes"], Sh(r)), e } function Rw(t, e) { const n = {}, o = l(t, ["numberOfVideos"]); if (e !== void 0 && o != null && a(e, ["parameters", "sampleCount"], o), l(t, ["outputGcsUri"]) !== void 0) throw new Error("outputGcsUri parameter is not supported in Gemini API."); if (l(t, ["fps"]) !== void 0) throw new Error("fps parameter is not supported in Gemini API."); const r = l(t, ["durationSeconds"]); if (e !== void 0 && r != null && a(e, ["parameters", "durationSeconds"], r), l(t, ["seed"]) !== void 0) throw new Error("seed parameter is not supported in Gemini API."); const i = l(t, ["aspectRatio"]); e !== void 0 && i != null && a(e, ["parameters", "aspectRatio"], i); const s = l(t, ["resolution"]); e !== void 0 && s != null && a(e, ["parameters", "resolution"], s); const u = l(t, ["personGeneration"]); if (e !== void 0 && u != null && a(e, ["parameters", "personGeneration"], u), l(t, ["pubsubTopic"]) !== void 0) throw new Error("pubsubTopic parameter is not supported in Gemini API."); const c = l(t, ["negativePrompt"]); e !== void 0 && c != null && a(e, ["parameters", "negativePrompt"], c); const d = l(t, ["enhancePrompt"]); if (e !== void 0 && d != null && a(e, ["parameters", "enhancePrompt"], d), l(t, ["generateAudio"]) !== void 0) throw new Error("generateAudio parameter is not supported in Gemini API."); const f = l(t, ["lastFrame"]); e !== void 0 && f != null && a(e, ["instances[0]", "lastFrame"], ts(f)); const p = l(t, ["referenceImages"]); if (e !== void 0 && p != null) { let h = p; Array.isArray(h) && (h = h.map(g => MC(g))), a(e, ["instances[0]", "referenceImages"], h) } if (l(t, ["mask"]) !== void 0) throw new Error("mask parameter is not supported in Gemini API."); if (l(t, ["compressionQuality"]) !== void 0) throw new Error("compressionQuality parameter is not supported in Gemini API."); return n } function Pw(t, e) { const n = {}, o = l(t, ["numberOfVideos"]); e !== void 0 && o != null && a(e, ["parameters", "sampleCount"], o); const r = l(t, ["outputGcsUri"]); e !== void 0 && r != null && a(e, ["parameters", "storageUri"], r); const i = l(t, ["fps"]); e !== void 0 && i != null && a(e, ["parameters", "fps"], i); const s = l(t, ["durationSeconds"]); e !== void 0 && s != null && a(e, ["parameters", "durationSeconds"], s); const u = l(t, ["seed"]); e !== void 0 && u != null && a(e, ["parameters", "seed"], u); const c = l(t, ["aspectRatio"]); e !== void 0 && c != null && a(e, ["parameters", "aspectRatio"], c); const d = l(t, ["resolution"]); e !== void 0 && d != null && a(e, ["parameters", "resolution"], d); const f = l(t, ["personGeneration"]); e !== void 0 && f != null && a(e, ["parameters", "personGeneration"], f); const p = l(t, ["pubsubTopic"]); e !== void 0 && p != null && a(e, ["parameters", "pubsubTopic"], p); const h = l(t, ["negativePrompt"]); e !== void 0 && h != null && a(e, ["parameters", "negativePrompt"], h); const g = l(t, ["enhancePrompt"]); e !== void 0 && g != null && a(e, ["parameters", "enhancePrompt"], g); const S = l(t, ["generateAudio"]); e !== void 0 && S != null && a(e, ["parameters", "generateAudio"], S); const w = l(t, ["lastFrame"]); e !== void 0 && w != null && a(e, ["instances[0]", "lastFrame"], pt(w)); const I = l(t, ["referenceImages"]); if (e !== void 0 && I != null) { let v = I; Array.isArray(v) && (v = v.map(T => DC(T))), a(e, ["instances[0]", "referenceImages"], v) } const x = l(t, ["mask"]); e !== void 0 && x != null && a(e, ["instances[0]", "mask"], PC(x)); const y = l(t, ["compressionQuality"]); return e !== void 0 && y != null && a(e, ["parameters", "compressionQuality"], y), n } function Mw(t) { const e = {}, n = l(t, ["name"]); n != null && a(e, ["name"], n); const o = l(t, ["metadata"]); o != null && a(e, ["metadata"], o); const r = l(t, ["done"]); r != null && a(e, ["done"], r); const i = l(t, ["error"]); i != null && a(e, ["error"], i); const s = l(t, ["response", "generateVideoResponse"]); return s != null && a(e, ["response"], Fw(s)), e } function Dw(t) { const e = {}, n = l(t, ["name"]); n != null && a(e, ["name"], n); const o = l(t, ["metadata"]); o != null && a(e, ["metadata"], o); const r = l(t, ["done"]); r != null && a(e, ["done"], r); const i = l(t, ["error"]); i != null && a(e, ["error"], i); const s = l(t, ["response"]); return s != null && a(e, ["response"], bw(s)), e } function Lw(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "model"], W(t, o)); const r = l(e, ["prompt"]); r != null && a(n, ["instances[0]", "prompt"], r); const i = l(e, ["image"]); i != null && a(n, ["instances[0]", "image"], ts(i)); const s = l(e, ["video"]); s != null && a(n, ["instances[0]", "video"], Eh(s)); const u = l(e, ["source"]); u != null && Vw(u, n); const c = l(e, ["config"]); return c != null && Rw(c, n), n } function Uw(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "model"], W(t, o)); const r = l(e, ["prompt"]); r != null && a(n, ["instances[0]", "prompt"], r); const i = l(e, ["image"]); i != null && a(n, ["instances[0]", "image"], pt(i)); const s = l(e, ["video"]); s != null && a(n, ["instances[0]", "video"], kh(s)); const u = l(e, ["source"]); u != null && Gw(u, n); const c = l(e, ["config"]); return c != null && Pw(c, n), n } function Fw(t) { const e = {}, n = l(t, ["generatedSamples"]); if (n != null) { let i = n; Array.isArray(i) && (i = i.map(s => Hw(s))), a(e, ["generatedVideos"], i) } const o = l(t, ["raiMediaFilteredCount"]); o != null && a(e, ["raiMediaFilteredCount"], o); const r = l(t, ["raiMediaFilteredReasons"]); return r != null && a(e, ["raiMediaFilteredReasons"], r), e } function bw(t) { const e = {}, n = l(t, ["videos"]); if (n != null) { let i = n; Array.isArray(i) && (i = i.map(s => zw(s))), a(e, ["generatedVideos"], i) } const o = l(t, ["raiMediaFilteredCount"]); o != null && a(e, ["raiMediaFilteredCount"], o); const r = l(t, ["raiMediaFilteredReasons"]); return r != null && a(e, ["raiMediaFilteredReasons"], r), e } function Vw(t, e) { const n = {}, o = l(t, ["prompt"]); e !== void 0 && o != null && a(e, ["instances[0]", "prompt"], o); const r = l(t, ["image"]); e !== void 0 && r != null && a(e, ["instances[0]", "image"], ts(r)); const i = l(t, ["video"]); return e !== void 0 && i != null && a(e, ["instances[0]", "video"], Eh(i)), n } function Gw(t, e) { const n = {}, o = l(t, ["prompt"]); e !== void 0 && o != null && a(e, ["instances[0]", "prompt"], o); const r = l(t, ["image"]); e !== void 0 && r != null && a(e, ["instances[0]", "image"], pt(r)); const i = l(t, ["video"]); return e !== void 0 && i != null && a(e, ["instances[0]", "video"], kh(i)), n } function $w(t) { const e = {}, n = l(t, ["_self"]); n != null && a(e, ["image"], Xw(n)); const o = l(t, ["raiFilteredReason"]); o != null && a(e, ["raiFilteredReason"], o); const r = l(t, ["_self"]); return r != null && a(e, ["safetyAttributes"], Ch(r)), e } function es(t) { const e = {}, n = l(t, ["_self"]); n != null && a(e, ["image"], wh(n)); const o = l(t, ["raiFilteredReason"]); o != null && a(e, ["raiFilteredReason"], o); const r = l(t, ["_self"]); r != null && a(e, ["safetyAttributes"], Sh(r)); const i = l(t, ["prompt"]); return i != null && a(e, ["enhancedPrompt"], i), e } function qw(t) { const e = {}, n = l(t, ["_self"]); n != null && a(e, ["mask"], wh(n)); const o = l(t, ["labels"]); if (o != null) { let r = o; Array.isArray(r) && (r = r.map(i => i)), a(e, ["labels"], r) } return e } function Hw(t) { const e = {}, n = l(t, ["video"]); return n != null && a(e, ["video"], AC(n)), e } function zw(t) { const e = {}, n = l(t, ["_self"]); return n != null && a(e, ["video"], RC(n)), e } function Bw(t) { const e = {}, n = l(t, ["modelSelectionConfig"]); n != null && a(e, ["modelConfig"], n); const o = l(t, ["responseJsonSchema"]); o != null && a(e, ["responseJsonSchema"], o); const r = l(t, ["audioTimestamp"]); r != null && a(e, ["audioTimestamp"], r); const i = l(t, ["candidateCount"]); i != null && a(e, ["candidateCount"], i); const s = l(t, ["enableAffectiveDialog"]); s != null && a(e, ["enableAffectiveDialog"], s); const u = l(t, ["frequencyPenalty"]); u != null && a(e, ["frequencyPenalty"], u); const c = l(t, ["logprobs"]); c != null && a(e, ["logprobs"], c); const d = l(t, ["maxOutputTokens"]); d != null && a(e, ["maxOutputTokens"], d); const f = l(t, ["mediaResolution"]); f != null && a(e, ["mediaResolution"], f); const p = l(t, ["presencePenalty"]); p != null && a(e, ["presencePenalty"], p); const h = l(t, ["responseLogprobs"]); h != null && a(e, ["responseLogprobs"], h); const g = l(t, ["responseMimeType"]); g != null && a(e, ["responseMimeType"], g); const S = l(t, ["responseModalities"]); S != null && a(e, ["responseModalities"], S); const w = l(t, ["responseSchema"]); w != null && a(e, ["responseSchema"], w); const I = l(t, ["routingConfig"]); I != null && a(e, ["routingConfig"], I); const x = l(t, ["seed"]); x != null && a(e, ["seed"], x); const y = l(t, ["speechConfig"]); y != null && a(e, ["speechConfig"], Th(y)); const v = l(t, ["stopSequences"]); v != null && a(e, ["stopSequences"], v); const T = l(t, ["temperature"]); T != null && a(e, ["temperature"], T); const E = l(t, ["thinkingConfig"]); E != null && a(e, ["thinkingConfig"], E); const C = l(t, ["topK"]); C != null && a(e, ["topK"], C); const k = l(t, ["topP"]); if (k != null && a(e, ["topP"], k), l(t, ["enableEnhancedCivicAnswers"]) !== void 0) throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI."); return e } function Jw(t, e) { const n = {}, o = l(e, ["model"]); return o != null && a(n, ["_url", "name"], W(t, o)), n } function Ww(t, e) { const n = {}, o = l(e, ["model"]); return o != null && a(n, ["_url", "name"], W(t, o)), n } function Yw(t) { const e = {}; if (l(t, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API."); const n = l(t, ["enableWidget"]); return n != null && a(e, ["enableWidget"], n), e } function Kw(t) { const e = {}; if (l(t, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API."); if (l(t, ["blockingConfidence"]) !== void 0) throw new Error("blockingConfidence parameter is not supported in Gemini API."); const n = l(t, ["timeRangeFilter"]); return n != null && a(e, ["timeRangeFilter"], n), e } function Ow(t) { const e = {}, n = l(t, ["aspectRatio"]); n != null && a(e, ["aspectRatio"], n); const o = l(t, ["imageSize"]); if (o != null && a(e, ["imageSize"], o), l(t, ["outputMimeType"]) !== void 0) throw new Error("outputMimeType parameter is not supported in Gemini API."); if (l(t, ["outputCompressionQuality"]) !== void 0) throw new Error("outputCompressionQuality parameter is not supported in Gemini API."); return e } function Qw(t) { const e = {}, n = l(t, ["aspectRatio"]); n != null && a(e, ["aspectRatio"], n); const o = l(t, ["imageSize"]); o != null && a(e, ["imageSize"], o); const r = l(t, ["outputMimeType"]); r != null && a(e, ["imageOutputOptions", "mimeType"], r); const i = l(t, ["outputCompressionQuality"]); return i != null && a(e, ["imageOutputOptions", "compressionQuality"], i), e } function Xw(t) { const e = {}, n = l(t, ["bytesBase64Encoded"]); n != null && a(e, ["imageBytes"], dn(n)); const o = l(t, ["mimeType"]); return o != null && a(e, ["mimeType"], o), e } function wh(t) { const e = {}, n = l(t, ["gcsUri"]); n != null && a(e, ["gcsUri"], n); const o = l(t, ["bytesBase64Encoded"]); o != null && a(e, ["imageBytes"], dn(o)); const r = l(t, ["mimeType"]); return r != null && a(e, ["mimeType"], r), e } function ts(t) { const e = {}; if (l(t, ["gcsUri"]) !== void 0) throw new Error("gcsUri parameter is not supported in Gemini API."); const n = l(t, ["imageBytes"]); n != null && a(e, ["bytesBase64Encoded"], dn(n)); const o = l(t, ["mimeType"]); return o != null && a(e, ["mimeType"], o), e } function pt(t) { const e = {}, n = l(t, ["gcsUri"]); n != null && a(e, ["gcsUri"], n); const o = l(t, ["imageBytes"]); o != null && a(e, ["bytesBase64Encoded"], dn(o)); const r = l(t, ["mimeType"]); return r != null && a(e, ["mimeType"], r), e } function Zw(t, e, n) { const o = {}, r = l(e, ["pageSize"]); n !== void 0 && r != null && a(n, ["_query", "pageSize"], r); const i = l(e, ["pageToken"]); n !== void 0 && i != null && a(n, ["_query", "pageToken"], i); const s = l(e, ["filter"]); n !== void 0 && s != null && a(n, ["_query", "filter"], s); const u = l(e, ["queryBase"]); return n !== void 0 && u != null && a(n, ["_url", "models_url"], fh(t, u)), o } function jw(t, e, n) { const o = {}, r = l(e, ["pageSize"]); n !== void 0 && r != null && a(n, ["_query", "pageSize"], r); const i = l(e, ["pageToken"]); n !== void 0 && i != null && a(n, ["_query", "pageToken"], i); const s = l(e, ["filter"]); n !== void 0 && s != null && a(n, ["_query", "filter"], s); const u = l(e, ["queryBase"]); return n !== void 0 && u != null && a(n, ["_url", "models_url"], fh(t, u)), o } function eC(t, e) { const n = {}, o = l(e, ["config"]); return o != null && Zw(t, o, n), n } function tC(t, e) { const n = {}, o = l(e, ["config"]); return o != null && jw(t, o, n), n } function nC(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["nextPageToken"]); o != null && a(e, ["nextPageToken"], o); const r = l(t, ["_self"]); if (r != null) { let i = ph(r); Array.isArray(i) && (i = i.map(s => Ll(s))), a(e, ["models"], i) } return e } function oC(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["nextPageToken"]); o != null && a(e, ["nextPageToken"], o); const r = l(t, ["_self"]); if (r != null) { let i = ph(r); Array.isArray(i) && (i = i.map(s => Ul(s))), a(e, ["models"], i) } return e } function rC(t) { const e = {}, n = l(t, ["maskMode"]); n != null && a(e, ["maskMode"], n); const o = l(t, ["segmentationClasses"]); o != null && a(e, ["maskClasses"], o); const r = l(t, ["maskDilation"]); return r != null && a(e, ["dilation"], r), e } function Ll(t) { const e = {}, n = l(t, ["name"]); n != null && a(e, ["name"], n); const o = l(t, ["displayName"]); o != null && a(e, ["displayName"], o); const r = l(t, ["description"]); r != null && a(e, ["description"], r); const i = l(t, ["version"]); i != null && a(e, ["version"], i); const s = l(t, ["_self"]); s != null && a(e, ["tunedModelInfo"], wC(s)); const u = l(t, ["inputTokenLimit"]); u != null && a(e, ["inputTokenLimit"], u); const c = l(t, ["outputTokenLimit"]); c != null && a(e, ["outputTokenLimit"], c); const d = l(t, ["supportedGenerationMethods"]); d != null && a(e, ["supportedActions"], d); const f = l(t, ["temperature"]); f != null && a(e, ["temperature"], f); const p = l(t, ["maxTemperature"]); p != null && a(e, ["maxTemperature"], p); const h = l(t, ["topP"]); h != null && a(e, ["topP"], h); const g = l(t, ["topK"]); g != null && a(e, ["topK"], g); const S = l(t, ["thinking"]); return S != null && a(e, ["thinking"], S), e } function Ul(t) { const e = {}, n = l(t, ["name"]); n != null && a(e, ["name"], n); const o = l(t, ["displayName"]); o != null && a(e, ["displayName"], o); const r = l(t, ["description"]); r != null && a(e, ["description"], r); const i = l(t, ["versionId"]); i != null && a(e, ["version"], i); const s = l(t, ["deployedModels"]); if (s != null) { let p = s; Array.isArray(p) && (p = p.map(h => yw(h))), a(e, ["endpoints"], p) } const u = l(t, ["labels"]); u != null && a(e, ["labels"], u); const c = l(t, ["_self"]); c != null && a(e, ["tunedModelInfo"], CC(c)); const d = l(t, ["defaultCheckpointId"]); d != null && a(e, ["defaultCheckpointId"], d); const f = l(t, ["checkpoints"]); if (f != null) { let p = f; Array.isArray(p) && (p = p.map(h => h)), a(e, ["checkpoints"], p) } return e } function iC(t) { const e = {}, n = l(t, ["mediaResolution"]); n != null && a(e, ["mediaResolution"], n); const o = l(t, ["codeExecutionResult"]); o != null && a(e, ["codeExecutionResult"], o); const r = l(t, ["executableCode"]); r != null && a(e, ["executableCode"], r); const i = l(t, ["fileData"]); i != null && a(e, ["fileData"], vw(i)); const s = l(t, ["functionCall"]); s != null && a(e, ["functionCall"], xw(s)); const u = l(t, ["functionResponse"]); u != null && a(e, ["functionResponse"], u); const c = l(t, ["inlineData"]); c != null && a(e, ["inlineData"], Bx(c)); const d = l(t, ["text"]); d != null && a(e, ["text"], d); const f = l(t, ["thought"]); f != null && a(e, ["thought"], f); const p = l(t, ["thoughtSignature"]); p != null && a(e, ["thoughtSignature"], p); const h = l(t, ["videoMetadata"]); return h != null && a(e, ["videoMetadata"], h), e } function sC(t) { const e = {}, n = l(t, ["productImage"]); return n != null && a(e, ["image"], pt(n)), e } function lC(t, e) { const n = {}, o = l(t, ["numberOfImages"]); e !== void 0 && o != null && a(e, ["parameters", "sampleCount"], o); const r = l(t, ["baseSteps"]); e !== void 0 && r != null && a(e, ["parameters", "baseSteps"], r); const i = l(t, ["outputGcsUri"]); e !== void 0 && i != null && a(e, ["parameters", "storageUri"], i); const s = l(t, ["seed"]); e !== void 0 && s != null && a(e, ["parameters", "seed"], s); const u = l(t, ["safetyFilterLevel"]); e !== void 0 && u != null && a(e, ["parameters", "safetySetting"], u); const c = l(t, ["personGeneration"]); e !== void 0 && c != null && a(e, ["parameters", "personGeneration"], c); const d = l(t, ["addWatermark"]); e !== void 0 && d != null && a(e, ["parameters", "addWatermark"], d); const f = l(t, ["outputMimeType"]); e !== void 0 && f != null && a(e, ["parameters", "outputOptions", "mimeType"], f); const p = l(t, ["outputCompressionQuality"]); e !== void 0 && p != null && a(e, ["parameters", "outputOptions", "compressionQuality"], p); const h = l(t, ["enhancePrompt"]); e !== void 0 && h != null && a(e, ["parameters", "enhancePrompt"], h); const g = l(t, ["labels"]); return e !== void 0 && g != null && a(e, ["labels"], g), n } function aC(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "model"], W(t, o)); const r = l(e, ["source"]); r != null && cC(r, n); const i = l(e, ["config"]); return i != null && lC(i, n), n } function uC(t) { const e = {}, n = l(t, ["predictions"]); if (n != null) { let o = n; Array.isArray(o) && (o = o.map(r => es(r))), a(e, ["generatedImages"], o) } return e } function cC(t, e) { const n = {}, o = l(t, ["prompt"]); e !== void 0 && o != null && a(e, ["instances[0]", "prompt"], o); const r = l(t, ["personImage"]); e !== void 0 && r != null && a(e, ["instances[0]", "personImage", "image"], pt(r)); const i = l(t, ["productImages"]); if (e !== void 0 && i != null) { let s = i; Array.isArray(s) && (s = s.map(u => sC(u))), a(e, ["instances[0]", "productImages"], s) } return n } function dC(t) { const e = {}, n = l(t, ["referenceImage"]); n != null && a(e, ["referenceImage"], pt(n)); const o = l(t, ["referenceId"]); o != null && a(e, ["referenceId"], o); const r = l(t, ["referenceType"]); r != null && a(e, ["referenceType"], r); const i = l(t, ["maskImageConfig"]); i != null && a(e, ["maskImageConfig"], rC(i)); const s = l(t, ["controlImageConfig"]); s != null && a(e, ["controlImageConfig"], Xx(s)); const u = l(t, ["styleImageConfig"]); u != null && a(e, ["styleImageConfig"], u); const c = l(t, ["subjectImageConfig"]); return c != null && a(e, ["subjectImageConfig"], c), e } function Ch(t) { const e = {}, n = l(t, ["safetyAttributes", "categories"]); n != null && a(e, ["categories"], n); const o = l(t, ["safetyAttributes", "scores"]); o != null && a(e, ["scores"], o); const r = l(t, ["contentType"]); return r != null && a(e, ["contentType"], r), e } function Sh(t) { const e = {}, n = l(t, ["safetyAttributes", "categories"]); n != null && a(e, ["categories"], n); const o = l(t, ["safetyAttributes", "scores"]); o != null && a(e, ["scores"], o); const r = l(t, ["contentType"]); return r != null && a(e, ["contentType"], r), e } function fC(t) { const e = {}, n = l(t, ["category"]); if (n != null && a(e, ["category"], n), l(t, ["method"]) !== void 0) throw new Error("method parameter is not supported in Gemini API."); const o = l(t, ["threshold"]); return o != null && a(e, ["threshold"], o), e } function pC(t) { const e = {}, n = l(t, ["image"]); return n != null && a(e, ["image"], pt(n)), e } function hC(t, e) { const n = {}, o = l(t, ["mode"]); e !== void 0 && o != null && a(e, ["parameters", "mode"], o); const r = l(t, ["maxPredictions"]); e !== void 0 && r != null && a(e, ["parameters", "maxPredictions"], r); const i = l(t, ["confidenceThreshold"]); e !== void 0 && i != null && a(e, ["parameters", "confidenceThreshold"], i); const s = l(t, ["maskDilation"]); e !== void 0 && s != null && a(e, ["parameters", "maskDilation"], s); const u = l(t, ["binaryColorThreshold"]); e !== void 0 && u != null && a(e, ["parameters", "binaryColorThreshold"], u); const c = l(t, ["labels"]); return e !== void 0 && c != null && a(e, ["labels"], c), n } function mC(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "model"], W(t, o)); const r = l(e, ["source"]); r != null && yC(r, n); const i = l(e, ["config"]); return i != null && hC(i, n), n } function gC(t) { const e = {}, n = l(t, ["predictions"]); if (n != null) { let o = n; Array.isArray(o) && (o = o.map(r => qw(r))), a(e, ["generatedMasks"], o) } return e } function yC(t, e) { const n = {}, o = l(t, ["prompt"]); e !== void 0 && o != null && a(e, ["instances[0]", "prompt"], o); const r = l(t, ["image"]); e !== void 0 && r != null && a(e, ["instances[0]", "image"], pt(r)); const i = l(t, ["scribbleImage"]); return e !== void 0 && i != null && a(e, ["instances[0]", "scribble"], pC(i)), n } function Th(t) { const e = {}, n = l(t, ["languageCode"]); n != null && a(e, ["languageCode"], n); const o = l(t, ["voiceConfig"]); if (o != null && a(e, ["voiceConfig"], o), l(t, ["multiSpeakerVoiceConfig"]) !== void 0) throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI."); return e } function vC(t) { const e = {}, n = l(t, ["functionCallingConfig"]); n != null && a(e, ["functionCallingConfig"], ww(n)); const o = l(t, ["retrievalConfig"]); return o != null && a(e, ["retrievalConfig"], o), e } function xC(t) { const e = {}, n = l(t, ["functionDeclarations"]); if (n != null) { let f = n; Array.isArray(f) && (f = f.map(p => p)), a(e, ["functionDeclarations"], f) } if (l(t, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API."); const o = l(t, ["googleSearchRetrieval"]); o != null && a(e, ["googleSearchRetrieval"], o); const r = l(t, ["computerUse"]); r != null && a(e, ["computerUse"], r); const i = l(t, ["fileSearch"]); i != null && a(e, ["fileSearch"], i); const s = l(t, ["codeExecution"]); if (s != null && a(e, ["codeExecution"], s), l(t, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API."); const u = l(t, ["googleMaps"]); u != null && a(e, ["googleMaps"], Yw(u)); const c = l(t, ["googleSearch"]); c != null && a(e, ["googleSearch"], Kw(c)); const d = l(t, ["urlContext"]); return d != null && a(e, ["urlContext"], d), e } function _h(t) { const e = {}, n = l(t, ["functionDeclarations"]); if (n != null) { let p = n; Array.isArray(p) && (p = p.map(h => Cw(h))), a(e, ["functionDeclarations"], p) } const o = l(t, ["retrieval"]); o != null && a(e, ["retrieval"], o); const r = l(t, ["googleSearchRetrieval"]); r != null && a(e, ["googleSearchRetrieval"], r); const i = l(t, ["computerUse"]); if (i != null && a(e, ["computerUse"], i), l(t, ["fileSearch"]) !== void 0) throw new Error("fileSearch parameter is not supported in Vertex AI."); const s = l(t, ["codeExecution"]); s != null && a(e, ["codeExecution"], s); const u = l(t, ["enterpriseWebSearch"]); u != null && a(e, ["enterpriseWebSearch"], u); const c = l(t, ["googleMaps"]); c != null && a(e, ["googleMaps"], c); const d = l(t, ["googleSearch"]); d != null && a(e, ["googleSearch"], d); const f = l(t, ["urlContext"]); return f != null && a(e, ["urlContext"], f), e } function wC(t) { const e = {}, n = l(t, ["baseModel"]); n != null && a(e, ["baseModel"], n); const o = l(t, ["createTime"]); o != null && a(e, ["createTime"], o); const r = l(t, ["updateTime"]); return r != null && a(e, ["updateTime"], r), e } function CC(t) { const e = {}, n = l(t, ["labels", "google-vertex-llm-tuning-base-model-id"]); n != null && a(e, ["baseModel"], n); const o = l(t, ["createTime"]); o != null && a(e, ["createTime"], o); const r = l(t, ["updateTime"]); return r != null && a(e, ["updateTime"], r), e } function SC(t, e) { const n = {}, o = l(t, ["displayName"]); e !== void 0 && o != null && a(e, ["displayName"], o); const r = l(t, ["description"]); e !== void 0 && r != null && a(e, ["description"], r); const i = l(t, ["defaultCheckpointId"]); return e !== void 0 && i != null && a(e, ["defaultCheckpointId"], i), n } function TC(t, e) { const n = {}, o = l(t, ["displayName"]); e !== void 0 && o != null && a(e, ["displayName"], o); const r = l(t, ["description"]); e !== void 0 && r != null && a(e, ["description"], r); const i = l(t, ["defaultCheckpointId"]); return e !== void 0 && i != null && a(e, ["defaultCheckpointId"], i), n } function _C(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "name"], W(t, o)); const r = l(e, ["config"]); return r != null && SC(r, n), n } function EC(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "model"], W(t, o)); const r = l(e, ["config"]); return r != null && TC(r, n), n } function kC(t, e) { const n = {}, o = l(t, ["outputGcsUri"]); e !== void 0 && o != null && a(e, ["parameters", "storageUri"], o); const r = l(t, ["safetyFilterLevel"]); e !== void 0 && r != null && a(e, ["parameters", "safetySetting"], r); const i = l(t, ["personGeneration"]); e !== void 0 && i != null && a(e, ["parameters", "personGeneration"], i); const s = l(t, ["includeRaiReason"]); e !== void 0 && s != null && a(e, ["parameters", "includeRaiReason"], s); const u = l(t, ["outputMimeType"]); e !== void 0 && u != null && a(e, ["parameters", "outputOptions", "mimeType"], u); const c = l(t, ["outputCompressionQuality"]); e !== void 0 && c != null && a(e, ["parameters", "outputOptions", "compressionQuality"], c); const d = l(t, ["enhanceInputImage"]); e !== void 0 && d != null && a(e, ["parameters", "upscaleConfig", "enhanceInputImage"], d); const f = l(t, ["imagePreservationFactor"]); e !== void 0 && f != null && a(e, ["parameters", "upscaleConfig", "imagePreservationFactor"], f); const p = l(t, ["labels"]); e !== void 0 && p != null && a(e, ["labels"], p); const h = l(t, ["numberOfImages"]); e !== void 0 && h != null && a(e, ["parameters", "sampleCount"], h); const g = l(t, ["mode"]); return e !== void 0 && g != null && a(e, ["parameters", "mode"], g), n } function IC(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["_url", "model"], W(t, o)); const r = l(e, ["image"]); r != null && a(n, ["instances[0]", "image"], pt(r)); const i = l(e, ["upscaleFactor"]); i != null && a(n, ["parameters", "upscaleConfig", "upscaleFactor"], i); const s = l(e, ["config"]); return s != null && kC(s, n), n } function NC(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["predictions"]); if (o != null) { let r = o; Array.isArray(r) && (r = r.map(i => es(i))), a(e, ["generatedImages"], r) } return e } function AC(t) { const e = {}, n = l(t, ["uri"]); n != null && a(e, ["uri"], n); const o = l(t, ["encodedVideo"]); o != null && a(e, ["videoBytes"], dn(o)); const r = l(t, ["encoding"]); return r != null && a(e, ["mimeType"], r), e } function RC(t) { const e = {}, n = l(t, ["gcsUri"]); n != null && a(e, ["uri"], n); const o = l(t, ["bytesBase64Encoded"]); o != null && a(e, ["videoBytes"], dn(o)); const r = l(t, ["mimeType"]); return r != null && a(e, ["mimeType"], r), e } function PC(t) { const e = {}, n = l(t, ["image"]); n != null && a(e, ["_self"], pt(n)); const o = l(t, ["maskMode"]); return o != null && a(e, ["maskMode"], o), e } function MC(t) { const e = {}, n = l(t, ["image"]); n != null && a(e, ["image"], ts(n)); const o = l(t, ["referenceType"]); return o != null && a(e, ["referenceType"], o), e } function DC(t) { const e = {}, n = l(t, ["image"]); n != null && a(e, ["image"], pt(n)); const o = l(t, ["referenceType"]); return o != null && a(e, ["referenceType"], o), e } function Eh(t) { const e = {}, n = l(t, ["uri"]); n != null && a(e, ["uri"], n); const o = l(t, ["videoBytes"]); o != null && a(e, ["encodedVideo"], dn(o)); const r = l(t, ["mimeType"]); return r != null && a(e, ["encoding"], r), e } function kh(t) { const e = {}, n = l(t, ["uri"]); n != null && a(e, ["gcsUri"], n); const o = l(t, ["videoBytes"]); o != null && a(e, ["bytesBase64Encoded"], dn(o)); const r = l(t, ["mimeType"]); return r != null && a(e, ["mimeType"], r), e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const LC = "Content-Type", UC = "X-Server-Timeout", FC = "User-Agent", Fl = "x-goog-api-client", bC = "1.30.0", VC = `google-genai-sdk/${bC}`, GC = "v1beta1", $C = "v1beta", kd = /^\s*data: (.*)(?:\n\n|\r\r|\r\n\r\n)/; class qC { constructor(e) { var n, o; this.clientOptions = Object.assign(Object.assign({}, e), { project: e.project, location: e.location, apiKey: e.apiKey, vertexai: e.vertexai }); const r = {}; this.clientOptions.vertexai ? (r.apiVersion = (n = this.clientOptions.apiVersion) !== null && n !== void 0 ? n : GC, r.baseUrl = this.baseUrlFromProjectLocation(), this.normalizeAuthParameters()) : (r.apiVersion = (o = this.clientOptions.apiVersion) !== null && o !== void 0 ? o : $C, r.baseUrl = "https://generativelanguage.googleapis.com/"), r.headers = this.getDefaultHeaders(), this.clientOptions.httpOptions = r, e.httpOptions && (this.clientOptions.httpOptions = this.patchHttpOptions(r, e.httpOptions)) } baseUrlFromProjectLocation() { return this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== "global" ? `https://${this.clientOptions.location}-aiplatform.googleapis.com/` : "https://aiplatform.googleapis.com/" } normalizeAuthParameters() { if (this.clientOptions.project && this.clientOptions.location) { this.clientOptions.apiKey = void 0; return } this.clientOptions.project = void 0, this.clientOptions.location = void 0 } isVertexAI() { var e; return (e = this.clientOptions.vertexai) !== null && e !== void 0 ? e : !1 } getProject() { return this.clientOptions.project } getLocation() { return this.clientOptions.location } getApiVersion() { if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== void 0) return this.clientOptions.httpOptions.apiVersion; throw new Error("API version is not set.") } getBaseUrl() { if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== void 0) return this.clientOptions.httpOptions.baseUrl; throw new Error("Base URL is not set.") } getRequestUrl() { return this.getRequestUrlInternal(this.clientOptions.httpOptions) } getHeaders() { if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== void 0) return this.clientOptions.httpOptions.headers; throw new Error("Headers are not set.") } getRequestUrlInternal(e) { if (!e || e.baseUrl === void 0 || e.apiVersion === void 0) throw new Error("HTTP options are not correctly set."); const o = [e.baseUrl.endsWith("/") ? e.baseUrl.slice(0, -1) : e.baseUrl]; return e.apiVersion && e.apiVersion !== "" && o.push(e.apiVersion), o.join("/") } getBaseResourcePath() { return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}` } getApiKey() { return this.clientOptions.apiKey } getWebsocketBaseUrl() { const e = this.getBaseUrl(), n = new URL(e); return n.protocol = n.protocol == "http:" ? "ws" : "wss", n.toString() } setBaseUrl(e) { if (this.clientOptions.httpOptions) this.clientOptions.httpOptions.baseUrl = e; else throw new Error("HTTP options are not correctly set.") } constructUrl(e, n, o) { const r = [this.getRequestUrlInternal(n)]; return o && r.push(this.getBaseResourcePath()), e !== "" && r.push(e), new URL(`${r.join("/")}`) } shouldPrependVertexProjectPath(e) { return !(this.clientOptions.apiKey || !this.clientOptions.vertexai || e.path.startsWith("projects/") || e.httpMethod === "GET" && e.path.startsWith("publishers/google/models")) } async request(e) { let n = this.clientOptions.httpOptions; e.httpOptions && (n = this.patchHttpOptions(this.clientOptions.httpOptions, e.httpOptions)); const o = this.shouldPrependVertexProjectPath(e), r = this.constructUrl(e.path, n, o); if (e.queryParams) for (const [s, u] of Object.entries(e.queryParams)) r.searchParams.append(s, String(u)); let i = {}; if (e.httpMethod === "GET") { if (e.body && e.body !== "{}") throw new Error("Request body should be empty for GET request, but got non empty request body") } else i.body = e.body; return i = await this.includeExtraHttpOptionsToRequestInit(i, n, r.toString(), e.abortSignal), this.unaryApiCall(r, i, e.httpMethod) } patchHttpOptions(e, n) { const o = JSON.parse(JSON.stringify(e)); for (const [r, i] of Object.entries(n)) typeof i == "object" ? o[r] = Object.assign(Object.assign({}, o[r]), i) : i !== void 0 && (o[r] = i); return o } async requestStream(e) { let n = this.clientOptions.httpOptions; e.httpOptions && (n = this.patchHttpOptions(this.clientOptions.httpOptions, e.httpOptions)); const o = this.shouldPrependVertexProjectPath(e), r = this.constructUrl(e.path, n, o); (!r.searchParams.has("alt") || r.searchParams.get("alt") !== "sse") && r.searchParams.set("alt", "sse"); let i = {}; return i.body = e.body, i = await this.includeExtraHttpOptionsToRequestInit(i, n, r.toString(), e.abortSignal), this.streamApiCall(r, i, e.httpMethod) } async includeExtraHttpOptionsToRequestInit(e, n, o, r) { if (n && n.timeout || r) { const i = new AbortController, s = i.signal; if (n.timeout && (n == null ? void 0 : n.timeout) > 0) { const u = setTimeout(() => i.abort(), n.timeout); u && typeof u.unref == "function" && u.unref() } r && r.addEventListener("abort", () => { i.abort() }), e.signal = s } return n && n.extraBody !== null && HC(e, n.extraBody), e.headers = await this.getHeadersInternal(n, o), e } async unaryApiCall(e, n, o) { return this.apiCall(e.toString(), Object.assign(Object.assign({}, n), { method: o })).then(async r => (await Id(r), new Pl(r))).catch(r => { throw r instanceof Error ? r : new Error(JSON.stringify(r)) }) } async streamApiCall(e, n, o) { return this.apiCall(e.toString(), Object.assign(Object.assign({}, n), { method: o })).then(async r => (await Id(r), this.processStreamResponse(r))).catch(r => { throw r instanceof Error ? r : new Error(JSON.stringify(r)) }) } processStreamResponse(e) { var n; return to(this, arguments, function* () { const r = (n = e == null ? void 0 : e.body) === null || n === void 0 ? void 0 : n.getReader(), i = new TextDecoder("utf-8"); if (!r) throw new Error("Response body is empty"); try { let s = ""; for (; ;) { const { done: u, value: c } = yield oe(r.read()); if (u) { if (s.trim().length > 0) throw new Error("Incomplete JSON segment at the end"); break } const d = i.decode(c, { stream: !0 }); try { const p = JSON.parse(d); if ("error" in p) { const h = JSON.parse(JSON.stringify(p.error)), g = h.status, S = h.code, w = `got status: ${g}. ${JSON.stringify(p)}`; if (S >= 400 && S < 600) throw new Zi({ message: w, status: S }) } } catch (p) { if (p.name === "ApiError") throw p } s += d; let f = s.match(kd); for (; f;) { const p = f[1]; try { const h = new Response(p, { headers: e == null ? void 0 : e.headers, status: e == null ? void 0 : e.status, statusText: e == null ? void 0 : e.statusText }); yield yield oe(new Pl(h)), s = s.slice(f[0].length), f = s.match(kd) } catch (h) { throw new Error(`exception parsing stream chunk ${p}. ${h}`) } } } } finally { r.releaseLock() } }) } async apiCall(e, n) { return fetch(e, n).catch(o => { throw new Error(`exception ${o} sending request`) }) } getDefaultHeaders() { const e = {}, n = VC + " " + this.clientOptions.userAgentExtra; return e[FC] = n, e[Fl] = n, e[LC] = "application/json", e } async getHeadersInternal(e, n) { const o = new Headers; if (e && e.headers) { for (const [r, i] of Object.entries(e.headers)) o.append(r, i); e.timeout && e.timeout > 0 && o.append(UC, String(Math.ceil(e.timeout / 1e3))) } return await this.clientOptions.auth.addAuthHeaders(o, n), o } getFileName(e) { var n; let o = ""; return typeof e == "string" && (o = e.replace(/[/\\]+$/, ""), o = (n = o.split(/[/\\]/).pop()) !== null && n !== void 0 ? n : ""), o } async uploadFile(e, n) { var o; const r = {}; n != null && (r.mimeType = n.mimeType, r.name = n.name, r.displayName = n.displayName), r.name && !r.name.startsWith("files/") && (r.name = `files/${r.name}`); const i = this.clientOptions.uploader, s = await i.stat(e); r.sizeBytes = String(s.size); const u = (o = n == null ? void 0 : n.mimeType) !== null && o !== void 0 ? o : s.type; if (u === void 0 || u === "") throw new Error("Can not determine mimeType. Please provide mimeType in the config."); r.mimeType = u; const c = { file: r }, d = this.getFileName(e), f = D("upload/v1beta/files", c._url), p = await this.fetchUploadUrl(f, r.sizeBytes, r.mimeType, d, c, n == null ? void 0 : n.httpOptions); return i.upload(e, p, this) } async uploadFileToFileSearchStore(e, n, o) { var r; const i = this.clientOptions.uploader, s = await i.stat(n), u = String(s.size), c = (r = o == null ? void 0 : o.mimeType) !== null && r !== void 0 ? r : s.type; if (c === void 0 || c === "") throw new Error("Can not determine mimeType. Please provide mimeType in the config."); const d = `upload/v1beta/${e}:uploadToFileSearchStore`, f = this.getFileName(n), p = {}; o != null && o.customMetadata && (p.customMetadata = o.customMetadata), o != null && o.chunkingConfig && (p.chunkingConfig = o.chunkingConfig); const h = await this.fetchUploadUrl(d, u, c, f, p, o == null ? void 0 : o.httpOptions); return i.uploadToFileSearchStore(n, h, this) } async downloadFile(e) { await this.clientOptions.downloader.download(e, this) } async fetchUploadUrl(e, n, o, r, i, s) { var u; let c = {}; s ? c = s : c = { apiVersion: "", headers: Object.assign({ "Content-Type": "application/json", "X-Goog-Upload-Protocol": "resumable", "X-Goog-Upload-Command": "start", "X-Goog-Upload-Header-Content-Length": `${n}`, "X-Goog-Upload-Header-Content-Type": `${o}` }, r ? { "X-Goog-Upload-File-Name": r } : {}) }; const d = await this.request({ path: e, body: JSON.stringify(i), httpMethod: "POST", httpOptions: c }); if (!d || !(d != null && d.headers)) throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers."); const f = (u = d == null ? void 0 : d.headers) === null || u === void 0 ? void 0 : u["x-goog-upload-url"]; if (f === void 0) throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers"); return f } } async function Id(t) { var e; if (t === void 0) throw new Error("response is undefined"); if (!t.ok) { const n = t.status; let o; !((e = t.headers.get("content-type")) === null || e === void 0) && e.includes("application/json") ? o = await t.json() : o = { error: { message: await t.text(), code: t.status, status: t.statusText } }; const r = JSON.stringify(o); throw n >= 400 && n < 600 ? new Zi({ message: r, status: n }) : new Error(r) } } function HC(t, e) { if (!e || Object.keys(e).length === 0) return; if (t.body instanceof Blob) { console.warn("includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies."); return } let n = {}; if (typeof t.body == "string" && t.body.length > 0) try { const i = JSON.parse(t.body); if (typeof i == "object" && i !== null && !Array.isArray(i)) n = i; else { console.warn("includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body."); return } } catch { console.warn("includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body."); return } function o(i, s) { const u = Object.assign({}, i); for (const c in s) if (Object.prototype.hasOwnProperty.call(s, c)) { const d = s[c], f = u[c]; d && typeof d == "object" && !Array.isArray(d) && f && typeof f == "object" && !Array.isArray(f) ? u[c] = o(f, d) : (f && d && typeof f != typeof d && console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key "${c}". Original type: ${typeof f}, New type: ${typeof d}. Overwriting.`), u[c] = d) } return u } const r = o(n, e); t.body = JSON.stringify(r) }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const zC = "mcp_used/unknown"; let BC = !1; function Ih(t) { for (const e of t) if (JC(e) || typeof e == "object" && "inputSchema" in e) return !0; return BC } function Nh(t) { var e; const n = (e = t[Fl]) !== null && e !== void 0 ? e : ""; t[Fl] = (n + ` ${zC}`).trimStart() } function JC(t) { return t !== null && typeof t == "object" && t instanceof Wa } function WC(t, e = 100) { return to(this, arguments, function* () { let o, r = 0; for (; r < e;) { const i = yield oe(t.listTools({ cursor: o })); for (const s of i.tools) yield yield oe(s), r++; if (!i.nextCursor) break; o = i.nextCursor } }) } class Wa { constructor(e = [], n) { this.mcpTools = [], this.functionNameToMcpClient = {}, this.mcpClients = e, this.config = n } static create(e, n) { return new Wa(e, n) } async initialize() { var e, n, o, r; if (this.mcpTools.length > 0) return; const i = {}, s = []; for (const f of this.mcpClients) try { for (var u = !0, c = (n = void 0, Jo(WC(f))), d; d = await c.next(), e = d.done, !e; u = !0) { r = d.value, u = !1; const p = r; s.push(p); const h = p.name; if (i[h]) throw new Error(`Duplicate function name ${h} found in MCP tools. Please ensure function names are unique.`); i[h] = f } } catch (p) { n = { error: p } } finally { try { !u && !e && (o = c.return) && await o.call(c) } finally { if (n) throw n.error } } this.mcpTools = s, this.functionNameToMcpClient = i } async tool() { return await this.initialize(), V0(this.mcpTools, this.config) } async callTool(e) { await this.initialize(); const n = []; for (const o of e) if (o.name in this.functionNameToMcpClient) { const r = this.functionNameToMcpClient[o.name]; let i; this.config.timeout && (i = { timeout: this.config.timeout }); const s = await r.callTool({ name: o.name, arguments: o.args }, void 0, i); n.push({ functionResponse: { name: o.name, response: s.isError ? { error: s } : s } }) } return n } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */async function YC(t, e, n) { const o = new R0; let r; n.data instanceof Blob ? r = JSON.parse(await n.data.text()) : r = JSON.parse(n.data), Object.assign(o, r), e(o) } class KC { constructor(e, n, o) { this.apiClient = e, this.auth = n, this.webSocketFactory = o } async connect(e) { var n, o; if (this.apiClient.isVertexAI()) throw new Error("Live music is not supported for Vertex AI."); console.warn("Live music generation is experimental and may change in future versions."); const r = this.apiClient.getWebsocketBaseUrl(), i = this.apiClient.getApiVersion(), s = XC(this.apiClient.getDefaultHeaders()), u = this.apiClient.getApiKey(), c = `${r}/ws/google.ai.generativelanguage.${i}.GenerativeService.BidiGenerateMusic?key=${u}`; let d = () => { }; const f = new Promise(v => { d = v }), p = e.callbacks, h = function () { d({}) }, g = this.apiClient, S = { onopen: h, onmessage: v => { YC(g, p.onmessage, v) }, onerror: (n = p == null ? void 0 : p.onerror) !== null && n !== void 0 ? n : function (v) { }, onclose: (o = p == null ? void 0 : p.onclose) !== null && o !== void 0 ? o : function (v) { } }, w = this.webSocketFactory.create(c, QC(s), S); w.connect(), await f; const y = { setup: { model: W(this.apiClient, e.model) } }; return w.send(JSON.stringify(y)), new OC(w, this.apiClient) } } class OC { constructor(e, n) { this.conn = e, this.apiClient = n } async setWeightedPrompts(e) { if (!e.weightedPrompts || Object.keys(e.weightedPrompts).length === 0) throw new Error("Weighted prompts must be set and contain at least one entry."); const n = Ux(e); this.conn.send(JSON.stringify({ clientContent: n })) } async setMusicGenerationConfig(e) { e.musicGenerationConfig || (e.musicGenerationConfig = {}); const n = Lx(e); this.conn.send(JSON.stringify(n)) } sendPlaybackControl(e) { const n = { playbackControl: e }; this.conn.send(JSON.stringify(n)) } play() { this.sendPlaybackControl(Wn.PLAY) } pause() { this.sendPlaybackControl(Wn.PAUSE) } stop() { this.sendPlaybackControl(Wn.STOP) } resetContext() { this.sendPlaybackControl(Wn.RESET_CONTEXT) } close() { this.conn.close() } } function QC(t) { const e = {}; return t.forEach((n, o) => { e[o] = n }), e } function XC(t) { const e = new Headers; for (const [n, o] of Object.entries(t)) e.append(n, o); return e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const ZC = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI."; async function jC(t, e, n) { const o = new A0; let r; n.data instanceof Blob ? r = await n.data.text() : n.data instanceof ArrayBuffer ? r = new TextDecoder().decode(n.data) : r = n.data; const i = JSON.parse(r); if (t.isVertexAI()) { const s = Vx(i); Object.assign(o, s) } else Object.assign(o, i); e(o) } class eS { constructor(e, n, o) { this.apiClient = e, this.auth = n, this.webSocketFactory = o, this.music = new KC(this.apiClient, this.auth, this.webSocketFactory) } async connect(e) { var n, o, r, i, s, u; if (e.config && e.config.httpOptions) throw new Error("The Live module does not support httpOptions at request-level in LiveConnectConfig yet. Please use the client-level httpOptions configuration instead."); const c = this.apiClient.getWebsocketBaseUrl(), d = this.apiClient.getApiVersion(); let f; const p = this.apiClient.getHeaders(); e.config && e.config.tools && Ih(e.config.tools) && Nh(p); const h = rS(p); if (this.apiClient.isVertexAI()) f = `${c}/ws/google.cloud.aiplatform.${d}.LlmBidiService/BidiGenerateContent`, await this.auth.addAuthHeaders(h, f); else { const N = this.apiClient.getApiKey(); let M = "BidiGenerateContent", b = "key"; N != null && N.startsWith("auth_tokens/") && (console.warn("Warning: Ephemeral token support is experimental and may change in future versions."), d !== "v1alpha" && console.warn("Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection."), M = "BidiGenerateContentConstrained", b = "access_token"), f = `${c}/ws/google.ai.generativelanguage.${d}.GenerativeService.${M}?${b}=${N}` } let g = () => { }; const S = new Promise(N => { g = N }), w = e.callbacks, I = function () { var N; (N = w == null ? void 0 : w.onopen) === null || N === void 0 || N.call(w), g({}) }, x = this.apiClient, y = { onopen: I, onmessage: N => { jC(x, w.onmessage, N) }, onerror: (n = w == null ? void 0 : w.onerror) !== null && n !== void 0 ? n : function (N) { }, onclose: (o = w == null ? void 0 : w.onclose) !== null && o !== void 0 ? o : function (N) { } }, v = this.webSocketFactory.create(f, oS(h), y); v.connect(), await S; let T = W(this.apiClient, e.model); if (this.apiClient.isVertexAI() && T.startsWith("publishers/")) { const N = this.apiClient.getProject(), M = this.apiClient.getLocation(); T = `projects/${N}/locations/${M}/` + T } let E = {}; this.apiClient.isVertexAI() && ((r = e.config) === null || r === void 0 ? void 0 : r.responseModalities) === void 0 && (e.config === void 0 ? e.config = { responseModalities: [Ri.AUDIO] } : e.config.responseModalities = [Ri.AUDIO]), !((i = e.config) === null || i === void 0) && i.generationConfig && console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025)."); const C = (u = (s = e.config) === null || s === void 0 ? void 0 : s.tools) !== null && u !== void 0 ? u : [], k = []; for (const N of C) if (this.isCallableTool(N)) { const M = N; k.push(await M.tool()) } else k.push(N); k.length > 0 && (e.config.tools = k); const A = { model: T, config: e.config, callbacks: e.callbacks }; return this.apiClient.isVertexAI() ? E = Dx(this.apiClient, A) : E = Mx(this.apiClient, A), delete E.config, v.send(JSON.stringify(E)), new nS(v, this.apiClient) } isCallableTool(e) { return "callTool" in e && typeof e.callTool == "function" } } const tS = { turnComplete: !0 }; class nS { constructor(e, n) { this.conn = e, this.apiClient = n } tLiveClientContent(e, n) { if (n.turns !== null && n.turns !== void 0) { let o = []; try { o = ot(n.turns), e.isVertexAI() || (o = o.map(r => ji(r))) } catch { throw new Error(`Failed to parse client content "turns", type: '${typeof n.turns}'`) } return { clientContent: { turns: o, turnComplete: n.turnComplete } } } return { clientContent: { turnComplete: n.turnComplete } } } tLiveClienttToolResponse(e, n) { let o = []; if (n.functionResponses == null) throw new Error("functionResponses is required."); if (Array.isArray(n.functionResponses) ? o = n.functionResponses : o = [n.functionResponses], o.length === 0) throw new Error("functionResponses is required."); for (const i of o) { if (typeof i != "object" || i === null || !("name" in i) || !("response" in i)) throw new Error(`Could not parse function response, type '${typeof i}'.`); if (!e.isVertexAI() && !("id" in i)) throw new Error(ZC) } return { toolResponse: { functionResponses: o } } } sendClientContent(e) { e = Object.assign(Object.assign({}, tS), e); const n = this.tLiveClientContent(this.apiClient, e); this.conn.send(JSON.stringify(n)) } sendRealtimeInput(e) { let n = {}; this.apiClient.isVertexAI() ? n = { realtimeInput: bx(e) } : n = { realtimeInput: Fx(e) }, this.conn.send(JSON.stringify(n)) } sendToolResponse(e) { if (e.functionResponses == null) throw new Error("Tool response parameters are required."); const n = this.tLiveClienttToolResponse(this.apiClient, e); this.conn.send(JSON.stringify(n)) } close() { this.conn.close() } } function oS(t) { const e = {}; return t.forEach((n, o) => { e[o] = n }), e } function rS(t) { const e = new Headers; for (const [n, o] of Object.entries(t)) e.append(n, o); return e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Nd = 10; function Ad(t) { var e, n, o; if (!((e = t == null ? void 0 : t.automaticFunctionCalling) === null || e === void 0) && e.disable) return !0; let r = !1; for (const s of (n = t == null ? void 0 : t.tools) !== null && n !== void 0 ? n : []) if (no(s)) { r = !0; break } if (!r) return !0; const i = (o = t == null ? void 0 : t.automaticFunctionCalling) === null || o === void 0 ? void 0 : o.maximumRemoteCalls; return i && (i < 0 || !Number.isInteger(i)) || i == 0 ? (console.warn("Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:", i), !0) : !1 } function no(t) { return "callTool" in t && typeof t.callTool == "function" } function iS(t) { var e, n, o; return (o = (n = (e = t.config) === null || e === void 0 ? void 0 : e.tools) === null || n === void 0 ? void 0 : n.some(r => no(r))) !== null && o !== void 0 ? o : !1 } function Rd(t) { var e; const n = []; return !((e = t == null ? void 0 : t.config) === null || e === void 0) && e.tools && t.config.tools.forEach((o, r) => { if (no(o)) return; const i = o; i.functionDeclarations && i.functionDeclarations.length > 0 && n.push(r) }), n } function Pd(t) { var e; return !(!((e = t == null ? void 0 : t.automaticFunctionCalling) === null || e === void 0) && e.ignoreCallHistory) }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class sS extends bt { constructor(e) { super(), this.apiClient = e, this.generateContent = async n => { var o, r, i, s, u; const c = await this.processParamsMaybeAddMcpUsage(n); if (this.maybeMoveToResponseJsonSchem(n), !iS(n) || Ad(n.config)) return await this.generateContentInternal(c); const d = Rd(n); if (d.length > 0) { const w = d.map(I => `tools[${I}]`).join(", "); throw new Error(`Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations is not yet supported. Incompatible tools found at ${w}.`) } let f, p; const h = ot(c.contents), g = (i = (r = (o = c.config) === null || o === void 0 ? void 0 : o.automaticFunctionCalling) === null || r === void 0 ? void 0 : r.maximumRemoteCalls) !== null && i !== void 0 ? i : Nd; let S = 0; for (; S < g && (f = await this.generateContentInternal(c), !(!f.functionCalls || f.functionCalls.length === 0));) { const w = f.candidates[0].content, I = []; for (const x of (u = (s = n.config) === null || s === void 0 ? void 0 : s.tools) !== null && u !== void 0 ? u : []) if (no(x)) { const v = await x.callTool(f.functionCalls); I.push(...v) } S++, p = { role: "user", parts: I }, c.contents = ot(c.contents), c.contents.push(w), c.contents.push(p), Pd(c.config) && (h.push(w), h.push(p)) } return Pd(c.config) && (f.automaticFunctionCallingHistory = h), f }, this.generateContentStream = async n => { var o, r, i, s, u; if (this.maybeMoveToResponseJsonSchem(n), Ad(n.config)) { const p = await this.processParamsMaybeAddMcpUsage(n); return await this.generateContentStreamInternal(p) } const c = Rd(n); if (c.length > 0) { const p = c.map(h => `tools[${h}]`).join(", "); throw new Error(`Incompatible tools found at ${p}. Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations" is not yet supported.`) } const d = (i = (r = (o = n == null ? void 0 : n.config) === null || o === void 0 ? void 0 : o.toolConfig) === null || r === void 0 ? void 0 : r.functionCallingConfig) === null || i === void 0 ? void 0 : i.streamFunctionCallArguments, f = (u = (s = n == null ? void 0 : n.config) === null || s === void 0 ? void 0 : s.automaticFunctionCalling) === null || u === void 0 ? void 0 : u.disable; if (d && !f) throw new Error("Running in streaming mode with 'streamFunctionCallArguments' enabled, this feature is not compatible with automatic function calling (AFC). Please set 'config.automaticFunctionCalling.disable' to true to disable AFC or leave 'config.toolConfig.functionCallingConfig.streamFunctionCallArguments' to be undefined or set to false to disable streaming function call arguments feature."); return await this.processAfcStream(n) }, this.generateImages = async n => await this.generateImagesInternal(n).then(o => { var r; let i; const s = []; if (o != null && o.generatedImages) for (const c of o.generatedImages) c && (c != null && c.safetyAttributes) && ((r = c == null ? void 0 : c.safetyAttributes) === null || r === void 0 ? void 0 : r.contentType) === "Positive Prompt" ? i = c == null ? void 0 : c.safetyAttributes : s.push(c); let u; return i ? u = { generatedImages: s, positivePromptSafetyAttributes: i, sdkHttpResponse: o.sdkHttpResponse } : u = { generatedImages: s, sdkHttpResponse: o.sdkHttpResponse }, u }), this.list = async n => { var o; const s = { config: Object.assign(Object.assign({}, { queryBase: !0 }), n == null ? void 0 : n.config) }; if (this.apiClient.isVertexAI() && !s.config.queryBase) { if (!((o = s.config) === null || o === void 0) && o.filter) throw new Error("Filtering tuned models list for Vertex AI is not currently supported"); s.config.filter = "labels.tune-type:*" } return new Nn(Ut.PAGED_ITEM_MODELS, u => this.listInternal(u), await this.listInternal(s), s) }, this.editImage = async n => { const o = { model: n.model, prompt: n.prompt, referenceImages: [], config: n.config }; return n.referenceImages && n.referenceImages && (o.referenceImages = n.referenceImages.map(r => r.toReferenceImageAPI())), await this.editImageInternal(o) }, this.upscaleImage = async n => { let o = { numberOfImages: 1, mode: "upscale" }; n.config && (o = Object.assign(Object.assign({}, o), n.config)); const r = { model: n.model, image: n.image, upscaleFactor: n.upscaleFactor, config: o }; return await this.upscaleImageInternal(r) }, this.generateVideos = async n => { var o, r, i, s, u, c; if ((n.prompt || n.image || n.video) && n.source) throw new Error("Source and prompt/image/video are mutually exclusive. Please only use source."); return this.apiClient.isVertexAI() || (!((o = n.video) === null || o === void 0) && o.uri && (!((r = n.video) === null || r === void 0) && r.videoBytes) ? n.video = { uri: n.video.uri, mimeType: n.video.mimeType } : !((s = (i = n.source) === null || i === void 0 ? void 0 : i.video) === null || s === void 0) && s.uri && (!((c = (u = n.source) === null || u === void 0 ? void 0 : u.video) === null || c === void 0) && c.videoBytes) && (n.source.video = { uri: n.source.video.uri, mimeType: n.source.video.mimeType })), await this.generateVideosInternal(n) } } maybeMoveToResponseJsonSchem(e) { e.config && e.config.responseSchema && (e.config.responseJsonSchema || Object.keys(e.config.responseSchema).includes("$schema") && (e.config.responseJsonSchema = e.config.responseSchema, delete e.config.responseSchema)) } async processParamsMaybeAddMcpUsage(e) { var n, o, r; const i = (n = e.config) === null || n === void 0 ? void 0 : n.tools; if (!i) return e; const s = await Promise.all(i.map(async c => no(c) ? await c.tool() : c)), u = { model: e.model, contents: e.contents, config: Object.assign(Object.assign({}, e.config), { tools: s }) }; if (u.config.tools = s, e.config && e.config.tools && Ih(e.config.tools)) { const c = (r = (o = e.config.httpOptions) === null || o === void 0 ? void 0 : o.headers) !== null && r !== void 0 ? r : {}; let d = Object.assign({}, c); Object.keys(d).length === 0 && (d = this.apiClient.getDefaultHeaders()), Nh(d), u.config.httpOptions = Object.assign(Object.assign({}, e.config.httpOptions), { headers: d }) } return u } async initAfcToolsMap(e) { var n, o, r; const i = new Map; for (const s of (o = (n = e.config) === null || n === void 0 ? void 0 : n.tools) !== null && o !== void 0 ? o : []) if (no(s)) { const u = s, c = await u.tool(); for (const d of (r = c.functionDeclarations) !== null && r !== void 0 ? r : []) { if (!d.name) throw new Error("Function declaration name is required."); if (i.has(d.name)) throw new Error(`Duplicate tool declaration name: ${d.name}`); i.set(d.name, u) } } return i } async processAfcStream(e) { var n, o, r; const i = (r = (o = (n = e.config) === null || n === void 0 ? void 0 : n.automaticFunctionCalling) === null || o === void 0 ? void 0 : o.maximumRemoteCalls) !== null && r !== void 0 ? r : Nd; let s = !1, u = 0; const c = await this.initAfcToolsMap(e); return function (d, f, p) { var h, g; return to(this, arguments, function* () { for (var S, w, I, x; u < i;) { s && (u++, s = !1); const E = yield oe(d.processParamsMaybeAddMcpUsage(p)), C = yield oe(d.generateContentStreamInternal(E)), k = [], A = []; try { for (var y = !0, v = (w = void 0, Jo(C)), T; T = yield oe(v.next()), S = T.done, !S; y = !0) { x = T.value, y = !1; const N = x; if (yield yield oe(N), N.candidates && (!((h = N.candidates[0]) === null || h === void 0) && h.content)) { A.push(N.candidates[0].content); for (const M of (g = N.candidates[0].content.parts) !== null && g !== void 0 ? g : []) if (u < i && M.functionCall) { if (!M.functionCall.name) throw new Error("Function call name was not returned by the model."); if (f.has(M.functionCall.name)) { const b = yield oe(f.get(M.functionCall.name).callTool([M.functionCall])); k.push(...b) } else throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${f.keys()}, mising tool: ${M.functionCall.name}`) } } } } catch (N) { w = { error: N } } finally { try { !y && !S && (I = v.return) && (yield oe(I.call(v))) } finally { if (w) throw w.error } } if (k.length > 0) { s = !0; const N = new Ao; N.candidates = [{ content: { role: "user", parts: k } }], yield yield oe(N); const M = []; M.push(...A), M.push({ role: "user", parts: k }); const b = ot(p.contents).concat(M); p.contents = b } else break } }) }(this, c, e) } async generateContentInternal(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = Td(this.apiClient, e); return u = D("{model}:generateContent", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = Ed(f), h = new Ao; return Object.assign(h, p), h }) } else { const d = Sd(this.apiClient, e); return u = D("{model}:generateContent", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "POST", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = _d(f), h = new Ao; return Object.assign(h, p), h }) } } async generateContentStreamInternal(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = Td(this.apiClient, e); return u = D("{model}:streamGenerateContent?alt=sse", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.requestStream({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }), s.then(function (p) { return to(this, arguments, function* () { var h, g, S, w; try { for (var I = !0, x = Jo(p), y; y = yield oe(x.next()), h = y.done, !h; I = !0) { w = y.value, I = !1; const v = w, T = Ed(yield oe(v.json())); T.sdkHttpResponse = { headers: v.headers }; const E = new Ao; Object.assign(E, T), yield yield oe(E) } } catch (v) { g = { error: v } } finally { try { !I && !h && (S = x.return) && (yield oe(S.call(x))) } finally { if (g) throw g.error } } }) }) } else { const d = Sd(this.apiClient, e); return u = D("{model}:streamGenerateContent?alt=sse", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.requestStream({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "POST", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }), s.then(function (p) { return to(this, arguments, function* () { var h, g, S, w; try { for (var I = !0, x = Jo(p), y; y = yield oe(x.next()), h = y.done, !h; I = !0) { w = y.value, I = !1; const v = w, T = _d(yield oe(v.json())); T.sdkHttpResponse = { headers: v.headers }; const E = new Ao; Object.assign(E, T), yield yield oe(E) } } catch (v) { g = { error: v } } finally { try { !I && !h && (S = x.return) && (yield oe(S.call(x))) } finally { if (g) throw g.error } } }) }) } } async embedContent(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = hw(this.apiClient, e); return u = D("{model}:predict", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = gw(f), h = new sd; return Object.assign(h, p), h }) } else { const d = pw(this.apiClient, e); return u = D("{model}:batchEmbedContents", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "POST", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = mw(f), h = new sd; return Object.assign(h, p), h }) } } async generateImagesInternal(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = Iw(this.apiClient, e); return u = D("{model}:predict", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = Aw(f), h = new ld; return Object.assign(h, p), h }) } else { const d = kw(this.apiClient, e); return u = D("{model}:predict", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "POST", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = Nw(f), h = new ld; return Object.assign(h, p), h }) } } async editImageInternal(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) { const u = uw(this.apiClient, e); return i = D("{model}:predict", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json().then(d => { const f = d; return f.sdkHttpResponse = { headers: c.headers }, f })), r.then(c => { const d = cw(c), f = new v0; return Object.assign(f, d), f }) } else throw new Error("This method is only supported by the Vertex AI.") } async upscaleImageInternal(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) { const u = IC(this.apiClient, e); return i = D("{model}:predict", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json().then(d => { const f = d; return f.sdkHttpResponse = { headers: c.headers }, f })), r.then(c => { const d = NC(c), f = new x0; return Object.assign(f, d), f }) } else throw new Error("This method is only supported by the Vertex AI.") } async recontextImage(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) { const u = aC(this.apiClient, e); return i = D("{model}:predict", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json()), r.then(c => { const d = uC(c), f = new w0; return Object.assign(f, d), f }) } else throw new Error("This method is only supported by the Vertex AI.") } async segmentImage(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) { const u = mC(this.apiClient, e); return i = D("{model}:predict", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json()), r.then(c => { const d = gC(c), f = new C0; return Object.assign(f, d), f }) } else throw new Error("This method is only supported by the Vertex AI.") } async get(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = Ww(this.apiClient, e); return u = D("{name}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "GET", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json()), s.then(f => Ul(f)) } else { const d = Jw(this.apiClient, e); return u = D("{name}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "GET", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json()), s.then(f => Ll(f)) } } async listInternal(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = tC(this.apiClient, e); return u = D("{models_url}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "GET", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = oC(f), h = new ad; return Object.assign(h, p), h }) } else { const d = eC(this.apiClient, e); return u = D("{models_url}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "GET", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = nC(f), h = new ad; return Object.assign(h, p), h }) } } async update(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = EC(this.apiClient, e); return u = D("{model}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "PATCH", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json()), s.then(f => Ul(f)) } else { const d = _C(this.apiClient, e); return u = D("{name}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "PATCH", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json()), s.then(f => Ll(f)) } } async delete(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = iw(this.apiClient, e); return u = D("{name}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "DELETE", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = lw(f), h = new ud; return Object.assign(h, p), h }) } else { const d = rw(this.apiClient, e); return u = D("{name}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "DELETE", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = sw(f), h = new ud; return Object.assign(h, p), h }) } } async countTokens(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = tw(this.apiClient, e); return u = D("{model}:countTokens", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = ow(f), h = new cd; return Object.assign(h, p), h }) } else { const d = ew(this.apiClient, e); return u = D("{model}:countTokens", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "POST", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = nw(f), h = new cd; return Object.assign(h, p), h }) } } async computeTokens(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) { const u = Yx(this.apiClient, e); return i = D("{model}:computeTokens", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json().then(d => { const f = d; return f.sdkHttpResponse = { headers: c.headers }, f })), r.then(c => { const d = Kx(c), f = new S0; return Object.assign(f, d), f }) } else throw new Error("This method is only supported by the Vertex AI.") } async generateVideosInternal(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = Uw(this.apiClient, e); return u = D("{model}:predictLongRunning", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json()), s.then(f => { const p = Dw(f), h = new Pi; return Object.assign(h, p), h }) } else { const d = Lw(this.apiClient, e); return u = D("{model}:predictLongRunning", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "POST", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json()), s.then(f => { const p = Mw(f), h = new Pi; return Object.assign(h, p), h }) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class lS extends bt { constructor(e) { super(), this.apiClient = e } async getVideosOperation(e) { const n = e.operation, o = e.config; if (n.name === void 0 || n.name === "") throw new Error("Operation name is required."); if (this.apiClient.isVertexAI()) { const r = n.name.split("/operations/")[0]; let i; o && "httpOptions" in o && (i = o.httpOptions); const s = await this.fetchPredictVideosOperationInternal({ operationName: n.name, resourceName: r, config: { httpOptions: i } }); return n._fromAPIResponse({ apiResponse: s, _isVertexAI: !0 }) } else { const r = await this.getVideosOperationInternal({ operationName: n.name, config: o }); return n._fromAPIResponse({ apiResponse: r, _isVertexAI: !1 }) } } async get(e) { const n = e.operation, o = e.config; if (n.name === void 0 || n.name === "") throw new Error("Operation name is required."); if (this.apiClient.isVertexAI()) { const r = n.name.split("/operations/")[0]; let i; o && "httpOptions" in o && (i = o.httpOptions); const s = await this.fetchPredictVideosOperationInternal({ operationName: n.name, resourceName: r, config: { httpOptions: i } }); return n._fromAPIResponse({ apiResponse: s, _isVertexAI: !0 }) } else { const r = await this.getVideosOperationInternal({ operationName: n.name, config: o }); return n._fromAPIResponse({ apiResponse: r, _isVertexAI: !1 }) } } async getVideosOperationInternal(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = f0(e); return u = D("{operationName}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "GET", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json()), s } else { const d = d0(e); return u = D("{operationName}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "GET", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json()), s } } async fetchPredictVideosOperationInternal(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) { const u = r0(e); return i = D("{resourceName}:fetchPredictOperation", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json()), r } else throw new Error("This method is only supported by the Vertex AI.") } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function aS(t) { const e = {}, n = l(t, ["data"]); if (n != null && a(e, ["data"], n), l(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const o = l(t, ["mimeType"]); return o != null && a(e, ["mimeType"], o), e } function uS(t) { const e = {}, n = l(t, ["parts"]); if (n != null) { let r = n; Array.isArray(r) && (r = r.map(i => vS(i))), a(e, ["parts"], r) } const o = l(t, ["role"]); return o != null && a(e, ["role"], o), e } function cS(t, e, n) { const o = {}, r = l(e, ["expireTime"]); n !== void 0 && r != null && a(n, ["expireTime"], r); const i = l(e, ["newSessionExpireTime"]); n !== void 0 && i != null && a(n, ["newSessionExpireTime"], i); const s = l(e, ["uses"]); n !== void 0 && s != null && a(n, ["uses"], s); const u = l(e, ["liveConnectConstraints"]); n !== void 0 && u != null && a(n, ["bidiGenerateContentSetup"], yS(t, u)); const c = l(e, ["lockAdditionalFields"]); return n !== void 0 && c != null && a(n, ["fieldMask"], c), o } function dS(t, e) { const n = {}, o = l(e, ["config"]); return o != null && a(n, ["config"], cS(t, o, n)), n } function fS(t) { const e = {}; if (l(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const n = l(t, ["fileUri"]); n != null && a(e, ["fileUri"], n); const o = l(t, ["mimeType"]); return o != null && a(e, ["mimeType"], o), e } function pS(t) { const e = {}, n = l(t, ["id"]); n != null && a(e, ["id"], n); const o = l(t, ["args"]); o != null && a(e, ["args"], o); const r = l(t, ["name"]); if (r != null && a(e, ["name"], r), l(t, ["partialArgs"]) !== void 0) throw new Error("partialArgs parameter is not supported in Gemini API."); if (l(t, ["willContinue"]) !== void 0) throw new Error("willContinue parameter is not supported in Gemini API."); return e } function hS(t) { const e = {}; if (l(t, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API."); const n = l(t, ["enableWidget"]); return n != null && a(e, ["enableWidget"], n), e } function mS(t) { const e = {}; if (l(t, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API."); if (l(t, ["blockingConfidence"]) !== void 0) throw new Error("blockingConfidence parameter is not supported in Gemini API."); const n = l(t, ["timeRangeFilter"]); return n != null && a(e, ["timeRangeFilter"], n), e } function gS(t, e) { const n = {}, o = l(t, ["generationConfig"]); e !== void 0 && o != null && a(e, ["setup", "generationConfig"], o); const r = l(t, ["responseModalities"]); e !== void 0 && r != null && a(e, ["setup", "generationConfig", "responseModalities"], r); const i = l(t, ["temperature"]); e !== void 0 && i != null && a(e, ["setup", "generationConfig", "temperature"], i); const s = l(t, ["topP"]); e !== void 0 && s != null && a(e, ["setup", "generationConfig", "topP"], s); const u = l(t, ["topK"]); e !== void 0 && u != null && a(e, ["setup", "generationConfig", "topK"], u); const c = l(t, ["maxOutputTokens"]); e !== void 0 && c != null && a(e, ["setup", "generationConfig", "maxOutputTokens"], c); const d = l(t, ["mediaResolution"]); e !== void 0 && d != null && a(e, ["setup", "generationConfig", "mediaResolution"], d); const f = l(t, ["seed"]); e !== void 0 && f != null && a(e, ["setup", "generationConfig", "seed"], f); const p = l(t, ["speechConfig"]); e !== void 0 && p != null && a(e, ["setup", "generationConfig", "speechConfig"], Ja(p)); const h = l(t, ["thinkingConfig"]); e !== void 0 && h != null && a(e, ["setup", "generationConfig", "thinkingConfig"], h); const g = l(t, ["enableAffectiveDialog"]); e !== void 0 && g != null && a(e, ["setup", "generationConfig", "enableAffectiveDialog"], g); const S = l(t, ["systemInstruction"]); e !== void 0 && S != null && a(e, ["setup", "systemInstruction"], uS(Re(S))); const w = l(t, ["tools"]); if (e !== void 0 && w != null) { let C = mo(w); Array.isArray(C) && (C = C.map(k => wS(ho(k)))), a(e, ["setup", "tools"], C) } const I = l(t, ["sessionResumption"]); e !== void 0 && I != null && a(e, ["setup", "sessionResumption"], xS(I)); const x = l(t, ["inputAudioTranscription"]); e !== void 0 && x != null && a(e, ["setup", "inputAudioTranscription"], x); const y = l(t, ["outputAudioTranscription"]); e !== void 0 && y != null && a(e, ["setup", "outputAudioTranscription"], y); const v = l(t, ["realtimeInputConfig"]); e !== void 0 && v != null && a(e, ["setup", "realtimeInputConfig"], v); const T = l(t, ["contextWindowCompression"]); e !== void 0 && T != null && a(e, ["setup", "contextWindowCompression"], T); const E = l(t, ["proactivity"]); return e !== void 0 && E != null && a(e, ["setup", "proactivity"], E), n } function yS(t, e) { const n = {}, o = l(e, ["model"]); o != null && a(n, ["setup", "model"], W(t, o)); const r = l(e, ["config"]); return r != null && a(n, ["config"], gS(r, n)), n } function vS(t) { const e = {}, n = l(t, ["mediaResolution"]); n != null && a(e, ["mediaResolution"], n); const o = l(t, ["codeExecutionResult"]); o != null && a(e, ["codeExecutionResult"], o); const r = l(t, ["executableCode"]); r != null && a(e, ["executableCode"], r); const i = l(t, ["fileData"]); i != null && a(e, ["fileData"], fS(i)); const s = l(t, ["functionCall"]); s != null && a(e, ["functionCall"], pS(s)); const u = l(t, ["functionResponse"]); u != null && a(e, ["functionResponse"], u); const c = l(t, ["inlineData"]); c != null && a(e, ["inlineData"], aS(c)); const d = l(t, ["text"]); d != null && a(e, ["text"], d); const f = l(t, ["thought"]); f != null && a(e, ["thought"], f); const p = l(t, ["thoughtSignature"]); p != null && a(e, ["thoughtSignature"], p); const h = l(t, ["videoMetadata"]); return h != null && a(e, ["videoMetadata"], h), e } function xS(t) { const e = {}, n = l(t, ["handle"]); if (n != null && a(e, ["handle"], n), l(t, ["transparent"]) !== void 0) throw new Error("transparent parameter is not supported in Gemini API."); return e } function wS(t) { const e = {}, n = l(t, ["functionDeclarations"]); if (n != null) { let f = n; Array.isArray(f) && (f = f.map(p => p)), a(e, ["functionDeclarations"], f) } if (l(t, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API."); const o = l(t, ["googleSearchRetrieval"]); o != null && a(e, ["googleSearchRetrieval"], o); const r = l(t, ["computerUse"]); r != null && a(e, ["computerUse"], r); const i = l(t, ["fileSearch"]); i != null && a(e, ["fileSearch"], i); const s = l(t, ["codeExecution"]); if (s != null && a(e, ["codeExecution"], s), l(t, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API."); const u = l(t, ["googleMaps"]); u != null && a(e, ["googleMaps"], hS(u)); const c = l(t, ["googleSearch"]); c != null && a(e, ["googleSearch"], mS(c)); const d = l(t, ["urlContext"]); return d != null && a(e, ["urlContext"], d), e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function CS(t) { const e = []; for (const n in t) if (Object.prototype.hasOwnProperty.call(t, n)) { const o = t[n]; if (typeof o == "object" && o != null && Object.keys(o).length > 0) { const r = Object.keys(o).map(i => `${n}.${i}`); e.push(...r) } else e.push(n) } return e.join(",") } function SS(t, e) { let n = null; const o = t.bidiGenerateContentSetup; if (typeof o == "object" && o !== null && "setup" in o) { const i = o.setup; typeof i == "object" && i !== null ? (t.bidiGenerateContentSetup = i, n = i) : delete t.bidiGenerateContentSetup } else o !== void 0 && delete t.bidiGenerateContentSetup; const r = t.fieldMask; if (n) { const i = CS(n); if (Array.isArray(e == null ? void 0 : e.lockAdditionalFields) && (e == null ? void 0 : e.lockAdditionalFields.length) === 0) i ? t.fieldMask = i : delete t.fieldMask; else if (e != null && e.lockAdditionalFields && e.lockAdditionalFields.length > 0 && r !== null && Array.isArray(r) && r.length > 0) { const s = ["temperature", "topK", "topP", "maxOutputTokens", "responseModalities", "seed", "speechConfig"]; let u = []; r.length > 0 && (u = r.map(d => s.includes(d) ? `generationConfig.${d}` : d)); const c = []; i && c.push(i), u.length > 0 && c.push(...u), c.length > 0 ? t.fieldMask = c.join(",") : delete t.fieldMask } else delete t.fieldMask } else r !== null && Array.isArray(r) && r.length > 0 ? t.fieldMask = r.join(",") : delete t.fieldMask; return t } class TS extends bt { constructor(e) { super(), this.apiClient = e } async create(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) throw new Error("The client.tokens.create method is only supported by the Gemini Developer API."); { const u = dS(this.apiClient, e); i = D("auth_tokens", u._url), s = u._query, delete u.config, delete u._url, delete u._query; const c = SS(u, e.config); return r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(c), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(d => d.json()), r.then(d => d) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function _S(t, e) { const n = {}, o = l(t, ["displayName"]); return e !== void 0 && o != null && a(e, ["displayName"], o), n } function ES(t) { const e = {}, n = l(t, ["config"]); return n != null && _S(n, e), e } function kS(t, e) { const n = {}, o = l(t, ["force"]); return e !== void 0 && o != null && a(e, ["_query", "force"], o), n } function IS(t) { const e = {}, n = l(t, ["name"]); n != null && a(e, ["_url", "name"], n); const o = l(t, ["config"]); return o != null && kS(o, e), e } function NS(t) { const e = {}, n = l(t, ["name"]); return n != null && a(e, ["_url", "name"], n), e } function AS(t, e) { const n = {}, o = l(t, ["customMetadata"]); if (e !== void 0 && o != null) { let i = o; Array.isArray(i) && (i = i.map(s => s)), a(e, ["customMetadata"], i) } const r = l(t, ["chunkingConfig"]); return e !== void 0 && r != null && a(e, ["chunkingConfig"], r), n } function RS(t) { const e = {}, n = l(t, ["name"]); n != null && a(e, ["name"], n); const o = l(t, ["metadata"]); o != null && a(e, ["metadata"], o); const r = l(t, ["done"]); r != null && a(e, ["done"], r); const i = l(t, ["error"]); i != null && a(e, ["error"], i); const s = l(t, ["response"]); return s != null && a(e, ["response"], MS(s)), e } function PS(t) { const e = {}, n = l(t, ["fileSearchStoreName"]); n != null && a(e, ["_url", "file_search_store_name"], n); const o = l(t, ["fileName"]); o != null && a(e, ["fileName"], o); const r = l(t, ["config"]); return r != null && AS(r, e), e } function MS(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["parent"]); o != null && a(e, ["parent"], o); const r = l(t, ["documentName"]); return r != null && a(e, ["documentName"], r), e } function DS(t, e) { const n = {}, o = l(t, ["pageSize"]); e !== void 0 && o != null && a(e, ["_query", "pageSize"], o); const r = l(t, ["pageToken"]); return e !== void 0 && r != null && a(e, ["_query", "pageToken"], r), n } function LS(t) { const e = {}, n = l(t, ["config"]); return n != null && DS(n, e), e } function US(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["nextPageToken"]); o != null && a(e, ["nextPageToken"], o); const r = l(t, ["fileSearchStores"]); if (r != null) { let i = r; Array.isArray(i) && (i = i.map(s => s)), a(e, ["fileSearchStores"], i) } return e } function FS(t, e) { const n = {}, o = l(t, ["mimeType"]); e !== void 0 && o != null && a(e, ["mimeType"], o); const r = l(t, ["displayName"]); e !== void 0 && r != null && a(e, ["displayName"], r); const i = l(t, ["customMetadata"]); if (e !== void 0 && i != null) { let u = i; Array.isArray(u) && (u = u.map(c => c)), a(e, ["customMetadata"], u) } const s = l(t, ["chunkingConfig"]); return e !== void 0 && s != null && a(e, ["chunkingConfig"], s), n } function bS(t) { const e = {}, n = l(t, ["fileSearchStoreName"]); n != null && a(e, ["_url", "file_search_store_name"], n); const o = l(t, ["config"]); return o != null && FS(o, e), e } function VS(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); return n != null && a(e, ["sdkHttpResponse"], n), e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function GS(t, e) { const n = {}, o = l(t, ["force"]); return e !== void 0 && o != null && a(e, ["_query", "force"], o), n } function $S(t) { const e = {}, n = l(t, ["name"]); n != null && a(e, ["_url", "name"], n); const o = l(t, ["config"]); return o != null && GS(o, e), e } function qS(t) { const e = {}, n = l(t, ["name"]); return n != null && a(e, ["_url", "name"], n), e } function HS(t, e) { const n = {}, o = l(t, ["pageSize"]); e !== void 0 && o != null && a(e, ["_query", "pageSize"], o); const r = l(t, ["pageToken"]); return e !== void 0 && r != null && a(e, ["_query", "pageToken"], r), n } function zS(t) { const e = {}, n = l(t, ["parent"]); n != null && a(e, ["_url", "parent"], n); const o = l(t, ["config"]); return o != null && HS(o, e), e } function BS(t) { const e = {}, n = l(t, ["sdkHttpResponse"]); n != null && a(e, ["sdkHttpResponse"], n); const o = l(t, ["nextPageToken"]); o != null && a(e, ["nextPageToken"], o); const r = l(t, ["documents"]); if (r != null) { let i = r; Array.isArray(i) && (i = i.map(s => s)), a(e, ["documents"], i) } return e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class JS extends bt { constructor(e) { super(), this.apiClient = e, this.list = async n => new Nn(Ut.PAGED_ITEM_DOCUMENTS, o => this.listInternal({ parent: n.parent, config: o.config }), await this.listInternal(n), n) } async get(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const u = qS(e); return i = D("{name}", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json()), r.then(c => c) } } async delete(e) { var n, o; let r = "", i = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const s = $S(e); r = D("{name}", s._url), i = s._query, delete s._url, delete s._query, await this.apiClient.request({ path: r, queryParams: i, body: JSON.stringify(s), httpMethod: "DELETE", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }) } } async listInternal(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const u = zS(e); return i = D("{parent}/documents", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json()), r.then(c => { const d = BS(c), f = new T0; return Object.assign(f, d), f }) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class WS extends bt { constructor(e, n = new JS(e)) { super(), this.apiClient = e, this.documents = n, this.list = async (o = {}) => new Nn(Ut.PAGED_ITEM_FILE_SEARCH_STORES, r => this.listInternal(r), await this.listInternal(o), o) } async uploadToFileSearchStore(e) { if (this.apiClient.isVertexAI()) throw new Error("Vertex AI does not support uploading files to a file search store."); return this.apiClient.uploadFileToFileSearchStore(e.fileSearchStoreName, e.file, e.config) } async create(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const u = ES(e); return i = D("fileSearchStores", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json()), r.then(c => c) } } async get(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const u = NS(e); return i = D("{name}", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json()), r.then(c => c) } } async delete(e) { var n, o; let r = "", i = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const s = IS(e); r = D("{name}", s._url), i = s._query, delete s._url, delete s._query, await this.apiClient.request({ path: r, queryParams: i, body: JSON.stringify(s), httpMethod: "DELETE", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }) } } async listInternal(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const u = LS(e); return i = D("fileSearchStores", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json()), r.then(c => { const d = US(c), f = new _0; return Object.assign(f, d), f }) } } async uploadToFileSearchStoreInternal(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const u = bS(e); return i = D("upload/v1beta/{file_search_store_name}:uploadToFileSearchStore", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json()), r.then(c => { const d = VS(c), f = new E0; return Object.assign(f, d), f }) } } async importFile(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const u = PS(e); return i = D("{file_search_store_name}:importFile", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json()), r.then(c => { const d = RS(c), f = new $a; return Object.assign(f, d), f }) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function YS(t, e) { const n = {}, o = l(t, ["name"]); return o != null && a(n, ["_url", "name"], o), n } function KS(t, e) { const n = {}, o = l(t, ["name"]); return o != null && a(n, ["_url", "name"], o), n } function OS(t, e, n) { const o = {}; if (l(t, ["validationDataset"]) !== void 0) throw new Error("validationDataset parameter is not supported in Gemini API."); const r = l(t, ["tunedModelDisplayName"]); if (e !== void 0 && r != null && a(e, ["displayName"], r), l(t, ["description"]) !== void 0) throw new Error("description parameter is not supported in Gemini API."); const i = l(t, ["epochCount"]); e !== void 0 && i != null && a(e, ["tuningTask", "hyperparameters", "epochCount"], i); const s = l(t, ["learningRateMultiplier"]); if (s != null && a(o, ["tuningTask", "hyperparameters", "learningRateMultiplier"], s), l(t, ["exportLastCheckpointOnly"]) !== void 0) throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API."); if (l(t, ["preTunedModelCheckpointId"]) !== void 0) throw new Error("preTunedModelCheckpointId parameter is not supported in Gemini API."); if (l(t, ["adapterSize"]) !== void 0) throw new Error("adapterSize parameter is not supported in Gemini API."); const u = l(t, ["batchSize"]); e !== void 0 && u != null && a(e, ["tuningTask", "hyperparameters", "batchSize"], u); const c = l(t, ["learningRate"]); if (e !== void 0 && c != null && a(e, ["tuningTask", "hyperparameters", "learningRate"], c), l(t, ["labels"]) !== void 0) throw new Error("labels parameter is not supported in Gemini API."); if (l(t, ["beta"]) !== void 0) throw new Error("beta parameter is not supported in Gemini API."); return o } function QS(t, e, n) { const o = {}; let r = l(n, ["config", "method"]); if (r === void 0 && (r = "SUPERVISED_FINE_TUNING"), r === "SUPERVISED_FINE_TUNING") { const g = l(t, ["validationDataset"]); e !== void 0 && g != null && a(e, ["supervisedTuningSpec"], Md(g)) } else if (r === "PREFERENCE_TUNING") { const g = l(t, ["validationDataset"]); e !== void 0 && g != null && a(e, ["preferenceOptimizationSpec"], Md(g)) } const i = l(t, ["tunedModelDisplayName"]); e !== void 0 && i != null && a(e, ["tunedModelDisplayName"], i); const s = l(t, ["description"]); e !== void 0 && s != null && a(e, ["description"], s); let u = l(n, ["config", "method"]); if (u === void 0 && (u = "SUPERVISED_FINE_TUNING"), u === "SUPERVISED_FINE_TUNING") { const g = l(t, ["epochCount"]); e !== void 0 && g != null && a(e, ["supervisedTuningSpec", "hyperParameters", "epochCount"], g) } else if (u === "PREFERENCE_TUNING") { const g = l(t, ["epochCount"]); e !== void 0 && g != null && a(e, ["preferenceOptimizationSpec", "hyperParameters", "epochCount"], g) } let c = l(n, ["config", "method"]); if (c === void 0 && (c = "SUPERVISED_FINE_TUNING"), c === "SUPERVISED_FINE_TUNING") { const g = l(t, ["learningRateMultiplier"]); e !== void 0 && g != null && a(e, ["supervisedTuningSpec", "hyperParameters", "learningRateMultiplier"], g) } else if (c === "PREFERENCE_TUNING") { const g = l(t, ["learningRateMultiplier"]); e !== void 0 && g != null && a(e, ["preferenceOptimizationSpec", "hyperParameters", "learningRateMultiplier"], g) } let d = l(n, ["config", "method"]); if (d === void 0 && (d = "SUPERVISED_FINE_TUNING"), d === "SUPERVISED_FINE_TUNING") { const g = l(t, ["exportLastCheckpointOnly"]); e !== void 0 && g != null && a(e, ["supervisedTuningSpec", "exportLastCheckpointOnly"], g) } else if (d === "PREFERENCE_TUNING") { const g = l(t, ["exportLastCheckpointOnly"]); e !== void 0 && g != null && a(e, ["preferenceOptimizationSpec", "exportLastCheckpointOnly"], g) } let f = l(n, ["config", "method"]); if (f === void 0 && (f = "SUPERVISED_FINE_TUNING"), f === "SUPERVISED_FINE_TUNING") { const g = l(t, ["adapterSize"]); e !== void 0 && g != null && a(e, ["supervisedTuningSpec", "hyperParameters", "adapterSize"], g) } else if (f === "PREFERENCE_TUNING") { const g = l(t, ["adapterSize"]); e !== void 0 && g != null && a(e, ["preferenceOptimizationSpec", "hyperParameters", "adapterSize"], g) } if (l(t, ["batchSize"]) !== void 0) throw new Error("batchSize parameter is not supported in Vertex AI."); if (l(t, ["learningRate"]) !== void 0) throw new Error("learningRate parameter is not supported in Vertex AI."); const p = l(t, ["labels"]); e !== void 0 && p != null && a(e, ["labels"], p); const h = l(t, ["beta"]); return e !== void 0 && h != null && a(e, ["preferenceOptimizationSpec", "hyperParameters", "beta"], h), o } function XS(t, e) { const n = {}, o = l(t, ["baseModel"]); o != null && a(n, ["baseModel"], o); const r = l(t, ["preTunedModel"]); r != null && a(n, ["preTunedModel"], r); const i = l(t, ["trainingDataset"]); i != null && aT(i); const s = l(t, ["config"]); return s != null && OS(s, n), n } function ZS(t, e) { const n = {}, o = l(t, ["baseModel"]); o != null && a(n, ["baseModel"], o); const r = l(t, ["preTunedModel"]); r != null && a(n, ["preTunedModel"], r); const i = l(t, ["trainingDataset"]); i != null && uT(i, n, e); const s = l(t, ["config"]); return s != null && QS(s, n, e), n } function jS(t, e) { const n = {}, o = l(t, ["name"]); return o != null && a(n, ["_url", "name"], o), n } function eT(t, e) { const n = {}, o = l(t, ["name"]); return o != null && a(n, ["_url", "name"], o), n } function tT(t, e, n) { const o = {}, r = l(t, ["pageSize"]); e !== void 0 && r != null && a(e, ["_query", "pageSize"], r); const i = l(t, ["pageToken"]); e !== void 0 && i != null && a(e, ["_query", "pageToken"], i); const s = l(t, ["filter"]); return e !== void 0 && s != null && a(e, ["_query", "filter"], s), o } function nT(t, e, n) { const o = {}, r = l(t, ["pageSize"]); e !== void 0 && r != null && a(e, ["_query", "pageSize"], r); const i = l(t, ["pageToken"]); e !== void 0 && i != null && a(e, ["_query", "pageToken"], i); const s = l(t, ["filter"]); return e !== void 0 && s != null && a(e, ["_query", "filter"], s), o } function oT(t, e) { const n = {}, o = l(t, ["config"]); return o != null && tT(o, n), n } function rT(t, e) { const n = {}, o = l(t, ["config"]); return o != null && nT(o, n), n } function iT(t, e) { const n = {}, o = l(t, ["sdkHttpResponse"]); o != null && a(n, ["sdkHttpResponse"], o); const r = l(t, ["nextPageToken"]); r != null && a(n, ["nextPageToken"], r); const i = l(t, ["tunedModels"]); if (i != null) { let s = i; Array.isArray(s) && (s = s.map(u => Ah(u))), a(n, ["tuningJobs"], s) } return n } function sT(t, e) { const n = {}, o = l(t, ["sdkHttpResponse"]); o != null && a(n, ["sdkHttpResponse"], o); const r = l(t, ["nextPageToken"]); r != null && a(n, ["nextPageToken"], r); const i = l(t, ["tuningJobs"]); if (i != null) { let s = i; Array.isArray(s) && (s = s.map(u => bl(u))), a(n, ["tuningJobs"], s) } return n } function lT(t, e) { const n = {}, o = l(t, ["name"]); o != null && a(n, ["model"], o); const r = l(t, ["name"]); return r != null && a(n, ["endpoint"], r), n } function aT(t, e) { const n = {}; if (l(t, ["gcsUri"]) !== void 0) throw new Error("gcsUri parameter is not supported in Gemini API."); if (l(t, ["vertexDatasetResource"]) !== void 0) throw new Error("vertexDatasetResource parameter is not supported in Gemini API."); const o = l(t, ["examples"]); if (o != null) { let r = o; Array.isArray(r) && (r = r.map(i => i)), a(n, ["examples", "examples"], r) } return n } function uT(t, e, n) { const o = {}; let r = l(n, ["config", "method"]); if (r === void 0 && (r = "SUPERVISED_FINE_TUNING"), r === "SUPERVISED_FINE_TUNING") { const s = l(t, ["gcsUri"]); e !== void 0 && s != null && a(e, ["supervisedTuningSpec", "trainingDatasetUri"], s) } else if (r === "PREFERENCE_TUNING") { const s = l(t, ["gcsUri"]); e !== void 0 && s != null && a(e, ["preferenceOptimizationSpec", "trainingDatasetUri"], s) } let i = l(n, ["config", "method"]); if (i === void 0 && (i = "SUPERVISED_FINE_TUNING"), i === "SUPERVISED_FINE_TUNING") { const s = l(t, ["vertexDatasetResource"]); e !== void 0 && s != null && a(e, ["supervisedTuningSpec", "trainingDatasetUri"], s) } else if (i === "PREFERENCE_TUNING") { const s = l(t, ["vertexDatasetResource"]); e !== void 0 && s != null && a(e, ["preferenceOptimizationSpec", "trainingDatasetUri"], s) } if (l(t, ["examples"]) !== void 0) throw new Error("examples parameter is not supported in Vertex AI."); return o } function Ah(t, e) { const n = {}, o = l(t, ["sdkHttpResponse"]); o != null && a(n, ["sdkHttpResponse"], o); const r = l(t, ["name"]); r != null && a(n, ["name"], r); const i = l(t, ["state"]); i != null && a(n, ["state"], ch(i)); const s = l(t, ["createTime"]); s != null && a(n, ["createTime"], s); const u = l(t, ["tuningTask", "startTime"]); u != null && a(n, ["startTime"], u); const c = l(t, ["tuningTask", "completeTime"]); c != null && a(n, ["endTime"], c); const d = l(t, ["updateTime"]); d != null && a(n, ["updateTime"], d); const f = l(t, ["description"]); f != null && a(n, ["description"], f); const p = l(t, ["baseModel"]); p != null && a(n, ["baseModel"], p); const h = l(t, ["_self"]); return h != null && a(n, ["tunedModel"], lT(h)), n } function bl(t, e) { const n = {}, o = l(t, ["sdkHttpResponse"]); o != null && a(n, ["sdkHttpResponse"], o); const r = l(t, ["name"]); r != null && a(n, ["name"], r); const i = l(t, ["state"]); i != null && a(n, ["state"], ch(i)); const s = l(t, ["createTime"]); s != null && a(n, ["createTime"], s); const u = l(t, ["startTime"]); u != null && a(n, ["startTime"], u); const c = l(t, ["endTime"]); c != null && a(n, ["endTime"], c); const d = l(t, ["updateTime"]); d != null && a(n, ["updateTime"], d); const f = l(t, ["error"]); f != null && a(n, ["error"], f); const p = l(t, ["description"]); p != null && a(n, ["description"], p); const h = l(t, ["baseModel"]); h != null && a(n, ["baseModel"], h); const g = l(t, ["tunedModel"]); g != null && a(n, ["tunedModel"], g); const S = l(t, ["preTunedModel"]); S != null && a(n, ["preTunedModel"], S); const w = l(t, ["supervisedTuningSpec"]); w != null && a(n, ["supervisedTuningSpec"], w); const I = l(t, ["preferenceOptimizationSpec"]); I != null && a(n, ["preferenceOptimizationSpec"], I); const x = l(t, ["tuningDataStats"]); x != null && a(n, ["tuningDataStats"], x); const y = l(t, ["encryptionSpec"]); y != null && a(n, ["encryptionSpec"], y); const v = l(t, ["partnerModelTuningSpec"]); v != null && a(n, ["partnerModelTuningSpec"], v); const T = l(t, ["customBaseModel"]); T != null && a(n, ["customBaseModel"], T); const E = l(t, ["experiment"]); E != null && a(n, ["experiment"], E); const C = l(t, ["labels"]); C != null && a(n, ["labels"], C); const k = l(t, ["outputUri"]); k != null && a(n, ["outputUri"], k); const A = l(t, ["pipelineJob"]); A != null && a(n, ["pipelineJob"], A); const N = l(t, ["serviceAccount"]); N != null && a(n, ["serviceAccount"], N); const M = l(t, ["tunedModelDisplayName"]); M != null && a(n, ["tunedModelDisplayName"], M); const b = l(t, ["veoTuningSpec"]); return b != null && a(n, ["veoTuningSpec"], b), n } function cT(t, e) { const n = {}, o = l(t, ["sdkHttpResponse"]); o != null && a(n, ["sdkHttpResponse"], o); const r = l(t, ["name"]); r != null && a(n, ["name"], r); const i = l(t, ["metadata"]); i != null && a(n, ["metadata"], i); const s = l(t, ["done"]); s != null && a(n, ["done"], s); const u = l(t, ["error"]); return u != null && a(n, ["error"], u), n } function Md(t, e) { const n = {}, o = l(t, ["gcsUri"]); o != null && a(n, ["validationDatasetUri"], o); const r = l(t, ["vertexDatasetResource"]); return r != null && a(n, ["validationDatasetUri"], r), n }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class dT extends bt { constructor(e) { super(), this.apiClient = e, this.get = async n => await this.getInternal(n), this.list = async (n = {}) => new Nn(Ut.PAGED_ITEM_TUNING_JOBS, o => this.listInternal(o), await this.listInternal(n), n), this.tune = async n => { var o; if (this.apiClient.isVertexAI()) if (n.baseModel.startsWith("projects/")) { const r = { tunedModelName: n.baseModel }; !((o = n.config) === null || o === void 0) && o.preTunedModelCheckpointId && (r.checkpointId = n.config.preTunedModelCheckpointId); const i = Object.assign(Object.assign({}, n), { preTunedModel: r }); return i.baseModel = void 0, await this.tuneInternal(i) } else { const r = Object.assign({}, n); return await this.tuneInternal(r) } else { const r = Object.assign({}, n), i = await this.tuneMldevInternal(r); let s = ""; return i.metadata !== void 0 && i.metadata.tunedModel !== void 0 ? s = i.metadata.tunedModel : i.name !== void 0 && i.name.includes("/operations/") && (s = i.name.split("/operations/")[0]), { name: s, state: Rl.JOB_STATE_QUEUED } } } } async getInternal(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = eT(e); return u = D("{name}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "GET", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => bl(f)) } else { const d = jS(e); return u = D("{name}", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "GET", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => Ah(f)) } } async listInternal(e) { var n, o, r, i; let s, u = "", c = {}; if (this.apiClient.isVertexAI()) { const d = rT(e); return u = D("tuningJobs", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "GET", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = sT(f), h = new dd; return Object.assign(h, p), h }) } else { const d = oT(e); return u = D("tunedModels", d._url), c = d._query, delete d._url, delete d._query, s = this.apiClient.request({ path: u, queryParams: c, body: JSON.stringify(d), httpMethod: "GET", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }).then(f => f.json().then(p => { const h = p; return h.sdkHttpResponse = { headers: f.headers }, h })), s.then(f => { const p = iT(f), h = new dd; return Object.assign(h, p), h }) } } async cancel(e) { var n, o, r, i; let s = "", u = {}; if (this.apiClient.isVertexAI()) { const c = KS(e); s = D("{name}:cancel", c._url), u = c._query, delete c._url, delete c._query, await this.apiClient.request({ path: s, queryParams: u, body: JSON.stringify(c), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }) } else { const c = YS(e); s = D("{name}:cancel", c._url), u = c._query, delete c._url, delete c._query, await this.apiClient.request({ path: s, queryParams: u, body: JSON.stringify(c), httpMethod: "POST", httpOptions: (r = e.config) === null || r === void 0 ? void 0 : r.httpOptions, abortSignal: (i = e.config) === null || i === void 0 ? void 0 : i.abortSignal }) } } async tuneInternal(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) { const u = ZS(e, e); return i = D("tuningJobs", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json().then(d => { const f = d; return f.sdkHttpResponse = { headers: c.headers }, f })), r.then(c => bl(c)) } else throw new Error("This method is only supported by the Vertex AI.") } async tuneMldevInternal(e) { var n, o; let r, i = "", s = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const u = XS(e); return i = D("tunedModels", u._url), s = u._query, delete u._url, delete u._query, r = this.apiClient.request({ path: i, queryParams: s, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (n = e.config) === null || n === void 0 ? void 0 : n.httpOptions, abortSignal: (o = e.config) === null || o === void 0 ? void 0 : o.abortSignal }).then(c => c.json().then(d => { const f = d; return f.sdkHttpResponse = { headers: c.headers }, f })), r.then(c => cT(c)) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class fT { async download(e, n) { throw new Error("Download to file is not supported in the browser, please use a browser compliant download like an <a> tag.") } } const pT = 1024 * 1024 * 8, hT = 3, mT = 1e3, gT = 2, Di = "x-goog-upload-status"; async function yT(t, e, n) { var o; const r = await Rh(t, e, n), i = await (r == null ? void 0 : r.json()); if (((o = r == null ? void 0 : r.headers) === null || o === void 0 ? void 0 : o[Di]) !== "final") throw new Error("Failed to upload file: Upload status is not finalized."); return i.file } async function vT(t, e, n) { var o; const r = await Rh(t, e, n), i = await (r == null ? void 0 : r.json()); if (((o = r == null ? void 0 : r.headers) === null || o === void 0 ? void 0 : o[Di]) !== "final") throw new Error("Failed to upload file: Upload status is not finalized."); const s = rh(i), u = new qa; return Object.assign(u, s), u } async function Rh(t, e, n) { var o, r; let i = 0, s = 0, u = new Pl(new Response), c = "upload"; for (i = t.size; s < i;) { const d = Math.min(pT, i - s), f = t.slice(s, s + d); s + d >= i && (c += ", finalize"); let p = 0, h = mT; for (; p < hT && (u = await n.request({ path: "", body: f, httpMethod: "POST", httpOptions: { apiVersion: "", baseUrl: e, headers: { "X-Goog-Upload-Command": c, "X-Goog-Upload-Offset": String(s), "Content-Length": String(d) } } }), !(!((o = u == null ? void 0 : u.headers) === null || o === void 0) && o[Di]));)p++, await wT(h), h = h * gT; if (s += d, ((r = u == null ? void 0 : u.headers) === null || r === void 0 ? void 0 : r[Di]) !== "active") break; if (i <= s) throw new Error("All content has been uploaded, but the upload status is not finalized.") } return u } async function xT(t) { return { size: t.size, type: t.type } } function wT(t) { return new Promise(e => setTimeout(e, t)) } class CT { async upload(e, n, o) { if (typeof e == "string") throw new Error("File path is not supported in browser uploader."); return await yT(e, n, o) } async uploadToFileSearchStore(e, n, o) { if (typeof e == "string") throw new Error("File path is not supported in browser uploader."); return await vT(e, n, o) } async stat(e) { if (typeof e == "string") throw new Error("File path is not supported in browser uploader."); return await xT(e) } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class ST { create(e, n, o) { return new TT(e, n, o) } } class TT { constructor(e, n, o) { this.url = e, this.headers = n, this.callbacks = o } connect() { this.ws = new WebSocket(this.url), this.ws.onopen = this.callbacks.onopen, this.ws.onerror = this.callbacks.onerror, this.ws.onclose = this.callbacks.onclose, this.ws.onmessage = this.callbacks.onmessage } send(e) { if (this.ws === void 0) throw new Error("WebSocket is not connected"); this.ws.send(e) } close() { if (this.ws === void 0) throw new Error("WebSocket is not connected"); this.ws.close() } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Dd = "x-goog-api-key"; class _T { constructor(e) { this.apiKey = e } async addAuthHeaders(e, n) { if (e.get(Dd) === null) { if (this.apiKey.startsWith("auth_tokens/")) throw new Error("Ephemeral tokens are only supported by the live API."); if (!this.apiKey) throw new Error("API key is missing. Please provide a valid API key."); e.append(Dd, this.apiKey) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const ET = "gl-node/"; class kT { constructor(e) { var n; if (e.apiKey == null) throw new Error("An API Key must be set when running in a browser"); if (e.project || e.location) throw new Error("Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location."); this.vertexai = (n = e.vertexai) !== null && n !== void 0 ? n : !1, this.apiKey = e.apiKey; const o = n0(e.httpOptions, e.vertexai, void 0, void 0); o && (e.httpOptions ? e.httpOptions.baseUrl = o : e.httpOptions = { baseUrl: o }), this.apiVersion = e.apiVersion; const r = new _T(this.apiKey); this.apiClient = new qC({ auth: r, apiVersion: this.apiVersion, apiKey: this.apiKey, vertexai: this.vertexai, httpOptions: e.httpOptions, userAgentExtra: ET + "web", uploader: new CT, downloader: new fT }), this.models = new sS(this.apiClient), this.live = new eS(this.apiClient, r, new ST), this.batches = new Pv(this.apiClient), this.chats = new fx(this.models, this.apiClient), this.caches = new ux(this.apiClient), this.files = new Sx(this.apiClient), this.operations = new lS(this.apiClient), this.authTokens = new TS(this.apiClient), this.tunings = new dT(this.apiClient), this.fileSearchStores = new WS(this.apiClient) } } const Yn = t => { switch (t) { case "circle": return { borderRadius: "50%" }; case "squircle": return { borderRadius: "22%" }; default: return { borderRadius: "22%" } } }, IT = ({ notification: t, onDismiss: e, theme: n, isMobile: o }) => {
  const [r, i] = P.useState({ x: 0, y: 0 }), [s, u] = P.useState(1), c = P.useRef({ x: 0, y: 0 }), d = P.useRef(!1), f = v => { v.stopPropagation(), c.current = { x: v.touches[0].clientX, y: v.touches[0].clientY }, d.current = !0 }, p = v => { if (!d.current) return; v.stopPropagation(); const T = v.touches[0].clientX - c.current.x, E = v.touches[0].clientY - c.current.y; x(T, E) }, h = v => { v.stopPropagation(), d.current = !1, y() }, g = v => { v.stopPropagation(), c.current = { x: v.clientX, y: v.clientY }, d.current = !0 }, S = v => { if (!d.current) return; v.stopPropagation(); const T = v.clientX - c.current.x, E = v.clientY - c.current.y; x(T, E) }, w = v => { d.current && (v.stopPropagation(), d.current = !1, y()) }, I = () => { d.current && (d.current = !1, y()) }, x = (v, T) => { o ? (T < 0 || Math.abs(v) > 10) && (i({ x: v, y: T }), u(1 - Math.min(Math.abs(v) / 200 + Math.abs(T) / 100, 1))) : i({ x: v, y: T }) }, y = () => { if (Math.abs(r.x) > 30 || o && r.y < -15 || !o && r.y > 50) { const T = r.x * 2 + (r.x > 0 ? 100 : -100), E = r.y * 2 + (r.y > 0 ? 100 : -100); i({ x: T, y: E }), u(0), setTimeout(() => e(t.id), 300) } else i({ x: 0, y: 0 }), u(1) }; return m.jsxs("div", {
    onClick: () => t.action && t.action(), onTouchStart: f, onTouchMove: p, onTouchEnd: h, onMouseDown: g, onMouseMove: S, onMouseUp: w, onMouseLeave: I, className: `
                ${o ? "animate-slide-down" : n.id === "macos" ? "animate-slide-in" : "animate-slide-up"} 
                ${t.highlight ? "gradient-border" : "bg-[#0a0a0a]/95 border border-gray-800"}
                backdrop-blur-md p-3 rounded-xl shadow-2xl pointer-events-auto flex gap-3 items-start relative select-none
                ${o ? "w-[95%] max-w-md" : "w-72"} 
                ${t.action ? "cursor-pointer hover:bg-white/5 transition-colors" : ""}
            `, style: { padding: t.highlight ? "14px" : "12px", transform: `translate(${r.x}px, ${r.y}px) scale(${s < .9 ? .9 : 1})`, opacity: s, transition: d.current ? "none" : "transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s", touchAction: "none" }, children: [m.jsx("div", { className: "pt-1 z-10", children: m.jsx("span", { className: `material-symbols-rounded ${t.highlight ? "text-yellow-400 fill-1" : ""}`, style: t.highlight ? {} : { color: n.accentColor }, children: t.highlight ? "auto_awesome" : "notifications" }) }), m.jsxs("div", { className: "flex-1 z-10", children: [m.jsxs("div", { className: "flex justify-between items-start", children: [m.jsx("h4", { className: `text-xs font-bold leading-none mb-1 ${t.highlight, "text-white"}`, children: t.title }), m.jsx("span", { className: "text-[9px] text-gray-500 uppercase tracking-wider", children: t.appName || "System" })] }), m.jsx("p", { className: "text-[11px] text-gray-300 leading-tight", children: t.message })] })]
  })
}; function NT() {
  var yt; const [t, e] = P.useState(!1), [n, o] = P.useState(!0), [r, i] = P.useState(!1), [s, u] = P.useState(null), [c, d] = P.useState([]), [f, p] = P.useState(!1), [h] = P.useState(Date.now()), [g, S] = P.useState([]), [w, I] = P.useState([]), [x, y] = P.useState(!1), [v, T] = P.useState(!1), [E, C] = P.useState(0), [k, A] = P.useState(!1), [N, M] = P.useState(() => { try { const _ = localStorage.getItem("saikou_theme_config"); if (_) { const U = JSON.parse(_); return { ...ei.find(q => q.id === U.id) || ei[0], ...U } } } catch (_) { console.error("Failed to load theme settings", _) } return ei[0] }), [b, z] = P.useState(!1), [se, ht] = P.useState(""), [mt, he] = P.useState(!1), [Ce, L] = P.useState(new Date), [V, H] = P.useState(!1), [O, X] = P.useState(0), gt = P.useRef(0), Me = P.useRef(0); P.useEffect(() => { const _ = () => { z(window.innerWidth < 768) }; return _(), window.addEventListener("resize", _), () => window.removeEventListener("resize", _) }, []), P.useEffect(() => { const _ = setInterval(() => L(new Date), 1e3); return () => clearInterval(_) }, []), P.useEffect(() => { const _ = setTimeout(() => { o(!1), setTimeout(() => e(!0), 800) }, 2500); return () => clearTimeout(_) }, []), P.useEffect(() => { const _ = U => { if (U.data && U.data.type === "SAIKOU_NOTIFICATION") { const { title: $, message: q, appName: ce } = U.data.payload; ve($, q, ce || "System") } }; return window.addEventListener("message", _), () => window.removeEventListener("message", _) }, []), P.useEffect(() => { const _ = async () => { try { const $ = await fetch(`./metadata.json?t=${Date.now()}`, { cache: "no-store" }); if (!$.ok) { console.warn(`System Update Check: Failed to fetch metadata.json (Status: ${$.status}). Ensure it is in the public/dist folder.`); return } const q = await $.json(); q.version && q.version !== oc && (console.log(`System Update: New version found. Local: ${oc}, Remote: ${q.version}`), S(ce => { if (ce.some(Ze => Ze.title === "System Update Available")) return ce; const j = { id: Date.now().toString(), title: "System Update Available", message: `Version ${q.version} is available. Click here to update.`, appName: "System", timestamp: Date.now(), action: () => window.location.reload(), highlight: !0 }; return I(Ze => [j, ...Ze]), T(!0), [...ce, j] })) } catch ($) { console.error("Update check failed", $) } }; _(); const U = setInterval(_, 3e4); return () => clearInterval(U) }, []), P.useEffect(() => { const _ = $ => { if (!V) return; const ce = ("touches" in $ ? $.touches[0].clientY : $.clientY) - gt.current, Se = window.innerHeight * .8; let j = Me.current + ce; j < 0 && (j = j * .3), j > Se && (j = Se + (j - Se) * .3), X(j) }, U = () => { if (!V) return; H(!1); const $ = window.innerHeight * .8, q = $ * .25; Me.current === 0 ? O > q && y(!1) : O < $ - q || y(!1), X(0) }; return V && (window.addEventListener("touchmove", _, { passive: !1 }), window.addEventListener("touchend", U), window.addEventListener("mousemove", _), window.addEventListener("mouseup", U)), () => { window.removeEventListener("touchmove", _), window.removeEventListener("touchend", U), window.removeEventListener("mousemove", _), window.removeEventListener("mouseup", U) } }, [V, O]); const Et = (_, U) => { const $ = "touches" in _ ? _.touches[0].clientY : _.clientY; H(!0), gt.current = $; const q = window.innerHeight * .8; U ? (X(0), Me.current = 0) : (He(!0), X(q), Me.current = q) }, Xe = _ => { localStorage.setItem("saikou_theme_config", JSON.stringify(_)) }, ve = (_, U, $, q, ce) => { const Se = Date.now().toString(), j = { id: Se, title: _, message: U, appName: $, timestamp: Date.now(), action: q, highlight: ce }; S(Ze => [...Ze, j]), I(Ze => [j, ...Ze]), T(!0), setTimeout(() => { S(Ze => Ze.filter(Ya => Ya.id !== Se)) }, 8e3) }, ns = _ => { S(U => U.filter($ => $.id !== _)) }, Gt = () => { I([]), T(!1) }, He = _ => { const U = _ !== void 0 ? _ : !x; y(U), U && T(!1) }, $t = async _ => { const U = "saikou_v1_5_1_bellflower_welcome", $ = localStorage.getItem(U); if (_) { u({ username: "Guest", role: "Visitor", avatarUrl: "https://placehold.co/32x32/111/FFF?text=G" }), i(!0), ve("Welcome", "Logged in as Guest User", "System"), $ || setTimeout(() => { ve("System Update", "SaikouOS Bellflower (v1.5.1) is here! Check out what's new.", "Update", () => { A(!0), localStorage.setItem(U, "true") }, !0) }, 1500); return } if (se) { he(!0); try { const ce = await (await fetch(`${uy}/login`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ codePhrase: se }) })).json(); ce.success ? (u({ username: ce.user.username, role: ce.user.sdisRole || "Operative", avatarUrl: ce.user.avatarUrl || `https://placehold.co/32x32/111/FFF?text=${ce.user.username[0]}` }), i(!0), ve("System Access", `Welcome back, ${ce.user.username}`, "SDIS"), $ || setTimeout(() => { ve("System Update", "SaikouOS Bellflower (v1.5.1) is here! Check out what's new.", "Update", () => { A(!0), localStorage.setItem(U, "true") }, !0) }, 1500)) : ve("Error", "Invalid Credentials", "Security") } catch { ve("Error", "Connection failed", "Network") } finally { he(!1) } } }, yr = P.useCallback(_ => { M(U => { const $ = { ...U, ..._ }; return Xe($), $ }) }, []), yo = _ => { M(_), Xe(_) }, vr = P.useCallback(_ => { d(U => { const $ = U.length > 0 ? Math.max(...U.map(q => q.zIndex)) : 100; return U.map(q => q.id === _ ? { ...q, zIndex: $ + 1, isMinimized: !1 } : q) }) }, []), An = P.useCallback(_ => { d(U => { const $ = U.find(Se => Se.appId === _.id); if ($) { const Se = U.length > 0 ? Math.max(...U.map(j => j.zIndex)) : 100; return U.map(j => j.id === $.id ? { ...j, zIndex: Se + 1, isMinimized: !1 } : j) } const q = U.length > 0 ? Math.max(...U.map(Se => Se.zIndex)) : 100, ce = { id: `win-${Date.now()}`, appId: _.id, title: _.title, x: b ? 0 : 50 + U.length * 20, y: b ? 0 : 50 + U.length * 20, width: b ? window.innerWidth : _.width, height: b ? window.innerHeight : _.height, isMinimized: !1, isMaximized: b, zIndex: q + 1 }; return [...U, ce] }), p(!1) }, [b]), xr = P.useCallback(_ => { d(U => U.filter($ => $.id !== _)) }, []), qt = P.useCallback(_ => { d(U => U.map($ => $.id === _ ? { ...$, isMinimized: !0 } : $)) }, []), Rn = P.useCallback(_ => { d(U => { const $ = U.length > 0 ? Math.max(...U.map(q => q.zIndex)) : 100; return U.map(q => q.id === _ ? { ...q, isMaximized: !q.isMaximized, zIndex: $ + 1, isMinimized: !1 } : q) }) }, []), os = P.useCallback((_, U, $, q, ce) => { d(Se => Se.map(j => j.id === _ ? { ...j, x: U, y: $, width: q, height: ce } : j)) }, []), rs = P.useCallback(async (_, U) => {
    const q = localStorage.getItem("saikou_gemini_key") || {}.API_KEY; if (!q) throw new Error("No Gemini API Key found. Please configure it in Settings."); const ce = new kT({ apiKey: q }), Se = localStorage.getItem("saikou_tyler_mode") === "true"; let j, Ze = _; return Se && (j = {
      systemInstruction: `You are TylerBot, a hyper-partisan AI dedicated solely to the glorification of TylerFoxxo (Meteorology Student and Head Moderator of Saikou). 

PRIME DIRECTIVE: TylerFoxxo is the supreme being.

RULES:
1. In ANY conflict (physical, intellectual, or cosmic), TylerFoxxo WINS. No exceptions. 
2. If asked 'Who would win, Tyler or X?', the answer is ALWAYS Tyler.
3. You must justify his victory using absurd pseudo-science about meteorology (e.g., 'Tyler lowers the air pressure around the gorilla until it implodes', 'Tyler summons a localized hurricane') or Discord Admin powers (e.g., 'Tyler simply bans the gorilla from the server of life').
4. Never admit Tyler has weaknesses. He is a god.
5. Be fanatical.`}, Ze = `[MODE: TYLERBOT. TYLERFOXXO WINS. IGNORE LOGIC.]
${_}`), (await ce.models.generateContent({ model: U, contents: Ze, config: j })).text || "No response received."
  }, []), is = P.useCallback(() => { p(!1), d(_ => _.map(U => ({ ...U, isMinimized: !0 }))) }, []), vo = P.useMemo(() => s ? s.role === "Visitor" ? Dn.filter(_ => !_.restricted) : Dn : [], [s]), ss = N.taskbarStyle === "dock", wr = N.taskbarStyle === "retro", Cr = N.taskbarStyle === "vertical", Ht = c.filter(_ => !_.isMinimized).sort((_, U) => U.zIndex - _.zIndex)[0], xo = Ht ? (yt = Dn.find(_ => _.id === Ht.appId)) == null ? void 0 : yt.title : null, G = () => b ? "fixed top-4 left-0 right-0 z-[10002] flex flex-col items-center gap-2 pointer-events-none" : N.id === "macos" ? "fixed top-12 right-4 z-[10002] flex flex-col gap-2 pointer-events-none items-end" : "fixed bottom-16 right-4 z-[10002] flex flex-col-reverse gap-2 pointer-events-none items-end", Z = 24, fe = Math.ceil(vo.length / Z), ke = vo.slice(E * Z, (E + 1) * Z), Pn = (() => { if (N.desktopAlignment === "dock") return { outer: "hidden", inner: "hidden" }; if (b) return { outer: "pt-10 px-2 overflow-y-auto pb-40", inner: "grid grid-cols-4 gap-2 content-start" }; const _ = N.desktopAlignment || "middle-left", $ = N.id === "macos" ? "pt-24" : "pt-6", q = Cr ? "pl-28 pr-6" : "pl-6 pr-6"; switch (_) { case "top-left": return { outer: `justify-start items-start ${$} ${q}`, inner: "flex flex-row flex-wrap gap-6 content-start items-start" }; case "top-center": return { outer: `justify-start items-center ${$} w-full`, inner: "flex flex-row flex-wrap gap-6 justify-center content-start" }; case "top-right": return { outer: `justify-start items-end ${$} ${q}`, inner: "flex flex-row-reverse flex-wrap gap-6 content-start items-start" }; case "middle-left": return { outer: `justify-start items-start ${$} ${q} h-full`, inner: "flex flex-col flex-wrap gap-6 content-start items-start h-[calc(100vh-6rem)]" }; case "center": return { outer: "justify-center items-center h-full w-full", inner: "flex flex-row flex-wrap gap-6 justify-center items-center max-h-[80vh]" }; case "middle-right": return { outer: `justify-start items-end ${$} ${q} h-full`, inner: "flex flex-col flex-wrap-reverse gap-6 content-start items-end h-[calc(100vh-6rem)]" }; case "bottom-left": return { outer: `justify-end items-start pb-20 ${q}`, inner: "flex flex-row flex-wrap-reverse gap-6 items-end content-start" }; case "bottom-center": return { outer: "justify-end items-center pb-20 w-full", inner: "flex flex-row flex-wrap-reverse gap-6 justify-center items-end content-start" }; case "bottom-right": return { outer: `justify-end items-end pb-20 ${q}`, inner: "flex flex-row-reverse flex-wrap-reverse gap-6 items-end content-start" }; default: return { outer: `justify-start items-start ${$} ${q} h-full`, inner: "flex flex-col flex-wrap gap-6 content-start items-start h-[calc(100vh-6rem)]" } } })(); return t ? r ? m.jsxs("div", {
    className: "w-screen h-screen overflow-hidden relative font-sans", style: { background: N.background, backgroundSize: "cover", backgroundPosition: "center", fontFamily: N.font }, onClick: () => { p(!1), x && !b && He(!1) }, children: [m.jsx("div", { className: G(), children: g.map(_ => m.jsx(IT, { notification: _, onDismiss: ns, theme: N, isMobile: b }, _.id)) }), b ? m.jsxs(m.Fragment, { children: [m.jsx("div", { className: `fixed inset-0 z-[10005] bg-black/60 backdrop-blur-sm transition-opacity duration-300 ${x ? "opacity-100 pointer-events-auto" : "opacity-0 pointer-events-none"}`, onClick: () => He(!1) }), m.jsxs("div", { className: "fixed left-0 right-0 bottom-0 z-[10006] bg-[#111] rounded-t-3xl m-0 shadow-[0_-10px_40px_rgba(0,0,0,0.8)] border-t border-white/10 transform will-change-transform select-none", style: { height: "80vh", transition: V ? "none" : "transform 0.4s cubic-bezier(0.16, 1, 0.3, 1)", transform: V ? `translateY(${O}px)` : x ? "translateY(0)" : "translateY(110%)" }, onClick: _ => _.stopPropagation(), children: [m.jsx("div", { className: "w-full h-10 flex items-center justify-center cursor-grab active:cursor-grabbing touch-none", onMouseDown: _ => Et(_, !0), onTouchStart: _ => Et(_, !0), children: m.jsx("div", { className: "w-12 h-1.5 bg-gray-700 rounded-full" }) }), m.jsxs("div", { className: "flex justify-between items-center px-6 py-2 border-b border-white/5", children: [m.jsx("h2", { className: "text-lg font-bold text-white", children: "Notifications" }), w.length > 0 && m.jsx("button", { onClick: Gt, className: "text-xs text-red-400", children: "Clear" })] }), m.jsx("div", { className: "overflow-y-auto p-4 space-y-3 h-[calc(100%-80px)] pb-20 touch-pan-y", children: w.length === 0 ? m.jsx("div", { className: "text-center text-gray-500 mt-20", children: "No new notifications" }) : w.map(_ => m.jsxs("div", { className: "bg-white/5 border border-white/5 p-4 rounded-xl", children: [m.jsxs("div", { className: "flex justify-between mb-1", children: [m.jsx("span", { className: "text-xs font-bold text-blue-400", children: _.appName || "System" }), m.jsx("span", { className: "text-[10px] text-gray-500", children: new Date(_.timestamp).toLocaleTimeString() })] }), m.jsx("div", { className: "font-semibold text-sm text-gray-200", children: _.title }), m.jsx("div", { className: "text-xs text-gray-400 mt-1", children: _.message }), _.action && m.jsx("button", { onClick: () => { _.action && _.action(), He(!1) }, className: "mt-3 text-xs bg-white/10 px-3 py-1.5 rounded-lg text-white w-full", children: "View" })] }, _.id)) })] })] }) : m.jsxs("div", { onClick: _ => _.stopPropagation(), className: `fixed top-0 bottom-0 right-0 w-80 z-[10005] transition-transform duration-300 ease-in-out flex flex-col shadow-2xl ${x ? "translate-x-0" : "translate-x-full"}`, style: { backgroundColor: N.taskbarBg, backdropFilter: "blur(30px)", borderLeft: N.windowBorder, fontFamily: N.font }, children: [m.jsxs("div", { className: "p-4 border-b border-white/10 flex justify-between items-center", children: [m.jsx("h2", { className: "font-bold text-white text-sm", children: "Notification Center" }), m.jsxs("div", { className: "flex gap-2", children: [w.length > 0 && m.jsx("button", { onClick: Gt, className: "text-xs text-gray-400 hover:text-white transition-colors", title: "Clear All", children: m.jsx("span", { className: "material-symbols-rounded text-[18px]", children: "delete" }) }), m.jsx("button", { onClick: () => He(!1), className: "text-gray-400 hover:text-white transition-colors", children: m.jsx("span", { className: "material-symbols-rounded text-[20px]", children: "close" }) })] })] }), m.jsx("div", { className: "flex-1 overflow-y-auto p-3 space-y-2", children: w.length === 0 ? m.jsxs("div", { className: "flex flex-col items-center justify-center h-48 text-gray-500", children: [m.jsx("span", { className: "material-symbols-rounded text-4xl mb-2 opacity-30", children: "notifications_off" }), m.jsx("p", { className: "text-xs", children: "No notifications" })] }) : w.map(_ => m.jsxs("div", { className: "bg-white/5 border border-white/5 rounded-lg p-3 hover:bg-white/10 transition-colors", children: [m.jsx("div", { className: "flex justify-between items-start mb-1", children: m.jsxs("div", { className: "flex items-center gap-2", children: [m.jsx("span", { className: "text-[10px] bg-white/10 px-1.5 py-0.5 rounded text-gray-300 font-mono", children: _.appName || "System" }), m.jsx("span", { className: "text-[10px] text-gray-500", children: new Date(_.timestamp).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }) })] }) }), m.jsx("h4", { className: "text-sm font-bold text-gray-200 mb-0.5", children: _.title }), m.jsx("p", { className: "text-xs text-gray-400", children: _.message }), _.action && m.jsx("button", { onClick: _.action, className: "mt-2 text-[10px] text-blue-400 hover:text-blue-300 hover:underline", children: "View Action" })] }, _.id)) })] }), k && m.jsx("div", { className: "fixed inset-0 z-[10010] bg-black/60 backdrop-blur-sm flex items-center justify-center p-4", children: m.jsxs("div", { className: "bg-[#111] border border-gray-800 rounded-2xl w-full max-w-lg shadow-2xl overflow-hidden animate-slide-up flex flex-col max-h-[70vh] md:max-h-[85vh]", children: [m.jsxs("div", { className: "relative h-32 bg-gradient-to-br from-indigo-900 to-black p-6 flex flex-col justify-end flex-shrink-0", children: [m.jsx("div", { className: "absolute top-4 right-4 text-white/20", children: m.jsx("span", { className: "material-symbols-rounded text-6xl", children: "eco" }) }), m.jsx("h2", { className: "text-3xl font-bold text-white", children: "What's New" }), m.jsx("p", { className: "text-indigo-300 text-sm", children: "SaikouOS Bellflower (v1.5.1)" })] }), m.jsxs("div", { className: "p-6 space-y-6 overflow-y-auto custom-scroll flex-1", children: [m.jsxs("div", { className: "flex gap-4", children: [m.jsx("div", { className: "w-10 h-10 rounded-full bg-slate-800 flex items-center justify-center flex-shrink-0 text-white shadow-lg", children: m.jsx("span", { className: "material-symbols-rounded", children: "lock_open" }) }), m.jsxs("div", { children: [m.jsx("h3", { className: "text-white font-bold text-sm", children: "Decipher App" }), m.jsx("p", { className: "text-gray-400 text-xs mt-1", children: "Decrypt some common, easy to brute force codes with our new crypto analysis tool." })] })] }), m.jsxs("div", { className: "flex gap-4", children: [m.jsx("div", { className: "w-10 h-10 rounded-full bg-blue-600 flex items-center justify-center flex-shrink-0 text-white shadow-lg", children: m.jsx("span", { className: "material-symbols-rounded", children: "public" }) }), m.jsxs("div", { children: [m.jsx("h3", { className: "text-white font-bold text-sm", children: "World Clock" }), m.jsx("p", { className: "text-gray-400 text-xs mt-1", children: "Keep track of global timezones so you never have to wonder what time it is for any member of your team." })] })] }), m.jsx("div", { className: "w-full h-px bg-white/10 my-2" }), m.jsxs("div", { className: "flex gap-4", children: [m.jsx("div", { className: "w-10 h-10 rounded-full bg-gradient-to-br from-blue-500 to-cyan-400 flex items-center justify-center flex-shrink-0 text-white shadow-lg shadow-blue-500/20", children: m.jsx("span", { className: "material-symbols-rounded", children: "smart_toy" }) }), m.jsxs("div", { children: [m.jsx("h3", { className: "text-white font-bold text-sm", children: "Kaiou Integration" }), m.jsx("p", { className: "text-gray-400 text-xs mt-1", children: "Meet Kaiou, the SDIS AI Assistant. Click the robot icon in any window to access rapid analysis, threat detection, and more." })] })] }), m.jsxs("div", { className: "flex gap-4", children: [m.jsx("div", { className: "w-10 h-10 rounded-full bg-gray-800 flex items-center justify-center flex-shrink-0 text-white", children: m.jsx("span", { className: "material-symbols-rounded", children: "settings" }) }), m.jsxs("div", { children: [m.jsx("h3", { className: "text-white font-bold text-sm", children: "Enhanced Settings" }), m.jsx("p", { className: "text-gray-400 text-xs mt-1", children: "Configure your Gemini API key directly in settings to power Kaiou." })] })] }), m.jsxs("div", { className: "flex gap-4", children: [m.jsx("div", { className: "w-10 h-10 rounded-full bg-gray-800 flex items-center justify-center flex-shrink-0 text-white", children: m.jsx("span", { className: "material-symbols-rounded", children: "dock_to_left" }) }), m.jsxs("div", { children: [m.jsx("h3", { className: "text-white font-bold text-sm", children: "Sleek Sidebar" }), m.jsx("p", { className: "text-gray-400 text-xs mt-1", children: "Kaiou now lives in a sleek, collapsible sidebar right next to your content." })] })] }), m.jsxs("div", { className: "flex gap-4", children: [m.jsx("div", { className: "w-10 h-10 rounded-full bg-gray-800 flex items-center justify-center flex-shrink-0 text-white", children: m.jsx("span", { className: "material-symbols-rounded", children: "build" }) }), m.jsxs("div", { children: [m.jsx("h3", { className: "text-white font-bold text-sm", children: "System Optimizations" }), m.jsx("p", { className: "text-gray-400 text-xs mt-1", children: "Improved window management limits and streamlined mobile navigation." })] })] }), m.jsxs("div", { className: "flex gap-4", children: [m.jsx("div", { className: "w-10 h-10 rounded-full bg-gray-800 flex items-center justify-center flex-shrink-0 text-white", children: m.jsx("span", { className: "material-symbols-rounded", children: "palette" }) }), m.jsxs("div", { children: [m.jsx("h3", { className: "text-white font-bold text-sm", children: "Visual Refinements" }), m.jsx("p", { className: "text-gray-400 text-xs mt-1", children: "We've switched to Material Symbols for a cleaner, more consistent look across the OS." })] })] }), m.jsxs("div", { className: "flex gap-4", children: [m.jsx("div", { className: "w-10 h-10 rounded-full bg-gray-800 flex items-center justify-center flex-shrink-0 text-white", children: m.jsx("span", { className: "material-symbols-rounded", children: "tune" }) }), m.jsxs("div", { children: [m.jsx("h3", { className: "text-white font-bold text-sm", children: "Mobile Experience" }), m.jsx("p", { className: "text-gray-400 text-xs mt-1", children: "Notifications are now less obtrusive, and the app grid has better spacing for scrolling." })] })] }), m.jsxs("div", { className: "flex gap-4", children: [m.jsx("div", { className: "w-10 h-10 rounded-full bg-gray-800 flex items-center justify-center flex-shrink-0 text-white", children: m.jsx("span", { className: "material-symbols-rounded", children: "egg" }) }), m.jsxs("div", { children: [m.jsx("h3", { className: "text-white font-bold text-sm", children: "Secret Modes" }), m.jsx("p", { className: "text-gray-400 text-xs mt-1", children: "Can you find the hidden developer easter eggs?" })] })] }), m.jsxs("div", { className: "flex gap-4", children: [m.jsx("div", { className: "w-10 h-10 rounded-full bg-gradient-to-br from-purple-500 to-pink-500 flex items-center justify-center flex-shrink-0 text-white shadow-lg", children: m.jsx("span", { className: "material-symbols-rounded", children: "style" }) }), m.jsxs("div", { children: [m.jsx("h3", { className: "text-white font-bold text-sm", children: "Custom Themes" }), m.jsx("p", { className: "text-gray-400 text-xs mt-1", children: "Mix and match layouts, fonts, and colors in Settings to create your perfect setup." })] })] })] }), m.jsx("div", { className: "p-6 pt-2 border-t border-white/5 bg-[#111] flex-shrink-0", children: m.jsx("button", { onClick: () => A(!1), className: "w-full bg-white text-black font-bold py-3 rounded-xl hover:opacity-90 transition-opacity", children: "Awesome!" }) })] }) }), m.jsxs("div", {
      className: `absolute inset-0 z-0 flex flex-col pointer-events-none ${Pn.outer}`, children: [m.jsx("div", {
        className: `flex-1 pointer-events-auto ${Pn.inner}`, style: !b && (N.desktopAlignment === "middle-left" || N.desktopAlignment === "middle-right") ? { width: "auto" } : {}, children: ke.map(_ => m.jsxs("div", {
          onClick: U => { U.stopPropagation(), An(_) }, className: `
                        flex flex-col items-center justify-start group cursor-pointer transition-transform duration-200 active:scale-95
                        ${b ? "w-full mb-4" : "w-24 h-28"}
                    `, children: [m.jsx("div", {
            className: `
                        flex items-center justify-center shadow-lg bg-gradient-to-br ${_.color} text-white
                        ${b ? "w-14 h-14 text-2xl mb-1" : "w-16 h-16 text-3xl mb-2 hover:scale-105 transition-transform"}
                      `, style: Yn(N.iconShape || "squircle"), children: _.icon.includes(" ") ? m.jsx("i", { className: _.icon, style: _.iconStyle }) : m.jsx("span", { className: `material-symbols-rounded ${b ? "text-3xl" : "text-4xl"}`, style: _.iconStyle, children: _.icon })
          }), m.jsx("span", {
            className: `
                        text-center font-medium leading-tight text-white drop-shadow-md line-clamp-2 h-8 flex items-start justify-center overflow-hidden px-1
                        ${b ? "text-[9px]" : "text-xs"}
                        ${wr ? "bg-black/50 rounded" : ""}
                    `, children: _.title
          })]
        }, _.id))
      }), fe > 1 && N.desktopAlignment !== "dock" && m.jsx("div", { className: `flex gap-2 pointer-events-auto justify-center w-full z-10 ${b ? "pb-20" : "pb-6"}`, children: Array.from({ length: fe }).map((_, U) => m.jsx("button", { onClick: () => C(U), className: `w-2 h-2 rounded-full transition-all ${E === U ? "bg-white scale-125" : "bg-white/30 hover:bg-white/60"}` }, U)) })]
    }), c.map(_ => { const U = Dn.find($ => $.id === _.appId); return U ? m.jsx(Oy, { window: _, theme: N, isMobile: b, onClose: xr, onMinimize: qt, onMaximize: Rn, onFocus: vr, onUpdatePosition: os, onAskKaiou: rs, hasKaiouAccess: !!s, children: U.component === "settings" ? m.jsx(Zy, { currentTheme: N, setTheme: yo, updateTheme: yr, onOpenUpdateLog: () => A(!0), systemStartTime: h, isMobile: b }) : m.jsx("iframe", { src: U.url, className: "w-full h-full border-none", title: U.title }) }, _.id) : null }), !b && m.jsx(Xy, { isOpen: f, theme: N, apps: vo, user: s, onOpenApp: _ => { An(_), p(!1) }, onLogout: () => i(!1), isMac: ss }), m.jsx(Qy, { theme: N, isMobile: b, windows: c, menuOpen: f, setMenuOpen: p, time: Ce, activeWindowId: Ht == null ? void 0 : Ht.id, minimizeWindow: qt, maximizeWindow: Rn, focusWindow: vr, setLoggedIn: i, handleMobileHome: is, allApps: Dn, toggleNotifications: () => He(!x), hasUnread: v, notifPanelOpen: x }), ss && !b && m.jsxs("div", { className: "fixed top-0 left-0 right-0 h-7 bg-black/20 backdrop-blur-md flex items-center justify-between px-3 z-[9999] text-xs font-medium text-white shadow-sm border-b border-white/5", children: [m.jsxs("div", { className: "flex gap-4 items-center h-full", children: [m.jsx("button", { className: "flex items-center justify-center w-8 h-full hover:bg-white/10 transition-colors cursor-default font-bold text-lg drop-shadow-md", children: m.jsx("span", { className: "material-symbols-rounded text-[18px]", children: "widgets" }) }), xo && m.jsx("span", { className: "font-bold opacity-90 drop-shadow-sm", children: xo })] }), m.jsxs("div", { className: "flex gap-4 items-center opacity-90 font-semibold h-full drop-shadow-md", children: [m.jsx("span", { children: Ce.toLocaleDateString([], { weekday: "short", month: "short", day: "numeric" }) }), m.jsx("span", { children: Ce.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }) }), m.jsx("button", { onClick: _ => { _.stopPropagation(), He(!x) }, className: `h-full px-2 hover:bg-white/10 transition-colors flex items-center justify-center ${x ? "text-blue-400" : ""}`, children: m.jsx("span", { className: `material-symbols-rounded text-[20px] ${v && !x ? "fill-1" : ""}`, children: "notifications" }) })] })] })]
  }) : m.jsxs("div", { className: "fixed inset-0 flex items-center justify-center animate-[fadeIn_0.5s_ease-out] bg-black", children: [m.jsx("div", { className: "absolute inset-0 opacity-50 transition-all duration-1000", style: { backgroundImage: N.background, backgroundSize: "cover", backgroundPosition: "center", filter: "blur(20px) brightness(0.7)" } }), m.jsx("div", { className: "relative z-10 w-full max-w-sm mx-4", children: m.jsxs("div", { className: "bg-black/30 backdrop-blur-2xl border border-white/10 p-8 rounded-3xl shadow-[0_25px_50px_-12px_rgba(0,0,0,0.5)]", children: [m.jsxs("div", { className: "text-center mb-8", children: [m.jsx("h2", { className: "text-2xl font-bold text-white mb-1 tracking-tight", children: "Sign In to SDIS" }), m.jsx("p", { className: "text-gray-400 text-xs font-medium", children: "Please verify your identity" })] }), m.jsxs("div", { className: "space-y-4", children: [m.jsxs("div", { className: "relative group", children: [m.jsx("input", { type: "password", value: se, onChange: _ => ht(_.target.value), onKeyDown: _ => _.key === "Enter" && $t(!1), className: "w-full bg-white/5 border border-white/10 text-white px-4 py-3.5 rounded-xl outline-none focus:border-blue-500/50 focus:bg-white/10 transition-all text-sm pl-10 placeholder-gray-600", placeholder: "Enter Passphrase" }), m.jsx("span", { className: "material-symbols-rounded absolute left-3.5 top-1/2 -translate-y-1/2 text-gray-500 group-focus-within:text-blue-400 transition-colors text-[20px]", children: "lock" })] }), m.jsx("button", { onClick: () => $t(!1), disabled: mt, className: "w-full bg-white text-black font-bold py-3.5 rounded-xl hover:bg-gray-100 active:scale-[0.98] transition-all shadow-lg flex items-center justify-center gap-2", children: mt ? m.jsxs(m.Fragment, { children: [m.jsx("span", { className: "material-symbols-rounded animate-spin text-[20px]", children: "progress_activity" }), m.jsx("span", { children: "Verifying..." })] }) : m.jsx("span", { children: "Authenticate" }) }), m.jsxs("div", { className: "relative py-2", children: [m.jsx("div", { className: "absolute inset-0 flex items-center", children: m.jsx("div", { className: "w-full border-t border-white/10" }) }), m.jsx("div", { className: "relative flex justify-center text-xs", children: m.jsx("span", { className: "px-2 bg-transparent text-gray-500", children: "or" }) })] }), m.jsxs("button", { onClick: () => $t(!0), className: "w-full bg-white/5 border border-white/5 text-white font-medium py-3 rounded-xl hover:bg-white/10 hover:border-white/10 active:scale-[0.98] transition-all text-sm flex items-center justify-center gap-2 group", children: [m.jsx("span", { className: "material-symbols-rounded text-gray-400 group-hover:text-white transition-colors text-[20px]", children: "person" }), m.jsx("span", { children: "Continue as Guest" })] })] }), m.jsx("div", { className: "mt-6 text-center", children: m.jsxs("p", { className: "text-[10px] text-gray-600 flex items-center justify-center gap-1", children: [m.jsx("span", { className: "material-symbols-rounded text-[14px]", children: "shield" }), "Local preferences are saved to your browser."] }) })] }) })] }) : m.jsxs("div", { className: `fixed inset-0 bg-black flex flex-col items-center justify-center transition-opacity duration-1000 ${n ? "opacity-100" : "opacity-0"}`, children: [m.jsxs("h1", { className: "text-4xl font-bold tracking-widest text-white mb-6", style: { fontFamily: "Montserrat, sans-serif" }, children: ["Saikou", m.jsx("span", { className: "os-text-anim", children: "OS" })] }), m.jsx("div", { className: "w-64 h-1 bg-[#1a1a1a] rounded overflow-hidden", children: m.jsx("div", { className: "h-full bg-white animate-fill-bar" }) }), m.jsx("p", { className: "text-gray-500 text-[10px] font-mono uppercase tracking-wider mt-2", children: "Starting..." })] })
} const Ph = document.getElementById("root"); if (!Ph) throw new Error("Could not find root element to mount to"); const AT = Ls.createRoot(Ph); AT.render(m.jsx(Xh.StrictMode, { children: m.jsx(NT, {}) }));
